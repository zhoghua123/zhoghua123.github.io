---
layout: post
title: Java常用企业框架-Spring(五)
category: Java后端开发
tags: Java后端开发
description: Java后端开发
--- 

## 注解
### 注解实现bean标签
1. `@Component`   
    1. 相当于`<bean>`
    2. 通过value属性设置bean的id，默认会将类名的首字母小写形式作为bean的id
    3. `@Controller`用于标识控制器层，`@Service`用于标识业务层，`@Repository`用于标识Dao层
2. `@Scop`e：设置singleton、prototype
3. `@Lazy`：scope为singleton时延迟加载
4. 可以通过`<context：component-scan>`设置需要扫描的包，可以扫描到所有的`@Component`
    1. `@ComponentScan`：相当于`<context:component-scan>`标签 
5. 举例使用
    1. 在applicationContext.xml文件中设置需要扫描那些包含注解的文件
        
        ```
        <!--扫描指定包下面的所有注解-->
        <!--注意：只能扫描到domain下的文件，不能扫描dao、service、servlet层的文件，但是可以通过注解@ComponentScan来附加扫描其他文件-->
        <context:component-scan base-package="com.zh.domain"/>
        ```
    2. domain下的person类注解如下：
        
        ```
        //等价于bean标签，默认id为类名小写person
        @Component
        //指定bean的id为personx
        //@Component("personx")
        //在容器中是否唯一
        @Scope("singleton")
        //等价于标签的lazy-init = true
        @Lazy
        //让入口xml文件，附加扫描其它的包
        @ComponentScans({
                @ComponentScan("com.zh.service"),
                @ComponentScan("com.zh.dao"),
                @ComponentScan("com.zh.servlet")
        })
        public class Person {
        
        }
        ```  
    3. MyTest测试代码
        
        ```
        ApplicationContext ctx = new ClassPathXmlApplicationContext(
            "applicationContext.xml");
        System.out.println(ctx.getBean("person"));
        System.out.println(ctx.getBean("user"));
        System.out.println(ctx.getBean("userService"));
        ```
        
### 注解实现注入
1. `@Autowired`：默认按照类型注入bean实例
    1. 可以写在成员变量(不会调用setter)、setter、构造方法上
    2. 可以配合使用`@Qualifier`、`@Named`：设置需要注入的bean的id
    3. required设置为false：找不到对应的bean时不会抛出异常
2. `@Value`
    1. 用于注入String、基本类型、BigDecimal等类型
    2. 可以配合配置文件(比如properties)使用`${}`读取配置文件的内容
3. `@PropertySources、@PropertySource`
    1. 相当于`<context:property-placeholder>`
4. 构造方法
    1. 可以通过`@Autowired`指定创建bean时调用的构造方法
        
        ```
        public Student (){};
        //创建bean时会调用这个构造方法
        @Autowired
        public Student(@Value("zh") String name,
                       @Qualifier("dog") Dog dog){
            this.name = name;
            this.dog = dog;
        }
    
        //@Nullable会注入null值
        @Autowired
        public Student(@Nullable String name,
                       @Qualifier("dog") Dog dog){
            this.name = name;
            this.dog = dog;
        }
        ```
5. 举例使用：
    1. 注解User类
        
        ```
        @Component
        //导入配置文件，相当于<context:property-placeholder>，有了这个下面就可以使用配置文件中的动态引用了 @Value("${name}")
        @PropertySource("user.properties")
        public class User {
            //基本数据类型注入一个动态的值
            @Value("${name}")
            private String name;
        
            //也可以直接放到成员变量上，不用放到set方法上，甚至不用写set方法
            //@Autowired
            private Dog dog;
        
            //基本数据类型注入一个确定的值
            //@Value("jack")
            //也可以放在set方法前面
            //@Value("${name}")
            public void setName(String name) {
                this.name = name;
            }
        
            //自动注入
            //@Autowired
            //required = false：找不到bean对象不会报错
            @Autowired(required = false)
            //指定id值为dog的bean对象进行注入
            @Qualifier("dog")
            public void setDog(Dog dog) {
                this.dog = dog;
            }
        }
        ```
    2. user.properties内容
        
        ```
        name=Rose
        ```

### 注解实现AOP
1. `@Aspect`：用来标识一个切面类(切面类对象需要被放入到IoC容器中)
2. `@Around`：用来设置切入点(被注解的方法要有返回值、接收一个ProceedingJoinPoint参数)
3. 还需要加上`<aop:aspectj-autoproxy>`标签，替代之前的`<aop：config>`
    1. 同样有proxy-target-class属性设置AOP的底层实现方案（强制使用CGLib、按照默认做法）
    
    ```
    <!--替代之前的<aop：config>-->
    <aop:aspectj-autoproxy proxy-target-class="true"/>
    ```

#### 举例使用
1. service层如下：
    
    ```
    //接口
    public interface UserService {
        void list();
    }
    
    //实现
    @Service("userService")
    public class UserServiceImpl implements UserService {
        public void list() {
            System.out.println("UserServiceImpl - list");
        }
    }
    ```
2. 添加切面类
    
    ```
    //代表一个切面类
    @Aspect
    //放入到spring容器中去
    @Component
    public class DefaultAspect {
        //可以使用@Pointcut复用切入点，这里设置好切入点，其他地方引用。
        //1. 设置要切入的类
        @Pointcut("within(com.zh.service.impl.UserServiceImpl)")
        //2. 用一个空方法来代表切入点
        public void pc() {}
    
        //设置切入点，也可以直接使用@Around("within(com.zh.service.impl.UserServiceImpl)")
        @Around("pc()")
        //附加代码：必须要接收一个ProceedingJoinPoint类型参数，用来拿到目标对象，执行目标方法；而且必须要有返回值
        public Object log(ProceedingJoinPoint point) throws Throwable {
            System.out.println("log-----------------------1");
            // 调用目标方法
            Object ret = point.proceed();
            System.out.println("log-----------------------2");
            return ret;
        }
    
        //设置切入点
        @Around("pc()")
        public Object watch(ProceedingJoinPoint point) throws Throwable {
            System.out.println("watch-----------------------1");
            // 调用目标方法
            Object ret = point.proceed();
            System.out.println("watch-----------------------2");
            return ret;
        }
    }
    ```
3. applicationContext.xml
    
    ```
    <!--让spring扫描这个包下所有的类，用来解析注解-->
    <context:component-scan base-package="com.zh"/>

    <!--替代之前的<aop：config>-->
    <aop:aspectj-autoproxy proxy-target-class="false"/>
    ```

#### 如何将自定义的附加代码与注解混合使用
1. 自定义附加代码
    
    ```
    public class LogInterceptor implements MethodInterceptor {
        @Override
        public Object invoke(MethodInvocation invocation) throws Throwable {
            System.out.println("LogInterceptor-----------------------1");
    
            // 调用目标方法
            Object ret = invocation.proceed();
    
            System.out.println("LogInterceptor-----------------------2");
            return ret;
        }
    }
    ```
2. 通过applicationContext.xml配置，将附加代码也切入到注解类设置的切入点(`com.zh.service.impl.UserServiceImpl`)中
    
    ```
    <!--xml与注解混合使用-->
    <bean id="logInterceptor" class="com.zh.aop.LogInterceptor"/>

    <aop:config>
        <!--直接使用注解中的切入点
        将自定义的附加代码，切入到注解的切面类设置的切入点中
        -->
        <aop:pointcut id="pc" expression="com.zh.aop.DefaultAspect.pc()"/>
        <aop:advisor advice-ref="logInterceptor" pointcut-ref="pc"/>
        <!--替代上面的两句-->
        <!--        <aop:advisor advice-ref="logInterceptor" pointcut="com.zh.aop.DefaultAspect.pc()"/>-->
    </aop:config>
    ```

### 注解实现事务管理
1. `@Transactional`
    1. 可以在需要进行事务管理的类(比如Service) 上使用这个注解， 代表所有方法都会自动管理事务
    2. 可以在需要进行事务管理的方法上使用这个注解(可以覆盖类中@Transactional的配置)
    3. 可以设置isolation、propagation、imeout、rollback For、noRollbackFor、readOnly等属性
2. 使用`<tx:annotation-driven>`取代之前的`<tx:advice>`、`<aop:config>`
    1. 同样有proxy-target-class属性设置AOP的底层实现方案

#### 代码举例
1. 之前讲解的事务管理如下：
    
    ```
    <!-- 事务管理器 -->
    <bean id="txMgr"
          class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>
    <!-- 附加代码：事务管理代码 -->
    <tx:advice id="txAdvice" transaction-manager="txMgr">
        <tx:attributes>
            <tx:method name="*"/>
            <tx:method name="list*" propagation="SUPPORTS"/>
        </tx:attributes>
    </tx:advice>

    <!-- 切面 -->
    <aop:config>
        <aop:pointcut id="pc" expression="within(com.zh.service..*)"/>
        <aop:advisor advice-ref="txAdvice" pointcut-ref="pc"/>
    </aop:config>
    ```
2. 在service层设置事务管理注解
    
    ```
    @Service("skillService")
    //代表所有方法都需要添加事务管理
    @Transactional
    //可以设置事务的属性
    //@Transactional(isolation = )
    public class SkillServiceImpl implements SkillService {
        private SkillDao dao;
    
        @Autowired
        public void setDao(SkillDao dao) {
            this.dao = dao;
        }
    
        @Override
        //针对某个特定的方法，设置特别的属性值
        @Transactional(propagation = Propagation.SUPPORTS)
        public List<Skill> list() {
            return dao.list();
        }
    
        @Override
        public boolean save(Skill skill) {
            return dao.save(skill);
        }
    
        @Override
        public boolean update(Skill skill) {
            return dao.update(skill);
        }
    
        public void test(Skill skill) throws Exception {
    
            dao.save(skill);
    
            throw new RuntimeException();
        }
    }
    ```
3. 在applicationContext.xml配置如下
    
    ```
    <!-- 事务管理器 -->
    <bean id="txMgr"
          class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>
    <!--设置注解驱动
    取代之前的<tx:advice>、`<aop:config>
     -->
    <tx:annotation-driven transaction-manager="txMgr"/>
    <!--让spring扫描这个包下所有的类，用来解析注解-->
    <context:component-scan base-package="com.zh"/>
    ```

### @Configuration、@Bean
1. `@Configuration`：使用此注解的类，可以取代applicationContext.xml
    1. 它也是一个`@Component`， 所以可以通过component-scan扫描
2. 可以在`@Configuration`类中，使用`@Bean`修饰方法，进行bean对象的创建
    1. 默认情况下,方法名就是bean的id。也可以通过name、value属性设置bean的id
    2. 可以配合`@Scope`设置bean的创建次数
    
    ```
    //com.zh.cfg.BeanConfig
    //使用此注解的类，可以取代applicationContext.xml
    @Configuration
    public class BeanConfig {
        //使用@Bean修饰方法，进行bean对象的创建
        // 默认情况下,方法名就是bean的id。也可以通过name、value属性设置bean的id
        @Bean
        //通过name属性设置id
        //@Bean(name = "skillx")
        //可以配合@Scope设置bean的创建次数
        //@Scope("prototype")
        //@Lazy
        public Skill skill() {
            Skill skill = new Skill();
            return skill;
        }
    }
    ```

### @Bean方法的注入
1. 注意下面讲的所有**方法**都在BeanConfig中

#### 注入bean对象
1. 如果bean属性本身有@Autowired,那么直接new原来对象即可
    
    ```
    //Dog类
    //表明可以通过scan将该类创建对象并存放到IoC容器中
    @Component
    public class Dog {
    }
    //bean属性本身有@Autowired
    public class Person {
        private Dog dog;
        @Autowired
        public void setDog(Dog dog) {
            this.dog = dog;
        }
    }
    
    //直接new对象即可
    @Configuration
    public class BeanConfig {
        @Bean
        public Person person(){
            return new Person();
        }
    }
    ```
2. Spring会利用@Autowired技术，自动注入bean给@Bean方法的参数（**前提条件是IoC容器中必须有这个bean参数对象**）
    
    ```
    @Bean
    public Person person(Dog dog)  {
        Person person = new Person();
        person.setDog(dog);
        return person;
    }
    ```
3. 直接调用@Bean方法来注入
    
    ```
    @Bean
    public Dog dog() {
        return new Dog();
    }
    @Bean
    public Person person(Dog dog)  {
        Person person = new Person();
        //直接调用bean方法来注入
        person.setDog(dog());
        return person;
    }
    ```
    
    1. 这里有个细节：@Bean方法被直接调用多次,也能保证是singleton(同一个对象)
        1. 因为`@Configuration`底层使用了CGLib动态代理，对@Bean方法进行了增强处理
    


