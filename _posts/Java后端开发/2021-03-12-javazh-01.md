---
layout: post
title: Java语言基础(SE)-第三节 面向对象(三)
category: Java后端开发
tags: Java后端开发
description: Java后端开发
---

### 接口（Interface）
1. 接口的英文单词是 Interface， 这个单词是否很熟悉？
2. API（Application Programming Interface）
    1. 应用编程接口，提供给开发者调用的一组功能（无须提供源码）
3. Java 中的接口
    1. 一系列方法声明的集合
    2. 用来定义规范、标准
    3. **接口就相当于OC中的协议，自定一系列的标准，谁遵守，谁就要实现，只是OC中的协议是可以设置遵守者是否选择性的实现，这里接口一旦遵守是必须实现**
4. 接口中可以定义的内容
    1. 接口的定义：右击->new->interface,可以看到接口跟类特别相似，接口用interface修饰，类用class修饰
    2. 可以定义：抽象方法、常量、嵌套类型，从 Java 8 开始可以定义：默认方法、静态方法（类方法）
        1. 上述可以定义的内容都是隐式 public 的，因此可以省略 public 关键字
        2. 从 Java 9 开始可以定义 private 方法
    3. 常量可以省略 static、final
    4. 抽象方法可以省略 abstract,但默认是抽象方法
    5. 不能自定义构造方法、不能定义（静态）初始化块、不能实例化
    6. 举例
        1. 一个child要找家教，不限制职业，只需要家教具备2个能力：教编程、教足球即可
        2. 因此建立一个接口用来提供家教的标准
        3. 各种行业的对象要服从这个标准
        
        ```
        //接口JiaJiaoAble
        package com.zh;
        public interface JiaJiaoAble {
            //抽象方法、常量
            //public abstract void test1();
            //可以省略public abstract 
            //void test2();
            public final static int a = 10;
            //可以省略final static
            int b = 10;
            //嵌套类型
            class A{}
            //家教接口标准   
            public abstract void jaoBianCheng(Child child);
            public abstract void jaoZuQiu(Child child);
        }
            
        //孩子
        package com.zh;
        public class Child {
            private String name;
            //家教
            private JiaJiaoAble jiaJiao;
            public Child(String name) {
                this.name = name;
            }
            public String getName() {
                return name;
            }
            //此时的类型为接口的类型,传入的对象必须实现了该接口的方法
            public void setJiaJiao(JiaJiaoAble jiaJiao) {
                this.jiaJiao = jiaJiao;
            }
            //学习
            public void study() {
                jiaJiao.jaoBianCheng(this);
                jiaJiao.jaoZuQiu(this);
            }
        }
            
        //学生成为一个家教
        package com.zh;
        //implements 实现接口
        public class Student implements JiaJiaoAble {
            public void jaoBianCheng(Child child) {
                System.out.println("Student 教" + child.getName() + "编程");
            }
            public void jaoZuQiu(Child child) {
                System.out.println("Student 教" + child.getName() + "足球");
            }
        }
            
        //老师成为一个家教
        package com.zh;
        //implements 实现接口
        public class Teacher implements JiaJiaoAble {
            public void jaoBianCheng(Child child) {
                System.out.println("Teacher 教" + child.getName() + "编程");
            }
            public void jaoZuQiu(Child child) {
                System.out.println("Teacher 教" + child.getName() + "足球");
            }
        }
            
        //main函数
        public static void main(String[] args) {
            Child chi = new Child("jack");
            chi.setJiaJiao(new Student());
            chi.study();
            chi.setJiaJiao(new Teacher());
            chi.study();
            /* 打印
            Student 教jack编程
            Student 教jack足球
            Teacher 教jack编程
            Teacher 教jack足球
            */
        }
        ```
5. 接口的细节
    1. 接口名称可以在任何**使用类型的地方**使用
        
        ```
        int a = 10;
        JiaJiaoAble jia;
        ```
    2. 一个类可以通过 implements 关键字实现一个或多个接口,多个接口用逗号隔开
        1. 实现接口的类必须实现接口中定义的所有抽象方法，除非它是个抽象类
        2. 如果一个类实现的多个接口中有相同的抽象方法，只需要实现此方法一次
        3. extends 和 implements 可以一起使用，implements 必须写在 extends 的后面
        4. 当父类和接口中的方法签名一样时，那么返回值类型也**必须**一样
            1. 就是两个方法必须一模一样
    3. 一个接口可以通过 extends 关键字继承一个或者多个接口
        1. 当多个父接口中的方法签名一样时，那么返回值类型也**必须**一样
            1. 就是两个方法必须一模一样
        
        ```
        public class Dog extends Animal implements Eatable {
            @Override
            public void eat(String name) {
            }
        }
        public class Student implements JiaJiaoAble , BaoMu{
            ...
        }
        ```
6. 接口的升级问题
    1. 如果接口需要升级，比如增加新的抽象方法
        1. 会导致大幅的代码改动，以前实现接口的类都得改动
    2. 若想在不改动以前实现类的前提下进行接口升级，从 Java 8 开始，有 2 种方案
        1. 默认方法（Default Method）
        2. 静态方法（Static Method）

#### 默认方法（Default Method）
1. 用 default 修饰默认方法
    1. 默认方法只能是实例方法
    2. 默认方法可以直接在接口中实现，继承者可以不用实现，也可以覆盖实现
    
    ```
    //接口
    package com.zh;
    public interface Eatable {
        default void eat(String name) {
            System.out.println("Eatable - eat - " + name);
        }	
    }
    //Dog
    package com.zh;
    public class Dog implements Eatable {
    }
    //Cat
    package com.zh;
    public class Cat implements Eatable {
        @Override
        public void eat(String name) {
            //先调用接口的实现，接口名称调用
            Eatable.super.eat(name);
            System.out.println("Cat - eat - " + name);
        }
    }
    
    //main函数
    public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat("bone");
        Cat cat = new Cat();
        cat.eat("fish");
    }
    //打印
    Eatable - eat - bone
    Eatable - eat - fish
    Cat - eat - fish
    ```
3. 默认方法的使用
    1. 当一个类实现的接口中有默认方法时，这个类可以
        1. 啥也不干，沿用接口的默认实现:`dog.eat("bone");`
        2. 重新定义默认方法，覆盖默认方法的实现: `cat.eat("fish");`
        3. 重新声明默认方法，将默认方法声明为抽象方法（此类必须是抽象类）
            1. 就是Dog首先用abstract修饰成为抽象类
            2. 然后声明一个抽象方法`public abstract void eat(String name);`
    2. 当一个接口继承的父接口中有默认方法时，这个接口可以
        1. 啥也不干，沿用接口的默认实现
        2. 重新定义默认方法，覆盖默认方法的实现
        3. 重新声明默认方法，将默认方法声明为抽象方法
4. 默认方法的细节
    1. 如果父类定义的非抽象方法与接口的默认方法相同时，最终将调用父类的方法
    2. 如果父类定义的抽象方法与接口的默认方法相同时，要求子类实现此抽象方法
        1. 可以通过 super 关键字调用接口的默认方法
    3. 如果（父）接口定义的默认方法与其他（父）接口定义的方法相同时，要求子类型实现此默认方法

![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/javazh-07.png) 

#### 静态方法（Static Method）
1. 接口中定义的静态方法只能通过接口名调用，不能被继承
    1. 不能被继承意思是，A接口有静态方法a，B接口继承A接口，`B.a()`，调用，是错误的，不能继承
    
    ```
    //接口Eatable
    package com.zh;
    public interface Eatable {
        static void eat(String name) {
            System.out.println("Eatable - eat - " + name);
        }	
    }
    
    //接口Sleepable
    package com.zh;
    public interface Sleepable {
        static void eat(String name) {
            System.out.println("Sleepable - eat - " + name);
        }
    }
    
    //接口Dog
    package com.zh;
    public interface Dog extends Sleepable, Eatable {
        static void eat(String name) {
            System.out.println("Dog - eat - " + name);
        }	
    }
    
    //类Cat
    package com.zh;
    public class Cat implements Eatable {
    }
    
    //main函数
    Dog.eat("1");
    Eatable.eat("2");
    Sleepable.eat("3");
    //尽管Cat实现Eatable接口，但是却无法通过Cat的任何方式去调用Eatable的接口方法
    //错误
    Cat.eat();
    Cat cat = new Cat();
    //错误
    cat.eat();
    /*
    Dog - eat - 1
    Eatable - eat - 2
    Sleepable - eat - 3
    */
    ```

#### 抽象类与接口对比
1. 抽象类和接口的用途还是有点类似，该如何选择？
2. 何时选择抽象类？
    1. 在紧密相关的类之间共享代码
    2. 需要除 public 之外的访问权限
        1. 接口所有的成员都是public
    3. 需要定义实例变量、非 final 的静态变量
        1. 接口只能定义常量
3. 何时选择接口？
    1. 不相关的类实现相同的方法
    2. 只是定义行为，不关心具体是谁实现了行为
    3. 想实现类型的多重继承
        1. **类的继承只能单继承，不能多继承**
        2. 接口可以多继承，类只能单继承

### 多态（Polymorphism）
1. 什么是多态？
    1. 具有多种形态
    2. 同一操作作用于不同的对象，产生不同的执行结果
2. 多态的体现
    1. 父类（接口）类型指向子类对象
    2. 调用子类重写的方法
3. JVM 会根据引用变量指向的具体对象来调用对应的方法
    1. 这个行为叫做：虚方法调用（virtual method invocation）
    2. 类似于 C++ 中的虚函数调用
4. 多态实例

    ```
    package com.zh;
    public class Animal {
        public void speak() {
            System.out.println("Animal - speak");
        }
    }
    
    package com.zh;
    public class Dog extends Animal {
        public void speak() {
            System.out.println("Dog - speak");
        }
    }
    
    package com.zh;
    public class Cat extends Animal {
        public void speak() {
            System.out.println("Cat - speak");
        };
    }
    
    /*********以上是类的集成体系，一下是接口的实现体系*******/

    package com.zh;
    public interface Runnable {
        void run();
    }
    
    package com.zh;
    public class Pig implements Runnable {
        @Override
        public void run() {
            System.out.println("Pig - run");
        }
    }
   
    package com.zh;
    public class Person implements Runnable {
        @Override
        public void run() {
            System.out.println("Person - run");
        }
    }
    
    //main函数
    public static void main(String[] args) {
        speak(new Dog()); //Dog - speak
        speak(new Cat()); //Cat - speak
        run(new Pig()); //Pig - run
        run(new Person()); //Person - run
    }
    static void speak(Animal animal) {
        animal.speak();
    }
    static void run(Runnable runnable) {
        runnable.run();
    }
    ```

#### 类方法的调用细节
1. 静态（类）方法不能实现多态

    ```
    public class Animal {
        public static void run() {
            System.out.println("Animal - run");
        }
    }
    public class Dog extends Animal {
        public static void run() {
            System.out.println("Dog - run");
        }
    }
    Dog.run(); //Dog - run
    Animal.run(); //Animal - run
    Dog dog1 = new Dog();
    dog1.run();//Dog - run
    //静态方法不能实现多态
    Animal dog2 = new Dog();
    dog2.run();//Animal - run
    ```
2. 多态只适用于实例

#### 成员变量的访问细节

![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/javazh-08.png) 


### instanceof
1. 可以通过 instanceof 判断某个类型是否属于某种类型
    
    ```
    public class Animal {}
    //接口
    public interface Runnable {}
    public class Dog extends Animal implements Runnable {}
    Object dog = new Dog();
    System.out.println(dog instanceof Dog); //true
    System.out.println(dog instanceof Animal); //true
    System.out.println(dog instanceof Runnable);//true
    System.out.println(dog instanceof String);//false
    ```
2. instanceof 使用
    
    ```
    public class Cat extends Animal {
        public void miao() {
            System.out.println("Cat-miao");
        }
    }
    public class Dog extends Animal{
        public void wang() {
            System.out.println("Dog-wang");
        }
    }
    
    speak(new Dog()); //Dog-wang
    speak(new Cat()); //Cat-miao
    public static void speak(Animal animal) {
        if (animal instanceof Dog) {
            ((Dog) animal).wang();
        }else {
            ((Cat) animal).miao();
        }
    }
    ```

