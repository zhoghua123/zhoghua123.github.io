---
layout: post
title: Java常用企业框架-SpringMVC(一)
category: Java后端开发
tags: Java后端开发
description: Java后端开发
--- 

### SpringMVC简介
1. SpringMVC的正式名称是Spring Web MVC
    1. 是属于Spring框架的一部分
    2. 是基于Server API的Web框架
2. SpringMVC的**核心**功能：**拦截和处理客户端的请求**
3. 官方参考文档
    1. [https://docs.spring.io/spring-framework/docs/current/reference/html/web.html](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html)
4. 特点：必须是JAVAEE项目


### 入门
1. 创建一个javaEE项目（略）
2. 添加依赖
    
    ```
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-webmvc</artifactId>
        <version>5.2.8.RELEASE</version>
    </dependency>
    ```
    
    1. spring-webmvc依赖于
        
        ```
        spring-aop
        spring-beans
        spring-context
        spring-core
        spring-expression
        spring-web
        ```
    2. 添加后的依赖如下
        
        ```
        <!-- 打包方式-->
        <packaging>war</packaging>
        <!-- JavaEE依赖-->
        <dependencies>
            <dependency>
                <groupId>javax.servlet</groupId>
                <artifactId>javax.servlet-api</artifactId>
                <version>4.0.1</version>
                <scope>provided</scope>
            </dependency>
            <dependency>
                <groupId>javax.servlet</groupId>
                <artifactId>jsp-api</artifactId>
                <version>2.0</version>
                <scope>provided</scope>
            </dependency>
    
            <!-- SpringMVC依赖-->
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-webmvc</artifactId>
                <version>5.2.8.RELEASE</version>
            </dependency>
            <!-- 日志-->
            <dependency>
                <groupId>ch.qos.logback</groupId>
                <artifactId>logback-classic</artifactId>
                <version>1.2.3</version>
            </dependency>
            <!-- 单元测试-->
            <dependency>
                <groupId>junit</groupId>
                <artifactId>junit</artifactId>
                <version>4.13.2</version>
                <scope>test</scope>
            </dependency>
        </dependencies>
        ```
3. web.xml配置DispatcherServlet
    
    ```
    <!-- 1. 配置SpringMVC自带的DispatcherServlet,用来拦截请求
    这里是web项目的入口
    -->
    <servlet>
        <servlet-name>springmvc</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <!--1.2 加载Spring的IoC容器 -->
        <!-- 创建servelt时，加载Spring的配置文件位置 -->
        <!-- 如果不写xml的具体位置classpath，则默认会去加载/WEB-INF/${servlet-name}-servlet.xml -->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:applicationContext.xml</param-value>
        </init-param>
        <!--1.3 设置servelt的创建时刻 -->
        <!-- 项目一旦部署到服务器，就会创建Servlet
        因为DispatcherServlet比较重，需要加载IoC容器，如果不设置默认是在客户端第一次发送请求的时候创建这个servlet
        因此我们想要在部署到服务器的时候就创建这个servlet
         -->
        <load-on-startup>0</load-on-startup>
    </servlet>

    <!--2 设置拦截器 -->
    <servlet-mapping>
        <servlet-name>springmvc</servlet-name>
        <!-- 拦截除开JSP以外所有请求 -->
        <url-pattern>/</url-pattern>
    </servlet-mapping>
    ```
    
    1. 与之前的JavaEE项目相比，这里使用的是SpringMVC自带的servlet
    2. 设置初始化servlet时要加载的IoC容器路径
    3. 设置servelt的创建时刻
    4. 设置要拦截的客户端请求
4. 创建IoC容器入口`applicationContext.xml`
    
    ```
    <context:component-scan base-package="com.zh"/>
    ```
5. 新建Controller
 
    ```
    //代表是控制器
    @Controller
    public class UserController {
        //拦截哪个路径
        @RequestMapping("/addUser")
        //返回值作为响应体直接返回给客户端
        @ResponseBody
        public String add() {
            return "Add Success!";
        }
    
        @RequestMapping("/getUser")
        @ResponseBody
        public String get() {
            return "Get Success!";
        }
    
        @RequestMapping("/removeUser")
        @ResponseBody
        public String remove() {
            return "Remove Success!";
        }
    }
    ```
    
    1. 以上完成，点击部署即可
    2. 当客户端发送`context_path/addUser、getUser、removeUser`（无论是get还是post请求），都会到响应的方法，然后将数据响应给客户端
6. `@RequestMapping`
    1. `@RequestMapping`可以用在类、方法上
        
        ```
        @Controller
        //用来类上,可以将/user/*下的所有请求都放在这个类中进行处理
        @RequestMapping("/user")
        public class UserController {
        
             // /user/add
            @RequestMapping("/add")
            @ResponseBody
            public String add() {
                return "UserController - Add Success!";
            }
            // /user/get
            @RequestMapping("/get")
            @ResponseBody
            public String get() {
                return "UserController - Get Success!";
            }
            // /user/remove
            @RequestMapping("/remove")
            @ResponseBody
            public String remove() {
                return "UserController - Remove Success!";
            }
        }
        ```
    2. `@PostMapping、@GetMapping`可以用在方法上，底层是基于`@RequestMapping`
        
        ```
        @Controller
        @RequestMapping("/user")
        public class UserControllerMethod {
        
            // /user/add
            //@RequestMapping用在方法上,只拦截post请求
            //@RequestMapping(value = "/add", method = RequestMethod.POST)
            //等价于上面
            @PostMapping("/add")
            @ResponseBody
            public String add() {
                return "UserController - Add Success!";
            }
        
            // /user/get
            //只拦截get请求
            //@RequestMapping(value = "/get", method = RequestMethod.GET)
            //等价于上面
            //可以拦截多个请求路径
            @GetMapping({"/get", "/list"})
            @ResponseBody
            public String get() {
                return "UserController - Get Success!";
            }
        }
        ```

