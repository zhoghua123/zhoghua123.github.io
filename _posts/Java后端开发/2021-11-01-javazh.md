---
layout: post
title: Java进阶-分布式框架通信核心基础
category: Java后端开发
tags: Java后端开发
description: Java后端开发
---  

## 序列化
1. 为什么需要序列化?
    1. 在JVM创建的对象是在内存当中, 当我们JVM停止运行, 释放内存以后, 对于JVM内存中的对象也会被销毁
    2. 但是在有些应用常见, 我们需要把对象的数据持久化保存起来, 我们就需要使用对应的序列化和反序列化技术
2. 常用序列化的场景
    1. 数据的持久化
    2. 数据的网络传输
3. 序列化与反序列化
    1. 序列化: 把内存中的对象信息转化为字节数组的过程
    2. 反序列化: 序列化的逆向操作, 把字节数组转换为对象的过程
4. 序列化框架选型的常用指标
    1. 序列化的字节数据大小
    2. 序列化的速度和系统资源开销

### JDK的序列化
1. **对于JDK的序列化对象一定要实现Serializable接口**
    1. 该接口并不需要实现任何方法，但是如果不实现该接口，运行时会报错
2. 代码举例
    1. User类如下
        
        ```
        @Data
        public class User implements Serializable {
            //为什么必须写这个属性，因为一旦动态修改user的属性，在进行烦序列化会报错
            private static final long serialVersionUID = 1657079049965088176L;
            private Integer age;
            private String name;
        }
        ```
    2. 封装一个接口与实现专门用来实现序列化、反序列化
        
        ```
        //接口
        package com.zh.demo.serdemo.ser;
        /**
         * 定义序列化接口
         */
        public interface ISerialize {
        
            /**
             * 序列化方法, 把一个对象转换为字节数组
             */
            <T> byte[] serialize(T obj);
        
            /**
             * 反序列方法, 把一个字节数组转换为一个对象
             */
            <T>  T deSerialize(byte[] buffer,Class<T> clazz);
        }
        
        //实现JdkSerialize
        package com.zh.demo.serdemo.ser.impl;
        import com.zh.demo.serdemo.ser.ISerialize;
        import java.io.*;
        public class JdkSerialize implements ISerialize {
        
            @Override
            public <T> byte[] serialize(T obj)  {
                //2 定义一个用于接收对象信息的字节数组输入流
                ByteArrayOutputStream bos = new ByteArrayOutputStream();
                //1 使用对象的输入流读取对象信息
                try {
                    //对象输出流, 传入对象输出的目的地
                    ObjectOutputStream oos = new ObjectOutputStream(bos);
                    //写入一个对象
                    oos.writeObject(obj);
                    //把字节数组流转换为字节数据
                    return bos.toByteArray();
                } catch (IOException e) {
                    e.printStackTrace();
                    throw  new  RuntimeException("序列化失败",e);
                }
            }
        
            @Override
            public <T> T deSerialize(byte[] buffer, Class<T> clazz) {
                //1 把字节数组转换为输入流
                ByteArrayInputStream bis = new ByteArrayInputStream(buffer);
                try {
                    ObjectInputStream ois = new ObjectInputStream(bis);
                    return (T) ois.readObject();
                } catch (Exception e) {
                    e.printStackTrace();
                    throw  new  RuntimeException("反序列化失败",e);
                }
            }
        }
        ```
        
        1. 本质：
            1. 序列化：将对象序列化为字节数组
            2. 反序列化： 将字节数组转换为对象
    3. 测试
        
        ```
        public class JdkSerializeTest {
            private ISerialize serialize=new JdkSerialize();
            //对象序列号
            @Test
            public void serialize() throws Exception {
                //创建一个对象
                User user = new User();
                user.setAge(21);
                user.setName("zh");
                byte[] datas = this.serialize.serialize(user);
                //数据的长度:194
                System.out.println("数据的长度:"+ datas.length);
                //保存到文件
                try(FileOutputStream fos = new FileOutputStream("user.dat");){
                    fos.write(datas);
                    fos.flush();
                }
            }
    
            //对象反序列化
            @Test
            public void deserialize() throws Exception {
                //反序列化
                byte[] buffer=new byte[1024];
                int len=-1;
                FileInputStream fis = new FileInputStream("user.dat");
                if((len=fis.read(buffer))>0){
                    buffer = Arrays.copyOf(buffer, len);
                    User u = serialize.deSerialize(buffer,User.class);
                    System.out.println("u = " + u);
                }
            }
        }
        ```
3. 注意事项
    1. serialVersionUID
        1. 被序列话的对象一定要自动生成serialVersionUID
        2. 生成方法
            1. idea偏好设置->Editor->inspections->右边搜索 Serializable class without 'serialVersionUID' 然后勾选 OK即可
            2. 在User类代码里面，鼠标点击User类名称，然后按住option/alt + 回车键，选择 add 'serialVersionUID' fiels ，会自动添加,id自动生成
                
                ```
                private static final long serialVersionUID = 1657079049965088176L;
                ```
        3. 为什么要添加呢？
            1. 如果在A场景已经将User的对象进行了序列化，但是后来在B场景修改了类，给这个类添加、删除了一些属性
            2. 等到再次进行反序列化获取时，会报错，因为如果没有写serialVersionUID属性，jdk会自动生成属性，一旦修改了原来类的属性，那么serialVersionUID就会自动修改，因此再次反序列化会找不到原来序列化存储的对象
            3. 专业讲解Java的序列化机制是通过判断类的 serialVersionUID 来验证版本一致性的。在进行反序列化时，JVM 会把传来的字节流中的 serialVersionUID与本地相应实体类的 serialVersionUID 进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常，即是 InvalidCastException如果没有为指定的 class 配置 erialVersionUID，那么 java 编译器会自动给这个 class 进行一个摘要算法，类似于指纹算法，只要这个文件有任何改动，得到的 UID 就会截然不同的，可以保证在这么多类中，这个编号是唯一的serialVersionUID 有两种显示的生成方式：一是默认的 1L，比如：private static final long serialVersionUID = 1L;二是根据类名、接口名、成员方法及属性等来生成一个 64 位的哈希字段当 实 现 java.io.Serializable 接 口 的 类 没 有 显 式 地 定 义 一 个serialVersionUID 变量时候，Java 序列化机制会根据编译的 Class 自动生成一个 serialVersionUID 作序列化版本比较用，这种情况下，如果Class 文件(类名，方法明等)没有发生变化(增加空格，换行，增加注释等等)，就算再编译多次，serialVersionUID 也不会变化的 
    2. 静态变量不会序列化
        1. 序列化保存的是对象的状态，静态变量属于类的状态，因此 序列化并不保存静态变量。
    3. 父类的序列化
        1. 一个子类实现了 Serializable 接口，它的父类都没有实现 Serializable,那么对于父类中的变量不会实现序列化操作；如果一个父类实现了Serializabla接口, 子类可以不用实现Serializable, 也会对对象的属性进行序列化操作
    4. transient
        1. 声明为transient的字段一般不会进行序列化, 对于一个敏感信息, 可以声明为transient
        2. 比如在User中添加一个pwd属性
            
            ```
            //声明为transient的字段一般不会进行序列化, 对于一个敏感信息, 可以声明transient
            private transient String pwd;
            ```

### 对象的深拷贝、浅拷贝
1. 浅克隆
    1. 被复制对象的所有变量都含有与原来的对象相同的值，而所有的**对其他对象的引用**仍然指向原来的对象。
    2. 实现步骤
        1. 实现Cloneable接口
        2. 实现clone方法, 修改一下方法权限为public
    
2. 深度克隆
    1. 克隆出来的对象都是不一样的, 引用的对象类型也是新的引用
    2. 实现步骤
        1. 所有对象都实现序列化的接口
        2. 自定义一个深度克隆方法deepClone, 通过字节数组流和对象流的方式实现对象的深度拷贝
3. 代码举例
    1. GirlfFriend、User类
    
        ```
        //GirlfFriend类
        @Data
        public class GirlfFriend implements Serializable {
            private String name;
        }
        //User类
        @Data
        public class User  extends Person implements Cloneable, Serializable {
            //为什么必须写这个属性，因为一旦动态修改user的属性，在进行烦序列化会报错
            private static final long serialVersionUID = 1657079049965088176L;
            private Integer age;
            private String name;
            //声明为transient的字段一般不会进行序列化, 对于一个敏感信息, 可以声明为transient
            private transient String pwd;
        
            private GirlfFriend gf;// oxa9bf 在浅拷贝的时候, 并没有创建一个新的对象, 拷贝的只是一个内存地址值
            
            //浅拷贝
            @Override
            public User clone() throws CloneNotSupportedException {
                return (User) super.clone(); //浅克隆, 只会拷贝内存地址值, 对弈引用类型, 还是同一个对象
            }
            
            //自己实现深拷贝
            public User deepClone(){
                //把对象序列化为字节数组
                ISerialize serialize = new JdkSerialize();
                //先序列化为一个字节输出
                byte[] bytes = serialize.serialize(this);//内存中
                //反序列化为一个对象，此时就是重新分配内存的新对象
                return serialize.deSerialize(bytes,User.class);//内存
            }
        }
        ```
    2. 测试
        
        ```
        public class CloneTest {

            @Test
            public void testClone() throws Exception {
                //1 创建一个User对象
                User jack = new User();
                jack.setName("jack");
                jack.setAge(18);
        
                GirlfFriend lucy = new GirlfFriend();
                lucy.setName("lucy");
                jack.setGf(lucy);
        
                //浅拷贝
                User jonh = jack.clone();
                //深度克隆
        //        User jonh = jack.deepClone();
                jonh.setAge(21);
                jonh.setName("jonh");
                jonh.getGf().setName("mary");
                //如果是浅拷贝，二者一样，jack、jonh的Gf都是mary，同一个人；反之，深拷贝，二者不一样
                System.out.println(jonh.getGf()==jack.getGf());
                System.out.println("jonh = " + jonh);
                System.out.println("jack = " + jack);
            }
        }
        ```

### Protobuf序列化
1. Protobuf是Google的一种数据交换格式，它独立于语言、独立于平台。Google 提供了多种语言来实现，比如 Java、C、Go、Python，每一种实现都包含了相应语言的编译器和库文件。
2. Protobuf 使用比较广泛，主要是空间开销小和性能比较好，非常适合用于公司内部对性能要求高的 RPC 调用。 
3. 另外由于解析性能比较高，序列化以后数据量相对较少，所以也可以应用在对象的持久化场景中,但是要使用 Protobuf 会相对来说麻烦些，因为他有自己的语法，有自己的编译器

#### 1.简单使用
1. 安装IDEA的插件Protobuf support
    1. 在偏好设置中找到plugins-》搜索Protobuf support，然后安装，重启idea即可
2. pom文件配置
    1. 在properties标签中定义属性
        
        ```
        <!--windows写这个-->
        <os.detected.classifier>windows-x86_64</os.detected.classifier>
        <!--macos写这个-->
        <os.detected.classifier> osx-x86_64</os.detected.classifier>
        ```
    2. 添加依赖
        
        ```
        <dependency>
            <groupId>com.google.protobuf</groupId>
            <artifactId>protobuf-java</artifactId>
            <version>3.12.0</version>
        </dependency>
        ```
    3. 添加插件
        
        ```
        <plugin>
            <groupId>org.xolstice.maven.plugins</groupId>
            <artifactId>protobuf-maven-plugin</artifactId>
            <version>0.6.1</version>
            <configuration>
                <protocArtifact>
                    com.google.protobuf:protoc:3.12.0:exe:${os.detected.classifier}
                </protocArtifact>
                <pluginId>grpc-java</pluginId>
            </configuration>
        </plugin>
        ```
3. 编写proto文件
    1. 在main目录下面创建包proto, 在proto包下面创建对应的资源文件，比如Person.proto文件,内容如下
        
        ```
        // 使用的协议版本 proto3  proto2
        syntax = "proto3";
        // 将要生成的Java类的包，就是生产序列化的文件放到哪个目录下
        option java_package = "com.zh.demo.serdemo.domain";
        // 创建一个文件名 PersonModel，就是序列化生成的文件名称
        option java_outer_classname = "PersonModel";
        
        // 具体需要序列化的类
        message Person {
            // 类的每个属性设置一个唯一的一个编号
            string name = 1  ;
            int32 age= 2 ;
        }
        ```
4. 通过插件生成格式化的类
    1. 点击右侧maven工具-》plugins-》protobuf-》protobuf:compile,双击编译
    2. 会在target下的generated-sources/protobuf/java下的com.zh.demo.serdemo.domain包名下生成一个PersonModel.java类文件
    3. 将PersonModel.java类文件拖入到项目的src/main/java/下的com.zh.demo.serdemo.domain包中
5. 使用编译后的类进行快速序列化，测试代码如下
    
    ```
    public class ProtoBufTest {

        @Test
        public void testSerialize() throws Exception {
            PersonModel.Person person = PersonModel.Person.newBuilder().setName("zh").setAge(21).build();
            //对对象进行序列化
            byte[] bytes = person.toByteArray();
            //序列化长度 8  之前是194
            System.out.println("序列化长度 " + bytes.length);
            //保存到文件
            try(FileOutputStream fos = new FileOutputStream("user2.dat");){
                fos.write(bytes);
                fos.flush();
            }
        }
        @Test
        public void testDeSerialize() throws Exception {
            //反序列化
            byte[] buffer=new byte[1024];
            int len=-1;
            FileInputStream fis = new FileInputStream("user2.dat");
            if((len=fis.read(buffer))>0){
                buffer = Arrays.copyOf(buffer, len);
                PersonModel.Person person = PersonModel.Person.parseFrom(buffer);
                System.out.println("person = " + person);
            }
        }
    }
    ```
6. 可以看到用protobuf序列化的数据大小才8个字节，之前是194个字节

#### 2.特点
1. 处理速度快
    1. 编码 / 解码 方式简单（只需要简单的数学运算 = 位移等等）
2. 数据体积小
    1. 采用了独特的编码方式，如Varint、Zigzag编码方式等等
3. 兼容性高
    1. 采用T - L - V 的数据存储方式

### 序列化技术选型
1. 查看资料：https://github.com/eishay/jvm-serializers/wiki
2. 建议
    1. 对性能要求不高的场景，可以采用基于 XML 的 SOAP 协议  webservice
    2. 对性能和间接性有比较高要求的场景，那么Hessian、Protobuf、Thrift、Avro 都可以。
    3. 基于前后端分离，或者独立的对外的 api 服务，选用 JSON 是比较好的，对于调试、可读性都很不错
3. 参考方面
    1. 序列化的数据大小
    2. 序列化的处理速度
    3. 是否支持跨平台,跨语言
    4. 可扩展性和兼容性
    5. 技术的流行度
    6. 学习的难度


## 远程过程调用RMI

### 简介
1. RPC概述
    1. RPC（Remote Procedure Call）远程过程调用，简单的理解是一个服务请求另一个服务提供的服务
    2. 本地过程调用: 就是在同一个JVM中, 直接调用本地的方法
    3. 常见的RPC框架: 
        1. RMI(JRMP)   纯Java的RPC框架
        2. SOAP(webservice)
        3. grpc
        4. dubbo(常用)
        5. Springcloud（常用）
    4. 本节学习RMI，便于后序其他框架的理解
2. 为什么需要RPC远程调用？
    1. 案例：一个电商系统，分为用户、商品、订购三个功能块
    2. 集中开发：当我们在传统的集中开发的时候，所有的业务功能都在一起运行，打包成一个jar/War包，到时候运行的时候，是在同一个JVM虚拟机中，对于各个功能之间的相互调用，是本地的方法（函数）调用，直接调用对应的方法即可；
    3. 分模块开发：但是当我们的业务功能增长，我们把一个系统拆分为不同的业务模块的时候，比如：用户模块、商品模块、订单模块，这三个模块单独进行部署，这个时候，如果在商品模块需要调用用户模块的信息，那么在商品模块的JVM中并没有用户的相关实现，只能通过远程调用的方式进行调用。
    4. 如下图所示：

    ![图1](https://gitee.com/zhonghua123/blogimgs/raw/master/img/javazh-65.png)

### Java RMI 应用实战

#### 1.业务流程梳理如下：
![图1](https://gitee.com/zhonghua123/blogimgs/raw/master/img/javazh-66.png)
    
1. 有三个模块rmi-api模块、rmi-server模块、rmi-client模块
2. rmi-api模块用于定义接口
3. rmi-server模块用于针对rmi-api的接口实现
4. rmi-client模块直接使用rmi-api的接口来远程使用rmi-server模块的实现 
    
#### 2.代码实战
1. 项目初始化
    1. 创建父模块07-rmi-demo 
        1. 新建一个项目(new Module)-》选择Maven->next->name: 07-rmi-demo Atrifact coordinates展开：groupid: com.zh Atrifactid:rmi-demo -> finished 
        2. 由于该项目仅仅是用来管理子项目的，因此在pom.xml文件中添加
        
            ```
            <packaging>pom</packaging>
            ```
        3. 删除src文件夹，只留pom文件
    2. 创建rmi-api模块
        1. 点击07-rmi-demo，右击->new->Module->Maven->next->name：rmi-api->finish
    3. 同理创建rmi-server、rmi-client2个模块
2. rmi-api模块
    1. 新建一个**接口**类IHelloService
        
        ```
        package com.zh.demo.rmi;
        public interface IHelloService {
            public String sayHello(String name) ;
        }
        ```
3. rmi-server模块
    1. 在pom文件添加rmi-api模块依赖
        
        ```
        <dependencies>
            <dependency>
                <groupId>com.zh.demo</groupId>
                <artifactId>rmi-api</artifactId>
                <version>1.0-SNAPSHOT</version>
            </dependency>
        </dependencies>
        ```
    2. 新建一个类HelloServiceImpl
        
        ```
        package com.zh.demo.rmi;
        public class HelloServiceImpl  implements IHelloService{
            public String sayHello(String name) {
                System.out.println("name = " + name);
                return "hello:"+name;
            }
        }
        ```
4. rmi-client模块
    1. 同理pom添加rmi-api模块依赖
    2. 新建一个类APPClient
        
        ```
        public class APPClient {
            public static void main(String[] args) {
                IHelloService helloService = null;
                String result =  helloService.sayHello("zh");
                System.out.println("result = " + result);
            }
        }
        ```
        
#### 4.问题分析：
1. rmi-client模块中的APPClient类中helloService为什么为null？因为该模块仅仅依赖于rmi-api模块，并没有IHelloService接口的实现，那么如何办呢？
2. 解决办法
    1. rmi-api模块
        1. 对于接口必须继承Remote接口
        2. 对于接口中的方法必须抛出RemoteException的异常
        3. 改造后如下
        
        ```
        public interface IHelloService extends Remote {
            /**
             * 定义一个可以远程调用的方法
             * @param name  参数
             * @return
             * @throws RemoteException 必须标记有远程调用异常
             */
            public String sayHello(String name) throws RemoteException;
        }
        ```
    2. rmi-server模块
        1. 实现类必须继承UnicastRemoteObject对象
        2. 对于构造器使用空参的构造器即可
            
            ```
            public class HelloServiceImpl extends UnicastRemoteObject implements IHelloService{
                public  HelloServiceImpl() throws RemoteException {
                    super();
                }
                public String sayHello(String name) throws RemoteException {
                    System.out.println("name = " + name);
                    return "hello:"+name;
                }
            }
            ```
        3. 新增当前模块的服务启动类APPServer
            
            ```
            //启动服务
            public class APPServer {
                public static void main(String[] args) throws Exception {
                    //1 注册服务端口
                    LocateRegistry.createRegistry(1099);
                    //2 提供具体的服务, 先创建服务
                    IHelloService helloService = new HelloServiceImpl(); // tcp  Serversocket等待连接
                    //3 发布远程服务  这里用rmi协议 类似注册中心的功能, key-->value
                    Naming.bind("rmi://127.0.0.1:1099/hello",helloService);
                    System.out.println("服务启动成功");
                }
            }
            ```
    3. rmi-client模块
        1. 通过lookup方法查找到对应的服务提供者,服务名称
        
        ```
        public class APPClient {
            public static void main(String[] args) throws  Exception{
                //通过lookup方法查找到对应的服务提供者,  服务名称
                IHelloService helloService= (IHelloService) Naming.lookup("rmi://127.0.0.1:1099/hello");
                String result =  helloService.sayHello("zh");
                System.out.println("result = " + result);
            }
        }
        ```
3. 运行项目
    1. 运行rmi-server模块的main函数类启动服务
    2. 运行rmi-client模块的APPClient
    3. 结果：rmi-client模块正常打印：`result = hello:zh`,说明获取到了rmi-server模块的的helloService实现

#### 5.RMI调用流程总结
1. 启动服务端程序, 暴露对应的端口和名称服务
    1. 注册服务端口
    2. 创建一个服务提供者的实例对象
2. 启动客户端程序, 通过对应的名称服务找到对应的代理对象
3. 通过代理对象调用远程方法
4. 对于调用过程中的方法参数、执行结果需要序列化在网络上传输
5. 整个流程时序图如下：
    
    ![图1](https://gitee.com/zhonghua123/blogimgs/raw/master/img/javazh-67.png)
    
    1. Sub、Skeleten 都是代理对象


## 手写RPC基础框架
1. 常见的项目简介
    1. 单体应用项目
        1. 项目的各个层都放在一个项目中，各个层之间的调用直接是通过方法接口调用，无需网络传输，无延迟
        2. 应用场景：对于单体应用项目来说, 开发起来比较方便, 服务的调用都是在本地调用,性能方面比较好,特别适用于中小型的一些项目: 比如小说类的App, 母婴类的App
    2. 分布式应用项目
        1. 项目的各个层分别部署在不同的服务器，各个层之间调用通过网络传输RPC框架来调用
        2. 特点：
            1. 项目规模比较大, 用户数量比较多, 业务功能比较复杂
            2. 分布式项目采用模块化开发, 对于开发人员来说, 只需要了解负责的模块即可
            3. 对于分布式项目部署来说, 采用模块化部署, 万一一个模块出现问题, 并不会直接影响其他模块调用
            4. 对于分布式项目会引入网络, 也会引入分库分表的操作, 所以系统的复杂性会明显提高
        3. 使用场景：对于分布式项目常用的一般是大型的App, 比如说社交类的App, 旅游类的App, 直播类的App, 在线教育类的App等等
2. 项目实际演练
    1. 本节讲解一个项目分三个层product-api层、product-web层、product-service层，然后web层与service层之间额调用通过网络传输来实现，这个网络传输由自己编写实现
    2. 即自己手写一套RPC框架，来实现各个层之间的网络通信数据传送
    3. 具体图如下：
    
        ![图1](https://gitee.com/zhonghua123/blogimgs/raw/master/img/javazh-68.png)   
            
### 初始化项目
1. 创建父模块08-product-rpc-v1
    1. 新建一个项目(new Module)-》选择Maven->next->name: 08-product-rpc-v1 Atrifact coordinates展开：groupid: com.zh.demo Atrifactid:product-rpc-v1 -> finished 
    2. 由于该项目仅仅是用来管理子项目的，因此在pom.xml文件中添加
    
        ```
        <packaging>pom</packaging>
        ```
    3. 删除src文件夹，只留pom文件
2. 创建product-api模块
    1. 点击08-product-rpc-v1，右击->new->Module->Maven->next->name：product-api->Atrifact coordinates展开：groupid: com.zh.demo.v1->finish
3. 创建product-web模块
    1. 点击08-product-rpc-v1，右击->new->Module->Spring Initializr(因为这个项目需要部署，因此需要启动，直接使用springboot)->group:com.zh.demo.v1、artifact:product-web-v1、java version:8->next->Develop Tools 勾选Lombok 、Web勾选Springweb->next->注意：content root 路径要在product-web下(.../08-product-rpc-v1/product-web-v1) ->finish
4. 同理创建product-server模块

#### 1.product-api模块（api层）
1. 创建包名：com.zh.demo.rpc.v1
2. 创建domain的product类
    
    ```
    package com.zh.demo.rpc.v1.domain;
    /**
     * 产品信息
     */
    @Setter
    @Getter
    @ToString
    @AllArgsConstructor
    @NoArgsConstructor
    public class Product implements Serializable {
        private Long id;//id
        private String sn;//产品编号
        private String name;//产品名称
        private BigDecimal price;//产品价格
    }
    ```
3. 创建service的IProductService类
    
    ```
    package com.zh.demo.rpc.v1.service;
    import com.zh.demo.rpc.v1.domain.Product;
    /**
     * 定义产品接口的操作规范
     */
    public interface IProductService {
        /**
         * 保存产品
         * @param product
         */
        void save(Product product);
    
        /**
         * 根据产品id删除产品
         * @param productId
         */
        void deleteById(Long productId);
    
        /**
         * 修改产品信息
         * @param product
         */
        void update(Product product);
    
        /**
         * 根据产品id获取到产品信息
         * @param productId
         * @return
         */
        Product get(Long productId);
    }
    ```

#### 2.product-web模块（control层）
1. 将包名也修改为`com.zh.demo.rpc.v1`
2. 在pom文件中导入product-api模块
    
    ```
    <dependency>
        <groupId>com.zh.demo.v1</groupId>
        <artifactId>product-api</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
    ```
3. 创建ProductController类
    
    ```
    package com.zh.demo.rpc.v1.web;
    import com.zh.demo.rpc.v1.domain.Product;
    import com.zh.demo.rpc.v1.service.IProductService;
    @RestController
    @RequestMapping("product")
    public class ProductController {
    
        @Autowired
        private IProductService productService;
    
        @RequestMapping("save")
        public String save(Product product) throws Exception{
            productService.save(product);
            return "success";
        }
    
        @RequestMapping("get")
        public Product get(Long id) throws Exception{
            Product product = productService.get(id);
            return product;
        }
    }
    ```

#### 3.product-server模块（service层）
1. 将包名也修改为`com.zh.demo.rpc.v1`
2. 在pom文件中导入product-api模块
3. 新增实现类
    
    ```
    package com.zh.demo.rpc.v1.service.impl;
    import com.zh.demo.rpc.v1.domain.Product;
    import com.zh.demo.rpc.v1.service.IProductService;
    import org.springframework.stereotype.Component;
    import java.math.BigDecimal;
    @Service("IProductService")
    public class ProductServiceImpl implements IProductService {
        @Override
        public void save(Product product) {
            System.out.println("产品保存成功: "+product);
        }
    
        @Override
        public void deleteById(Long productId) {
            System.out.println("产品删除成功: "+ productId);
        }
    
        @Override
        public void update(Product product) {
            System.out.println("产品修改成功: "+ product);
        }
    
        @Override
        public Product get(Long productId) {
            System.out.println("产品获取成功");
            return new Product(1L,"001","笔记本电脑",BigDecimal.TEN);
        }
    }
    ```

#### 4.问题剖析
1. 从上面来看service、control都依赖api层，但是control层如何拿到service层的实现呢？
2. 比如：ProductController中的注入
    
    ```
    @Autowired
    private IProductService productService;
    ```
    
    1. 这里是拿不到IProductService接口的实现对象的
3. 因此需要做一个网络类到service层去获取对应的接口实现类


### 手动实现各个层的网络通信
#### 1.product-api模块封装通用的请求、响应结果类
1. 请求类RpcRequest
    
    ```
    package com.zh.demo.rpc.v1.common;
    @Setter
    @NoArgsConstructor
    @AllArgsConstructor
    @ToString
    @Getter
    //RPC通信的数据请求规则
    public class RpcRequest implements Serializable {
        // 请求消息的消息Id
        private String requestId;
        // 请求的具体的类名(接口名称)
        private String className;
        // 请求的具体的方法名称
        private String methodName;
        // 请求的方法参数类型列表
        private Class<?>[] parameterTypes;
        // 请求的方法参数列表
        private Object[] parameters;
    }
    ```
2. 响应类RpcResponse
    
    ```
    package com.zh.demo.rpc.v1.common;
    @NoArgsConstructor
    @AllArgsConstructor
    @ToString
    @Setter
    @Getter
    //RPC通信消息的响应数据规则
    public class RpcResponse implements Serializable {
        //响应的消息id
        private String responseId;
        //请求的消息id
        private String requestId;
        // 响应的消息是否成功
        private boolean success;
        // 响应的数据结果
        private Object result;
        // 如果有异常信息,在该对象中记录异常信息
        private Throwable throwable;
    }

    ```

#### 2.product-server模块
1. 提供一个网络监听服务，用来响应当前模块的所有接口的实现类RpcServer
    
    ```
    package com.zh.demo.rpc.v1;
    @Slf4j
    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public class RpcServer {
        private int port ;
        private ApplicationContext applicationContext;
        //服务启动类--> 启动一个ServerSocket
        //PostConstruct这个注解可以让这个方法在调用完构造函数后自动执行
        @PostConstruct
        public void startup(){
            try {
                //1 创建一个socket通信
                ServerSocket serverSocket = new ServerSocket(port);
                System.out.println("服务端启动成功, 等待客户端连接.....");
                //2 接收客户端请求
                while(true){
                    Socket socket = serverSocket.accept();//等待客户端连接 如果没有客户端连接, 会阻塞在这里
                    try(
                            ObjectInputStream ois =new ObjectInputStream(socket.getInputStream());
                            ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream())
                    ){
                        //读取内容
                        RpcRequest rpcRequest = (RpcRequest) ois.readObject();
                        System.out.println("服务端收到客户端的请求: obj = " + rpcRequest);
                        //调用业务方法执行代码
                        //1 通过类名找到对应的Bean对象,在容器中查找
                        String className = rpcRequest.getClassName();//IProductService
                        Object bean = applicationContext.getBean(className);
                        Class<?> clazz = bean.getClass();//字节码对象
                        //2 通过反射调用类的对应方法
                        String methodName = rpcRequest.getMethodName();
                        Class<?>[] parameterTypes = rpcRequest.getParameterTypes();
                        Object[] parameters = rpcRequest.getParameters();
                        Method method = null;//方法对象
                        Object result = null;//反射的返回结果
                        if(parameterTypes==null || parameterTypes.length==0){
                            method=clazz.getMethod(methodName);
                            result =method.invoke(bean);
                        }else{
                            method = clazz.getMethod(methodName, parameterTypes);
                            result=method.invoke(bean,parameters);
                        }
                        //发送数据到客户端
                        RpcResponse rpcResponse = new RpcResponse();
                        rpcResponse.setSuccess(true);
                        rpcResponse.setResult(result);
                        oos.writeObject(rpcResponse);
                        oos.flush();//刷新缓冲区域
                    }catch (Exception e){
                        e.printStackTrace();
                        log.error(e.getMessage());
                    }
                }
    
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    ```
2. 在ProductServerApplication启动当前模块时，启动网络服务RpcServer
    
    ```
    @SpringBootApplication
    public class ProductServerApplication {
    
        public static void main(String[] args) {
            SpringApplication.run(ProductServerApplication.class, args);
        }
        @Bean
        public RpcServer rpcServer(ApplicationContext applicationContext){
            RpcServer rpcServer = new RpcServer(9000,applicationContext);
            return rpcServer;
        }
    }
    ```

#### 3.product-web模块（control层）
1. 转门封装一个通用类，用于到service层获取接口对应的实现类的对象---RpcClient
    
    ```
    package com.zh.demo.rpc.v1;
    @Slf4j
    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public class RpcClient {
        private String host;
        private int port;
    
        public Object send(RpcRequest rpcRequest){
            //1 连接服务端
            try(
                    Socket socket = new Socket(host, port);
                    ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
                    ObjectInputStream ois = new ObjectInputStream(socket.getInputStream())
            )
            {
                //1 通过输出流返送数据到服务端--> 对象输出流
                // 调用一个方法  找到对应的字节码对象 通过一个名称   找到对应的方法   调用方法的参数类型,  实际参数列表
                oos.writeObject(rpcRequest);
                oos.flush();
                //2 接收服务端数据
                RpcResponse rpcResponse = (RpcResponse) ois.readObject();
                System.out.println("服务端响应给客户端的请求结果: rpcResponse = " + rpcResponse);
                return rpcResponse.getResult();
            }catch (Exception e){
                e.printStackTrace();
                log.error(e.getMessage());
            }
            return null;
        }
    }
    ```
3. 提供一个代理,转门用来代理某个接口去service获取对应实现类--RpcProxy
    
    ```
    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public class RpcProxy {
        private RpcClient rpcClient;
        //通用的代理对象,可以代理任何接口
        public  <T> T getProxy(Class<T> interfaceClass){
            return (T) Proxy.newProxyInstance(interfaceClass.getClassLoader(),//类加载器
                    new Class<?>[]{interfaceClass},
                    new InvocationHandler() {
                        //proxy 代理对象  method 代理的方法  args 实际参数列表
                        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                            // 1 创建客户端连接
                            // 2 构造请求参数
                            RpcRequest rpcRequest = new RpcRequest();
                            rpcRequest.setClassName(interfaceClass.getSimpleName());
                            rpcRequest.setMethodName(method.getName());
                            rpcRequest.setParameters(args);
                            rpcRequest.setParameterTypes(method.getParameterTypes());
                            // 3 发送请求
                            // 4 返回请求结果
                            Object result = rpcClient.send(rpcRequest);
                            return result;
                        }
                    }
            );
        }
    }
    ```
4. product-web模块启动时，应到到service层获取到所有当前模块所需要的接口实现类对应的实例对象
    
    ```
    @SpringBootApplication
    public class ProductWebApplication {
    
        public static void main(String[] args) {
            SpringApplication.run(ProductWebApplication.class, args);
        }
        @Bean
        public RpcClient rpcClient(){
            RpcClient client = new RpcClient("127.0.0.1", 9000);
            return client;
        }
        @Bean
        public RpcProxy rpcProxy(RpcClient rpcClient){
            return new RpcProxy(rpcClient);
        }
    
        @Bean
        public IProductService productService(RpcProxy rpcProxy){
            // 因为本地没有对应的实现类的字节码对象, 无法实例化对象
            // 通过代理对象 调用远程的服务方法,获取当前接口的实现对象
            IProductService productService=rpcProxy.getProxy(IProductService.class) ;
            return productService;
        }
    }
    ```
    
    1. 这样，ProductController注入的productService实例，就能获取到值了

#### 4.测试
1. 启动product-server模块-ProductServerApplication
2. 启动product-web模块-ProductWebApplication
3. 浏览器访问：`http://localhost:8080/product/get?id=100`,响应结果如下
    
    ```
    {
        "id": 1,
        "sn": "001",
        "name": "笔记本电脑",
        "price": 10
    }
    ```
    
#### 6.原理总结
1. 首先使用socket创建2个模块（请求层、响应层）的网络连接
2. 请求层网络请求传输的数据是一个对象，这个对象封装了要获取的类名、方法名称、参数等信息
3. 响应层根据请求的数据采用java的反射来调用相应的方法，返回对应的对象

#### 5.问题分析
1. 我们封装的网络通信模块放在了product-web层，那么是不是应该将网络通信模块独立出来？任何模块使用直接引入即可？

### 抽取网络通信模块

