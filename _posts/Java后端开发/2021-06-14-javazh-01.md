---
layout: post
title: Java常用企业框架-MyBatis(四)
category: Java后端开发
tags: Java后端开发
description: Java后端开发
--- 

## 缓存
1. 缓存：是指为了减少数据库直接访问次数、提高访问效率，而临时存储在**内存中**的数据
    1. 数据库是存储在硬盘上的文件，每次查询都进行了IO操作，效率较低
2. 适合存放到缓存中的数据
    1. 经常查询、不经常改变、数据的正确性对最终结果影响不大
3. 举例一些不适合放到缓存中的数据：商品库存、股票 黄金的价格、汇率
4. MyBatis的缓存分为一级缓存、二级缓存，用于缓存**select的结果**
    1. 参考资料：[https://mybatis.org/mybatis-3/zh/sqlmap-xml.html#cache](https://mybatis.org/mybatis-3/zh/sqlmap-xml.html#cache)
    
### 一级缓存
1. 一级缓存是存放到了SqlSession对象中
    1. 同一个SqlSession的select共享缓存
    2. 所以当关闭SqlSession时，缓存也就失效了
    3. 执行insert、update、delete、commit等方法时，会自动清理一级缓存
    4. 由于在很多时候，每次查询用的都是不同的SqlSession，所以一级缓存的命中率并不高
2. 一级缓存代码举例：
    
    ```
    public void firstLevel() {
        try (SqlSession session = MyBatises.openSession()) {
            Job job1 = session.selectOne("job.get", 1);
            System.out.println(job1);
            Job job2 = session.selectOne("job.get", 1);
            System.out.println(job2);
            //job1与job2打印一样
        }
        //不同session,关闭SqlSession时，缓存也就失效了
        try (SqlSession session = MyBatises.openSession()) {
            Job job3 = session.selectOne("job.get", 1);
            System.out.println(job3);
            //job1与job3打印不一样,不同的session
        }
        //执行insert、update、delete、commit等方法时，会自动清理一级缓存
        try (SqlSession session = MyBatises.openSession()) {
            Job job4 = session.selectOne("job.get", 1);
            System.out.println(job4);
            //会清除一级缓存
            session.update("job.update", null);
            Job job5 = session.selectOne("job.get", 1);
            System.out.println(job5);
            //job4与job5打印不一样
        }
    }
    ```

### 二级缓存
1. 为了提高缓存的命中率，可以考虑开启MyBatis的二级缓存，它是namespace(mapper)级别的缓存
    1. 同一个namespace下的select共享缓存
    2. 默认情况，namespace下update、insert、delete执行成功时，会自动清理二级缓存
    3. 当调用SqlSession的close方法时，会将查询结果放进二级缓存

#### 开启二级缓存
1. 在mybatis-config.xml中配置
    
    ```
    <setting name="cache Enabled" value="true"/>
    ```
2. 在映射文件的mapper中添加cache标签，默认会缓存映射文件中的所有select的结果
    
    ```
    //job.xml
    <mapper namespace="job">
        <cache readOnly="false"/>
    
        <sql id="sqlListAll">
            SELECT * FROM job
        </sql>
    
        <select id="list" resultType="zh.bean.Job">
            <include refid="sqlListAll"/>
        </select>
    
        <select id="get" parameterType="int" resultType="zh.bean.Job">
            <include refid="sqlListAll"/> WHERE id = #{id}
        </select>
    
        <update id="update" parameterType="zh.bean.Job">
            UPDATE job SET name = #{name}, duty = #{duty} WHERE id = #{id}
        </update>
    </mapper>
    ```
3. cache标签的常用属性有
    1. size：缓存多少个存储结果(单个对象或一个列表) 的引用，默认值是1024
    2. eviction：当缓存数量超过size时的清除策略。可选值有LRU(默认值)、FIFO、SOFT、WEAK
        1. LRU – 最近最少使用：移除最长时间不被使用的对象。
        2. FIFO – 先进先出：按对象进入缓存的顺序来移除它们。
        3. SOFT – 软引用：基于垃圾回收器状态和软引用规则移除对象。
        4. WEAK – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。
    3. flush Interval：每隔多少毫秒清除一次缓存， 默认不会定时清除缓存
    4. readOnly： true代表缓存的是对原对象的引用，false代表缓存的是原对象序列化后的拷贝对象
        1. 所以false时要求bean实现Serializable接口。默认值是false
        2. readOnly为true，代表：只读，二级缓存中是：原对象，不安全，会修改原来对象的值
        3. readOnly为false，代表：可读写，二级缓存中是：原对象序列化后的结果，安全，不会修改原来对象的值
            
            ```
            package zh.bean;
            import java.io.Serializable;
            //bean实现Serializable接口
            public class Job implements Serializable {
                private Integer id;
                private String name;
                private String duty;
            
                public Integer getId() {
                    return id;
                }
            
                public void setId(Integer id) {
                    this.id = id;
                }
            
                public String getName() {
                    return name;
                }
            
                public void setName(String name) {
                    this.name = name;
                }
            
                public String getDuty() {
                    return duty;
                }
            
                public void setDuty(String duty) {
                    this.duty = duty;
                }
            }
            ```
    
    5. 代码举例：
        ```
        <cache
          eviction="FIFO"
          flushInterval="60000"
          size="512"
          readOnly="true"/>
        ```
4. 代码举例
    
    ```
    public void secondLevel() {
        try (SqlSession session = MyBatises.openSession()) {
            Job job1 = session.selectOne("job.get", 1);
            job1.setName("ZH666");
            System.out.println(job1 + "_" + job1.getName());
        }

        try (SqlSession session = MyBatises.openSession()) {
            Job job2 = session.selectOne("job.get", 1);
            System.out.println(job2 + "_" + job2.getName());
        }

        //job1与job2为同一个对象
    }
    ```

### userCache、flushCache
1. 可以通过设置userCache属性来决定某个select属性来决定某个
    
    ```
    <select id="get" useCache="false" parameterType="int" resultType="zh.bean.Job">
        <include refid="sqlListAll"/> WHERE id = #{id}
    </select>
    ```
2. 可以通过设置flushCache属性来决定某个操作之后，是否需要清除缓存
    
    ```
    <update id="update" flushCache="false" parameterType="zh.bean.Job">
        UPDATE job SET name = #{name}, duty = #{duty} WHERE id = #{id}
    </update>
    ```


