---
layout: post
title: 项目实战九-前后端分离驾考项目（八）
category: Java后端开发
tags: Java后端开发
description: Java后端开发
--- 

## 登录功能
> 登录有：用户名、密码、验证码

### 基本登录功能的实现
1. 新增登录的vo
    1. 登录请求LoginReqVo：在req下直接添加
        
        ```
        @Data
        public class LoginReqVo {
            //用户名
            @NotBlank
            private String username;
        
            //密码
            @NotBlank
            private String password;
        
            //验证码
            @NotBlank
            private String captcha;
        }
        ```
    2. 登录响应LoginVo:在vo下直接添加
        
        ```
        @Data
        public class LoginVo {
            private Integer id;
            private String nickname;
            private String username;
            private String token;
        }
        ```
2. controller层
    1. 新增登录、获取验证码方法
        
        ```
        @PostMapping("/login")
        public DataJsonVo<LoginVo> login(LoginReqVo reqVo, HttpServletRequest request) {
            //验证验证码是否正确
            if (CaptchaUtil.ver(reqVo.getCaptcha(),request)){
                return JsonVos.ok(service.login(reqVo));
            }
            //验证码错误
            return JsonVos.raise(CodeMsg.WRONG_CAPTCHA);
    
        }
    
        //生成验证码
        @GetMapping("/captcha")
        public void captcha(HttpServletRequest request,
                            HttpServletResponse response) throws Exception {
    
            //返回给前端的事验证码图片,CaptchaUtil是使用功能第三方jar包easy-captcha
            CaptchaUtil.out(request, response);
        }
        ```
    2. **注意：**
        1. 给前端体用验证码接口，使用第三方jar包easy-captcha，pom.xml中导入
            
            ```
            <!-- 验证码 -->
            <dependency>
                <groupId>com.github.whvcse</groupId>
                <artifactId>easy-captcha</artifactId>
                <version>1.6.2</version>
            </dependency>
            ```
        2. 前端必须要传递cookie到后台，才能正确识别验证码，后台要允许跨域以及允许传递cookie
            1. 后台：目前在WebCfg类中已经全局配置
                
                ```
                allowCredentials(true)
                allowedOrigins(origins): 要指定特定的主机地址，不能使用*
                ```
            2. 前端
            
                ```
                Ajaxs.loadPost({
                    uri: 'sysUsers/login',
                    data: data.field,
                    success: (response) => {
                        //登录成功跳转到首页
                        location.href = '../index.html'
                    },
                    //必须要加这个，需要跨域带上cookie
                    xhrFields: { 
                        withCredentials: true
                    }
                })
                ```
3. service层

    ```
    //新增接口
    LoginVo login(LoginReqVo reqVo);
    
    //impl新增方法实现
    @Override
    public LoginVo login(LoginReqVo reqVo) {
        //根据用户名查询用户
        MpLambdaQueryWrapper<SysUser> wrapper = new MpLambdaQueryWrapper<>();
        wrapper.eq(SysUser::getUsername,reqVo.getUsername());
        SysUser po = baseMapper.selectOne(wrapper);
        if (po == null) { //用户名不存在
            return JsonVos.raise(CodeMsg.WRONG_USERNAME);
        }
        //密码不正确
        if (!po.getPassword().equals(reqVo.getPassword())){
            return JsonVos.raise(CodeMsg.WRONG_PASSWORD);
        }
        //账号锁定
        if(po.getStatus() == 1){
            return JsonVos.raise(CodeMsg.USER_LOCKED);
        }
        //更新登录时间
        po.setLoginTime(new Date());
        baseMapper.updateById(po);
        
        return MapStructs.INSTANCE.po2loginVo(po);
    }
    ```
    
    1. 注意：MapStructs需要添加LoginVo-》SysUser转化
        
        ```
        LoginVo po2loginVo(SysUser po);
        ```

### 会话管理
1. 在线免费流程图使用[processon](https://processon.com/)

#### 1.客户端身份认证-基于Cookie、Session
1. 执行流程
    1. 客户端：发送用户名密码
    2. 服务器：验证成功后，创建并保留一个跟客户端相关联的Session，返回Session_ID给客户端
    3. 客户端：将Session_ID保存到Cookie中
    4. 客户端：后续的请求都带上包含了Session_ID的Cookie
    5. 服务器：通过验证Cookie中的Session_ID确认用户身份
2. 优点
    1. 服务器、客户端基本自动完成一系列的流程，不用编写太多额外的代码
3. 缺点
    1. 默认不支持分布式架构，在分布式架构下，需要解决分布式Session共享的问题，比如存放到Redis中
    2. 默认不支持**非浏览器**环境（没有Cookie机制的环境）
    
#### 2.简单的分布式架构

![图1](https://gitee.com/zhonghua123/blogimgs/raw/master/img/javazh-49.png) 

1. 一套后台代码服务部署到n台主机上，客户端只需要访问一台服务器的地址（Nginx服务器），这台服务器仅仅用来做**负载均衡**这个算法，自动计算出到底去访问哪台服务器
2. Nginx服务器：负载均衡服务器、反向代理服务器（相当于n台服务器的代理人）
3. 分布式缓存：
    1. n台服务器肯定要访问数据库，数据库本质是一个文件，如果n台服务器都要访问，就需要进行大量的IO操作，效率低下，因此可以将数据放入到缓存中。缓存是放在服务器的内存中，提高效率
    2. 这样这个缓存就要n台服务器访问，因此专门搞一台服务器搭建缓存，再搞一台服务器存放数据库
    3. 访问数据时，先到缓存中获取，缓存中没有在到数据库中去查询，数据库查询到之后存放到缓存，以备下次访问
    4. 注意：n台服务器是不能设置缓存的，因为缓存是需要n台服务器共享，共同访问
    5. Redis就是一种分布式缓存
4. Cookie、Session是不支持分布式的，因为Session在某台服务器的主机中存储，当客户端下次访问时不一定还是到这台主机中查找，如果要做必须将Session存储到分布式缓存中

#### 3.客户端身份认证-基于token
 1. 执行流程
    1. 客户端：发送用户名密码
    2. 服务器：验证成功后，生成一个跟客户端相关联的token，返回token给客户端
    3. 客户端：存储token到本地
    4. 客户端：后续的请求都带上token
    5. 服务器：通过验证token确认用户身份
2. 优点
    1. 支持分布式架构、支持非浏览器环境（没有Cookie机制的环境）
3. 缺点
    1. 需要客户端手动存储、发送token
    2. 有些token会比session_id大，需要消耗更多流量
    3. 有些token方案，默认无法在服务器主动销毁token
4. 如果在分布式缓存redis环境下，需要将token存储到redis中去

#### 4.EhCache
1. [EhCache](https://www.ehcache.org)是一款简单易用的缓存框架
2. 支持3层缓存：Heap（JVM的堆内存,内存会自动管理）、Off-Heap（堆外内存，内存需要手动管理）、Disk（磁盘）
3. Off-Heap、Disk要求对象支持序列化和反序列化
4. 该缓存可以设置缓存时效
5. pom
    
    ```
    <dependency>
        <groupId>org.ehcache</groupId>
        <artifactId>ehcache</artifactId>
    </dependency>
    ```   
    
### 基于token登录控制

#### 1.服务端生成token并存储
1. 只有登录过才能访问相关的页面
2. 返回给客户端添加token字段LoginVo
    
    ```
    //返回给用户token
    private String token;
    ``` 
3. pom.xml添加 EhCache依赖
4. resources下添加ehCache.xml配置文件
    
    ```
    <?xml version="1.0" encoding="UTF-8"?>
    <config xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
            xmlns='http://www.ehcache.org/v3'
            xsi:schemaLocation="http://www.ehcache.org/v3
            http://www.ehcache.org/schema/ehcache-core.xsd">
    <!--    <persistence directory="F:/ehcache"/>-->
    
        <!-- 设置缓存的数据类型，以及缓存的位置-->
        <cache-template name="common">
    
            <key-type>java.lang.Object</key-type>
            <value-type>java.lang.Object</value-type>
            <!-- 设置资源存储到哪里-->
            <resources>
                <!-- 默认unit是unit="entries",对象-->
                <heap>10000</heap>
    <!--            <offheap unit="MB">50</offheap>-->
    <!--            <disk unit="GB" persistent="true">1</disk>-->
            </resources>
        </cache-template>
    
        <!--
           11月1号~11月7号，11月8号过期
           11月6号~11月12号，11月13号过期
           11月12号~11月18号，11月19号过期
        -->
    
        <!-- 创建一个缓存别名为token，存放token的缓存：只要7天内不访问，就失效 -->
        <cache alias="token" uses-template="common">
            <!--
            设置时长
            ttl：time to leave 生命周期，不管中间有没有访问，从1号开始，到8号一定过期
            tti:time to idle 只要1-8号内有访问，声明周期就是从最后一次访问开始直到7天结束，
            只要中间有访问，生命周期就延长
            -->
            <expiry>
                <tti unit="days">7</tti>
                <!-- <tti unit="seconds">5</tti>-->
            </expiry>
        </cache>
    
        <!-- 默认缓存：永不过期 -->
        <cache alias="default" uses-template="common">
            <!-- 设置时长-->
            <expiry>
                <none/>
            </expiry>
        </cache>
    </config>
    ```
5. 封装一个Caches类，读取xml文件
    
    ```
    //com.zh.jk.common.cache
    public class Caches {
        //注意：缓存管理器、缓存对象必须是唯一的！！！
        private static final CacheManager MGR;
        private static final Cache<Object, Object> DEFAULT_CACHE;
        private static final Cache<Object, Object> TOKEN_CACHE;
        static {
            // 初始化缓存管理器，读取xml配置
            URL url = Caches.class.getClassLoader().getResource("ehcache.xml");
            assert url != null;
            Configuration cfg = new XmlConfiguration(url);
            MGR = CacheManagerBuilder.newCacheManager(cfg);
            MGR.init();
    
            // 缓存对象
            DEFAULT_CACHE = MGR.getCache("default", Object.class, Object.class);
            TOKEN_CACHE = MGR.getCache("token", Object.class, Object.class);
        }
    
        public static void put(Object key, Object value) {
            if (key == null || value == null) return;
            DEFAULT_CACHE.put(key, value);
        }
    
        public static void remove(Object key) {
            if (key == null) return;
            DEFAULT_CACHE.remove(key);
        }
    
        public static <T> T get(Object key) {
            if (key == null) return null;
            return (T) DEFAULT_CACHE.get(key);
        }
    
        public static void clear() {
            DEFAULT_CACHE.clear();
        }
    
        public static void putToken(Object key, Object value) {
            if (key == null || value == null) return;
            TOKEN_CACHE.put(key, value);
        }
    
        public static void removeToken(Object key) {
            if (key == null) return;
            TOKEN_CACHE.remove(key);
        }
    
        public static <T> T getToken(Object key) {
            if (key == null) return null;
            return (T) TOKEN_CACHE.get(key);
        }
    
        public static void clearToken() {
            TOKEN_CACHE.clear();
        }
    }
    ```
6. service层SysUserServiceImpl的login方法改造
    
    ```
    @Override
    public LoginVo login(LoginReqVo reqVo) {
        //根据用户名查询用户
        MpLambdaQueryWrapper<SysUser> wrapper = new MpLambdaQueryWrapper<>();
        wrapper.eq(SysUser::getUsername,reqVo.getUsername());
        SysUser po = baseMapper.selectOne(wrapper);
        if (po == null) { //用户名不存在
            return JsonVos.raise(CodeMsg.WRONG_USERNAME);
        }
        //密码不正确
        if (!po.getPassword().equals(reqVo.getPassword())){
            return JsonVos.raise(CodeMsg.WRONG_PASSWORD);
        }
        //账号锁定
        if(po.getStatus() == Constants.SysUserStatus.LOCKED){
            return JsonVos.raise(CodeMsg.USER_LOCKED);
        }
        //更新登录时间
        po.setLoginTime(new Date());
        baseMapper.updateById(po);

        //生成token，发送token给用户
        String token = UUID.randomUUID().toString();
        //存储token到缓存中,使用EhCache封装的类
        Caches.putToken(token,po);

        //返回给客户端的具体数据
        LoginVo vo = MapStructs.INSTANCE.po2loginVo(po);
        vo.setToken(token);

        return vo;
    }
    ```

#### 2.项目中使用shiro
1. pom.xml添加依赖
    
    ```
    <!--权限控制-->
    <dependency>
        <groupId>org.apache.shiro</groupId>
        <artifactId>shiro-spring-boot-starter</artifactId>
        <version>1.7.0</version>
    </dependency>
    ```
2. 运行项目，此时会报错
    
    ```
    Description:
    No bean of type 'org.apache.shiro.realm.Realm' found.
    Action:
    Please create bean of type 'Realm' or add a shiro.ini in the root classpath (src/main/resources/shiro.ini) or in the META-INF folder (src/main/resources/META-INF/shiro.ini).
    Disconnected from the target VM, address: '127.0.0.1:65420', transport: 'socket'
    Process finished with exit code 0
    ```
    
    1. 就是容器中必须要有个Realm类型的bean对象，或者在classpath、META-INF下添加shiro.ini文件
3. 在common下新建一个shiro包
    1. 新建TokenRealm类，继承自AuthorizingRealm
        
        ```
        //com.zh.jk.common.shiro
        public class TokenRealm extends AuthorizingRealm {
            //自己定义一个密码的比对算法类，传进来
            public TokenRealm (TokenMatcher matcher) {
                super(matcher);
            }
            //自己定义如何获取数据授权
            @Override
            protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
                return null;
            }
            //自己定义如何获取数据认证
            @Override
            protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
                return null;
            }
        }
        ```
    2. 新建一个ShiroCfg类，专门配置那些bean放入容器，将TokenRealm类的bean放入容器
        
        ```
        //com.zh.jk.common.shiro
        @Configuration
        public class ShiroCfg {
            @Bean
            public Realm realm() {
                return new TokenRealm(new TokenMatcher());
            }
        
            /**
             * ShiroFilterFactoryBean用来告诉Shiro如何进行拦截
             * 1.拦截哪些URL
             * 2.每个URL需要进行哪些filter
             */
            //这里的参数realm会自动注入，注入的是上面的Realm
            @Bean
            public ShiroFilterFactoryBean shiroFilterFactoryBean(Realm realm) {
                ShiroFilterFactoryBean filterBean = new ShiroFilterFactoryBean();
        
                //设置安全管理器
                filterBean.setSecurityManager(new DefaultWebSecurityManager(realm));
        
                // 添加一些自定义Filter,每个自定义的filter还需要设置一个别名，比如下面TokenFilter设置了一个别名为token
                Map<String, Filter> filters = new HashMap<>();
                filters.put("token", new TokenFilter());
                filterBean.setFilters(filters);
        
                // 设置URL如何拦截，必须要用LinkedHashMap，因为是有序存储，HashMap是无序存储
                Map<String, String> urlMap = new LinkedHashMap<>();
                /*设置哪些请求路径需要拦截*/
                // 验证码接口，anon代表的是shiro内置的filter： org.apache.shiro.web.filter.authc.AnonymousFilter
                //不需要认证就可以访问
                urlMap.put("/sysUsers/captcha", "anon");
                // 用户登录
                urlMap.put("/sysUsers/login", "anon");
        
                // 其他所有的请求路径，使用token这个别名自定义的filter
                urlMap.put("/**", "token");
                filterBean.setFilterChainDefinitionMap(urlMap);
        
                return filterBean;
            }
        }
        ```
    3. 自定义TokenMatcher，如何匹配校验算法
        
        ```
        public class TokenMatcher implements CredentialsMatcher {
            /*自定义实现，客户端传递过来的值与数据库的值进行匹配的算法*/
            @Override
            public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) {
                return false;
            }
        }
        ```
    4. 自定义TokenFilter，如何过滤某些url
        
        ```
        public class TokenFilter extends AccessControlFilter {
            @Override
            protected boolean isAccessAllowed(ServletRequest servletRequest, ServletResponse servletResponse, Object o) throws Exception {
                return false;
            }
        
            @Override
            protected boolean onAccessDenied(ServletRequest servletRequest, ServletResponse servletResponse) throws Exception {
                return false;
            }
        }
        ```
    4. 上面的层级关系如下图
    
       ![图1](https://gitee.com/zhonghua123/blogimgs/raw/master/img/javazh-51.png)  
       
       1. ShiroFilterFactoryBean： 用来告诉Shiro如何进行拦截url
       2. 上面对象需要设置一个setSecurityManager-DefaultWebSecurityManager
       3. 要告诉上面那个manager要使用那个Realm-AuthorizingRealm
       4. 要告诉AuthorizingRealm使用什么算法匹配CredentialsMatcher
        

### 退出登录
1. 为什么token通常存放请求头？因为token不是业务参数，跟业务无关
2. SysUserController控制器添加logout方法
    
    ```
    @PostMapping("logout")
    //RequestHeader，请求头必须传递一个token，否则就会报错
    public JsonVo logout(@RequestHeader("Token") String token){
        //清除token
        Caches.removeToken(token);
        return JsonVos.ok();
    }
    ```

## Shiro

### Shiro简介
1. [Shiro](https://shiro.apache.org)是apache推出的安全管理框架
    1. 比SpringSecurity更加简单易用
    2. 官方手册：[http://shiro.apache.org/reference.html](http://shiro.apache.org/reference.html)
2. Shiro的**2大核心功能**
    1. 认证
        1. 比如登录认证，只有合法用户才能登录进入系统
    2. 授权
        1. 比如设置每个合法用户的权限范围
        2. 可以对哪些资源进行哪些操作（C？R？U？D？）

### 核心类型
1. SecurityManager: 安全管理器，Shiro最核心的类型之一
2. Subject: 需要进行认证和授权的主体，比如用户
    1. 相当于前端
3. Authenticator: 认证器
    1. 用来认证用户的，到Realm查询用户的信息，进行认证
4. Authorizer: 授权器
    1. 用来用户授权的，到Realm查询用户的权限，判断用户是否有权限
5. Realm: 相当于数据源，可以用于获取主体的权限信息
    1. 相当于数据库，专门存储用户的认证信息、权限信息

![图1](https://gitee.com/zhonghua123/blogimgs/raw/master/img/javazh-50.png) 

### 内置的filter

1. anon: [org.apache.shiro.web.filter.authc.AnonymousFilter](https://shiro.apache.org/static/1.8.0/apidocs/org/apache/shiro/web/filter/authc/AnonymousFilter.html)
2. authc: [org.apache.shiro.web.filter.authc.Form AuthenticationFilter](https://shiro.apache.org/static/1.8.0/apidocs/org/apache/shiro/web/filter/authc/FormAuthenticationFilter.html)
3. authcBasic:[org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter](https://shiro.apache.org/static/1.8.0/apidocs/org/apache/shiro/web/filter/authc/BasicHttpAuthenticationFilter.html)
4. authcBearer:[org.apache.shiro.web.filter.authc.BearerHttpAuthenticationFilter](https://shiro.apache.org/static/1.8.0/apidocs/org/apache/shiro/web/filter/authc/BearerHttpAuthenticationFilter.html)
5. invalidRequest: [org.apache.shiro.web.filter.InvalidRequestFilter](https://shiro.apache.org/static/1.8.0/apidocs/org/apache/shiro/web/filter/InvalidRequestFilter.html)
6. logout:[org.apache.shiro.web.filter.authc.LogoutFilter](https://shiro.apache.org/static/1.8.0/apidocs/org/apache/shiro/web/filter/authc/LogoutFilter.html)
7. noSessionCreation:[org.apache.shiro.web.filter.session.NoSessionCreationFilter](https://shiro.apache.org/static/1.8.0/apidocs/org/apache/shiro/web/filter/session/NoSessionCreationFilter.html)
8. perms: [org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter](https://shiro.apache.org/static/1.8.0/apidocs/org/apache/shiro/web/filter/authz/PermissionsAuthorizationFilter.html)
9. port: [org.apache.shiro.web.filter.authz.PortFilter](https://shiro.apache.org/static/1.8.0/apidocs/org/apache/shiro/web/filter/authz/PortFilter.html)
10. rest: [org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter](https://shiro.apache.org/static/1.8.0/apidocs/org/apache/shiro/web/filter/authz/HttpMethodPermissionFilter.html)
11. roles: [org.apache.shiro.web.filter.authz.RolesAuthorizationFilter](https://shiro.apache.org/static/1.8.0/apidocs/org/apache/shiro/web/filter/authz/RolesAuthorizationFilter.html)
12. ssl: [org.apache.shiro.web.filter.authz.SslFilter](https://shiro.apache.org/static/1.8.0/apidocs/org/apache/shiro/web/filter/authz/SslFilter.html)
13. user:[org.apache.shiro.web.filter.authc.UserFilter](https://shiro.apache.org/static/1.8.0/apidocs/org/apache/shiro/web/filter/authc/UserFilter.html)

### 简单使用
#### 1. 简单使用
1. 新建一个项目25_TestShiro项目
2. pom.xml添加依赖
    
    ```
    <dependencies>
        <dependency>
            <groupId>org.apache.shiro</groupId>
            <artifactId>shiro-core</artifactId>
            <version>1.7.0</version>
        </dependency>

        <!--shiro用到了SLF4J这个日志文件，但是缺乏实现，因此 可以根据自身需要选择SLF4J的实现-->
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>1.2.3</version>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.16</version>
            <scope>provided</scope>
        </dependency>
    </dependencies>
    ```
3. 在resources下新建一个realm.inl文件
    1. 相当于存储数据的地方，类似数据库
        
        ```
        [users]
        //用户名    密码    角色
        zhangsan = 123456, admin
        lisi = 123456, normal
        zh = 123456, normal
        
        [roles]
        //角色    权限1         权限2     权限3         权限4
        admin = user:create, user:read, user:update, user:delete
        normal = user:read
        ```
4. 创建一个Main类，main函数测试代码如下：
    
    ```
    // 安全管理器：DefaultSecurityManager是SecurityManager的实现类型
    DefaultSecurityManager mgr = new DefaultSecurityManager();
    // 设置安全管理器
    SecurityUtils.setSecurityManager(mgr);
    // 设置Realm,通常资源是数据库，这里先搞一个ini最为数据源
    mgr.setRealm(new IniRealm("classpath:realm.ini"));

    // 主体：Subject
    Subject subject = SecurityUtils.getSubject();

    // 登录
    String username = "zh";
    String password = "123456";
    UsernamePasswordToken token = new UsernamePasswordToken(username, password);

    try {
        //【登录之前】isAuthenticated -> false
        System.out.println("【登录之前】isAuthenticated -> " + subject.isAuthenticated());

        subject.login(token);
        //【登录之后】isAuthenticated -> true
        System.out.println("【登录之后】isAuthenticated -> " + subject.isAuthenticated());
        //判断用户是否有相应的权限
        //【权限】user:read -> true
        System.out.println("【权限】user:read -> " + subject.isPermitted("user:read"));
        //【权限】user:update -> false
        System.out.println("【权限】user:update -> " + subject.isPermitted("user:update"));
        //【权限】user:delete -> false
        System.out.println("【权限】user:delete -> " + subject.isPermitted("user:delete"));
        //【权限】user:create -> false
        System.out.println("【权限】user:create -> " + subject.isPermitted("user:create"));

        //判断用户是否有相应的角色
        //【角色】admin -> false
        System.out.println("【角色】admin -> " + subject.hasRole("admin"));
        //【角色】normal -> true
        System.out.println("【角色】normal -> " + subject.hasRole("normal"));

        // 退出登录
        subject.logout();
        //【退出登录】isAuthenticated -> false
        System.out.println("【退出登录】isAuthenticated -> " + subject.isAuthenticated());
        //【角色】normal -> false
        System.out.println("【角色】normal -> " + subject.hasRole("normal"));
    } catch (UnknownAccountException e) {
        System.out.println("用户名不存在");
    } catch (IncorrectCredentialsException e) {
        System.out.println("密码不正确");
    } catch (AuthenticationException e) {
        System.out.println("认证失败");
    }
    ```
    
#### 2. 存储源为数据库
1. 创建一个类Dbs模拟数据库
    
    ```
    public class Dbs {
        //到数据库中查询用户的用户名、密码
        public static SysUser get(String username) {
            if ("zh666".equals(username)) {
                SysUser user = new SysUser();
                user.setUsenrname("zh666");
                user.setPassword("zh666");
                return user;
            } else if ("zh333".equals(username)) {
                SysUser user = new SysUser();
                user.setUsenrname("zh333");
                user.setPassword("zh333");
                return user;
            }
            return null;
        }
    
        //到数据库查询用户的角色
        public static List<String> getRoles(String username) {
            if ("zh666".equals(username)) {
                return  List.of("admin");
            } else if ("zh333".equals(username)) {
                return List.of("normal");
            }
            return null;
        }
    
        //到数据库中查询用户的权限
        public static List<String> getPermissions(String username) {
            if ("zh666".equals(username)) {
                return List.of("user:create", "user:update", "user:delete");
            } else  if ("zh333".equals(username)) {
    
                return List.of("user:read");
            }
            return null;
        }
    }
    ```
2. SysUser
    
    ```
    @Data
    public class SysUser {
        private String usenrname;
        private String password;
    }
    ```
3. 自定义Realm类CustomRealm
    
    ```
    public class CustomRealm extends AuthorizingRealm {

        /**
         * 当主体（subject）要进行权限\角色（isPermitted、hasRole）判断时，就会调用
         *
         * 开发者需要在这个方法中干啥？【一般】
         * 根据用户名查询用户的角色\权限信息
         *
         * @return 用户的角色\权限信息
         */
        @Override
        protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
            //获取用户名
            String username = (String) principals.getPrimaryPrincipal();
    
            SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();
    
            List<String> roles = Dbs.getRoles(username);
            if (roles != null) {
                info.addRoles(roles);
            }
    
            List<String> permissions = Dbs.getPermissions(username);
            if (permissions != null) {
                info.addStringPermissions(permissions);
            }
    
            return info;
        }
    
        /**
         * 当主体（subject）要进行认证（login、logout）时，就会调用
         *
         * 开发者需要在这个方法中干啥？【一般】
         * 根据用户名查询用户的具体信息（用户名、密码）
         *
         * @param token subject.login()登录时传进来的token
         * @return 用户名的具体信息（用户名、密码）
         */
        @Override
        protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
            // 获取token
            UsernamePasswordToken tk = (UsernamePasswordToken) token;
    
            //根据token获取用户名
            String username = (String) tk.getPrincipal();
    
            // 根据用户名去数据库中查询用户信息
            SysUser user = Dbs.get(username);
            if (user == null) return null;
    
            // 认证成功
            return new SimpleAuthenticationInfo(user.getUsenrname(), user.getPassword(), getName());
        }
    }
    ```
4. main函数代码
    1. 仅仅将原来的mgr.setRealm代码替换成如下
        
        ```
        // 设置Realm
        mgr.setRealm(new CustomRealm());
        ```
5. **分析**
    1. 自定义CustomRealm类的原因是可以自定义Realm的数据源
    2. 认证流程如下：
        1. Subject.login(token)
        2. SecurityManager -> Authenticator -> Realm【AuthorizingRealm】
        3. info = AuthorizingRealm.doGetAuthenticationInfo(token)，根据token信息查询对应的用户信息（比如去数据库中查找）
        4. CredentialsMatcher.doCredentialsMatch(token, info)，判断token、info的Credentials是否匹配
            1. CredentialsMatcher：专门用来判断Credentials是否正确
            2. **即专门用来匹配传值与存储值的算法类**
            3. **也可以自定义CredentialsMatcher的实现类，使用自己的算法类**
    3. 判断权限、角色流程：
        1. Subject.isPermitted(permission)、Subject.hasRole(role)
        2. SecurityManager -> Authorizer -> Realm【AuthorizingRealm】
        3. info = AuthorizingRealm.doGetAuthorizationInfo(principal的集合)，根据principal查询对应的角色、权限信息
        4. 根据返回的info信息与传进来的判断权限、角色是否正确
    4. **注意：上面流程要与上面的图做参照理解**

