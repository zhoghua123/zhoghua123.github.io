---
layout: post
title: Java常用企业框架-Spring(三)
category: Java后端开发
tags: Java后端开发
description: Java后端开发
--- 

## 代理
1. 业务层（Service）的主要内容
    1. 业务代码：业务运算、dao操作等（必要）
        1. 最终的结果需要通过几个数据库查询然后计算得出
    2. 附加代码：事务、日志、性能监控、异常处理等（可选）
        1. 查询几个数据库必须有条件，同时成功、失败等
        2. 计算结果完成还需要将结果记录日志
        3. 对整段业务代码进行trycatch
    
    ![图1](https://gitee.com/zhonghua123/blogimgs/raw/master/img/javazh-27.png)
2. 现在的尴尬情况
    1. 在业务层加入附加代码会显得很臃肿、累赘
    2. 但很多时候又好像不得不加
3. 代理
    1. 在**不修改**目标类的目标方法代码的前提下，为目标方法增加额外功能
    2. **代理的必要条件：**代理类中必须也有同样的目标方法
        1. 代理类实现跟目标类同样的接口
        2. 若目标类没有实现**接口**，代理类继承目标类
    
    ![图1](https://gitee.com/zhonghua123/blogimgs/raw/master/img/javazh-28.png)
4. 代理的实现方案
    1. 静态代理（Static Proxy)
        1. 开发人员手动编写代理类（创建对应的*.java文件）
        2. 基本上，一个目标类就要编写一个代理类
    2. 动态代理（Dynamic Proxy):：程序运行过程动态生成代理类的字节码

### 静态代理
1. 业务层service
    1. UserService
        
        ```
        //接口
        public interface UserService {
            boolean login(String username, String password);
        }
        //实现类
        public class UserServiceImpl implements UserService{
            //业务方法
            @Override
            public boolean login(String username, String password) {
                System.out.println("09 - UserServiceImpl - login - " + username + "_" + password);
                return false;
            }
        }
        ```
    2. SkillService
        
        ```
        //只有目标实现类，没有接口
        public class SkillService {
            public boolean save(Object skill) {
                System.out.println("SkillServiceImpl - save");
                return false;
            }
        }
        ```
2. 手动实现对应业务层类的代理类
    1. UserServiceProxy
        
        ```
        //代理类实现跟目标类同样的接口
        public class UserServiceProxy implements UserService {
            private UserService target;
        
            public void setTarget(UserService target) {
                this.target = target;
            }
        
            @Override
            public boolean login(String username, String password) {
                System.out.println("日志------------------1");
        
                boolean result = target.login(username, password);
        
                System.out.println("日志------------------2");
                return result;
            }
        }
        ```
    2. SkillServiceProxy
        
        ```
        //若目标类没有实现接口，代理类继承目标类
        public class SkillServiceProxy extends SkillService {
            private SkillService target;
        
            public void setTarget(SkillService target) {
                this.target = target;
            }
        
            @Override
            public boolean save(Object skill) {
                System.out.println("SkillServiceProxy - 1");
                boolean result = target.save(skill);
                System.out.println("SkillServiceProxy - 2");
                return result;
            }
        }
        ```
3. applicationContext.xml中注册类
    
    ```
    <!--代理对象1-->
    <bean id="userService"
          class="com.zh.proxy.UserServiceProxy">
        <!--设置目标类（委托方） -->
        <property name="target">
            <bean class="com.zh.service.impl.UserServiceImpl"/>
        </property>
    </bean>
    <!--代理对象2-->
    <bean id="skillService"
          class="com.zh.proxy.SkillServiceProxy">
        <!--设置目标类（委托方） -->
        <property name="target">
            <bean class="com.zh.service.SkillService"/>
        </property>
    </bean>
    ```
4. UserTest
    
    ```
    @Test
    public void test() {
        // 创建容器
        ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
        //此时拿到的是代理对象UserServiceProxy，不是UserServiceImpl对象
        UserService userService = ctx.getBean("userService", UserService.class);
        service.login("123", "456");
        SkillService skillService = ctx.getBean("skillService", SkillService.class);
        service.save(null);

        // 关闭容器
        ctx.close();
    }
    ```

### 动态代理(Dynamic Proxy)
1. 动态代理的常见实现方案有2种
    1. JDK自带的API
        1. 本质：代理类实现跟目标类一样的接口
    2. 开源项目GGLib(Code Generation Library)
        1. 本质：代理类继承目标类
        2. Spring已经集成了GGLib
        
### 动态代理-JDK
1. 本质就是通过JDK自带的API动态的实现一个对象，这个对象与目标类有相同的实现方法（**通过与目标类实现相同的接口**）
2. 目标类，service业务层
    
    ```
    //接口
    public interface UserService {
        boolean login(String username, String password);
    }
    //实现
    public class UserServiceImpl implements UserService {
        @Override
        public boolean login(String username, String password) {
            System.out.println("UserServiceImpl - login");
            return false;
        }
    }
    ```
3. applicationContext.xml中注册类
    
    ```
    <bean id="userService" class="com.zh.service.impl.UserServiceImpl"/>
    ```
4. UserTest
    
    ```
    @Test
    public void test() {
        // 创建容器
        ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");

        // 目标对象
        UserServiceImpl target = ctx.getBean("userService", UserServiceImpl.class);

        // 代理对象
        //JDK的API，通过传递类加载器、需要实现的接口、附加block，动态生成一个对象
        UserService userService = (UserService) Proxy.newProxyInstance(
                getClass().getClassLoader(), // 类加载器
                target.getClass().getInterfaces(), // 代理类需要实现的接口（目标类的接口）
                (Object proxy, Method method, Object[] args) -> { // 附加代码（代理类的具体实现）
                    // proxy：代理对象
                    // method：目标方法
                    // args：目标方法的参数

                    System.out.println("proxy - 1");

                    // 调用目标对象的目标方法（核心业务代码）
                    Object result = method.invoke(target, args);

                    System.out.println("proxy - 2");

                    return result;
                });

        //通过代理对象调用目标方法，会调用它的block代码
        userService.login("123", "456");

        // 关闭容器
        ctx.close();
    }
    ```
5. 分析：
    1. 上面的方法实现，如果有n个类，那么动态的实现需要写n段相同的代码
    2. 如果n个类要同时实现，比如service层的类都要实现呢？
    3. 此时可以用上节讲的生命周期方法拦截所有的对象，一次性处理
    4. 经过排查可以使用postProcessAfterInitialization方法中进行拦截

#### 统一封装设置动态代理
1. 创建LogProcessor类
    
    ```
    //com.zh.processor.LogProcessor
    /**
     * 会拦截每一个bean的生命周期
     * 监听初始化操作，每个bean对象只会执行一次
     */
    public class LogProcessor implements BeanPostProcessor {
        //初始化完毕，然后生成代理
        @Override
        public Object postProcessAfterInitialization(Object target, String beanName) throws BeansException {
            return Proxy.newProxyInstance(
                    getClass().getClassLoader(), // 类加载器
                    target.getClass().getInterfaces(), // 代理类需要实现的接口（目标类的接口）
                    new LogInvocationHandler(target)); // 附加代码;
        }
    
    
        //封装一个类
        private static class LogInvocationHandler implements InvocationHandler {
            private final Object target;
            public LogInvocationHandler(Object target) {
                this.target = target;
            }
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    
                System.out.println("proxy - 1");
    
                // 调用目标对象的目标方法（核心业务代码）
                Object result = method.invoke(target, args);
    
                System.out.println("proxy - 2");
    
                return result;
            }
        }
    }
    ```
2. applicationContext.xml中注册
    
    ```
    <bean class="com.zh.processor.LogProcessor"/>
    ```
3. UserTest
    
    ```
    @Test
    public void test3() {
        // 创建容器
        ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");

        //此时获取的就是代理对象userService
        UserService userService = ctx.getBean("userService", UserService.class);
        userService.login(null, null);
    }
    ```

### 动态代理-GGLib
1. 本质是使用Spring内部集成GGLib的API来动态的实现一个对象，这个对象与目标类有相同的实现方法（**通过集成目标类来实现**）
2. 目标类，service业务层
    
    ```
    //只有实现，没有接口
    public class SkillService {
        public boolean save(Object skill) {
            System.out.println("SkillService - save");
            return false;
        }
    }
    ```
3. 统一封装拦截所有对象创建，动态实现代理
    
    ```
    public class LogProcessor2 implements BeanPostProcessor {
        @Override
        public Object postProcessAfterInitialization(Object target, String beanName) throws BeansException {
            //过滤哪些对象需要设置代理
            //if (beanName.equals("person")) return target;
            if (!beanName.endsWith("Service")) return target;
    
            Enhancer enhancer = new Enhancer();
            // 可以省略，内部自动获取类加载器
            // enhancer.setClassLoader(getClass().getClassLoader());
            //代理类继承目标类
            enhancer.setSuperclass(target.getClass());
            //附加代码
            enhancer.setCallback(new LogMethodInterceptor(target));
            //返回代理
            return enhancer.create();
        }
    
        //MethodInterceptor方法拦截器接口，callback的参数
        private static class LogMethodInterceptor implements MethodInterceptor {
            private final Object target;
            public LogMethodInterceptor(Object target) {
                this.target = target;
            }
            @Override
            public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
    
                String name = method.getName();
                // method.getReturnType();
                // method.getParameterTypes();
                System.out.println("1-------------------");
                Object result = method.invoke(target, args);
                System.out.println("2-------------------");
                return result;
            }
        }
    }
    ```
4. applicationContext.xml中注册
    
    ```
    <bean id="skillService" class="com.zh.service.SkillService"/>
    <bean class="com.zh.processor.LogProcessor2"/>
    ```
5. UserTest
    
    ```
    // 创建容器
    ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
    SkillService skillService = ctx.getBean("skillService", SkillService.class);
    skillService.save(null);
    UserService userService = ctx.getBean("userService", UserService.class);
    userService.login(null, null);
    ```

#### 缺点分析
1. 某些类不需要代理，需要进行拦截设置
2. 不同的类有不同的附加代码，需要不同设置
3. 所有的拦截都放在LogProcessor，代码极度冗余
4. 解决办法---AOP:可以实现简单控制，哪些类需要实现代理，哪些方法需要实现附加方法

## AOP(Aspect Oriented Programming)
1. 面向切面编程
2. Spring使用AOP技术封装了动态代理的功能，使用起来非常简单
3. 它依赖于AspectJ库
    
    ```
    <dependency>
        <groupId>org.aspectj</groupId>
        <artifactId>aspectjrt</artifactId>
        <version>1.9.6</version>
    </dependency>
    <dependency>
        <groupId>org.aspectj</groupId>
        <artifactId>aspectjweaver</artifactId>
        <version>1.9.6</version>
    </dependency>
    ```


