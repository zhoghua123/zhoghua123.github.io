---
layout: post
title: 项目实战三-前后端分离驾考项目（二）
category: Java后端开发
tags: Java后端开发
description: Java后端开发
---  

## 前后端分离驾考项目

### 项目整合（一）
1. 整合点梳理
    1. 控制器中的list方法
        
        ```
        public Map<String,Object> list(long page, long size,String keyword){};
        ```
    2. 需要接收参数，而且有可能有n个搜索参数，因此可以封装
    3. 前面讲过可以封装成一个query对象，不同的页面搜索使用不同的query类，而且每次查询的结果封装给这个query对象
        
        ```
        public Map<String,Object> list(DictTypeQuery query){};
        ```
2. 在pojo下新增一个query包，下面存放各个页面的query类
    
    ```
    //基类PageQuery
    @Data
    public class PageQuery {
        private static final int DEFAULT_SIZE = 10;
        private long page;
        private long size;
        //当前页的数据
        private List<?> data;
        //总数
        private long count;
        //总页数
        private long pages;
    
        public long getPage() {
            return Math.max(page,1);
        }
    
        public long getSize() {
            return (size < 1) ? DEFAULT_SIZE : size;
        }
    }
    //KeywordQuery
    @EqualsAndHashCode(callSuper = true)
    @Data
    public class KeywordQuery extends PageQuery {
        private String keyword;
    }
    //数据字典类型页面
    @EqualsAndHashCode(callSuper = true)
    @Data
    public class DictTypeQuery extends KeywordQuery {}
    //省份页面
    @EqualsAndHashCode(callSuper = true)
    @Data
    public class ProvinceQuery extends KeywordQuery{}
    ```
3. service层更新
    1. 数据字典类型页面
        
        ```
        //DictTypeService
        public interface DictTypeService extends IService<DictType> {
            void list(DictTypeQuery query);
        }
        //DictTypeServiceImpl
        @Service
        @Transactional
        public class DictTypeServiceImpl extends ServiceImpl<DictTypeMapper, DictType> implements DictTypeService {
            @Autowired
            private DictTypeMapper mapper;
            @Override
            public void list(DictTypeQuery query) {
                //配置搜索条件
                LambdaQueryWrapper<DictType> queryWrapper = new LambdaQueryWrapper<>();
                String keyword = query.getKeyword();
                if(!StringUtils.isEmpty(keyword)){
                    queryWrapper.like(DictType::getName,keyword).or()
                            .like(DictType::getValue,keyword).or()
                            .like(DictType::getIntro,keyword);
                }
                //根据id降序
                queryWrapper.orderByDesc(DictType::getId);
        
                MpPage<DictType> page = new MpPage<>(query);
                //查询
                mapper.selectPage(page,queryWrapper);
                //填充结果
                page.updateQuery(query);
            }
        }
        ```
    2. 省份页面
        
        ```
        public interface ProvinceService extends IService<Province> {
            void list(ProvinceQuery query);
        }
        
        @Service
        @Transactional
        public class ProvinceServiceImpl extends ServiceImpl<ProvinceMapper, Province> implements ProvinceService {
            @Autowired
            private ProvinceMapper mapper;
            @Override
            public void list(ProvinceQuery query) {
                String keyword = query.getKeyword();
                //配置搜索条件
                LambdaQueryWrapper<Province> queryWrapper = new LambdaQueryWrapper<>();
                if(!StringUtils.isEmpty(keyword)){
                    queryWrapper.like(Province::getName,keyword).or()
                            .like(Province::getPlate,keyword);
                }
                //根据id降序
                queryWrapper.orderByDesc(Province::getId);
                mapper.selectPage(new MpPage<>(query),queryWrapper).updateQuery(query);
            }
        }
        ```
4. MpPage是Page的增强类，用于抽取冗余代码
    
    ```
    //com.zh.jk.common.enhance
    public class MpPage<T> extends Page<T> {
        public MpPage(PageQuery query) {
            super(query.getPage(),query.getSize());
        }
        //如果不使用增强类，这段代码将会在每个service中重复写
        public void updateQuery(PageQuery query) {
            //填充结果
            query.setCount(getTotal());
            query.setPages(getPages());
            query.setData(getRecords());
            query.setPages(getCurrent());
            query.setSize(getSize());
        }
    }
    ```
5. controller
    1. DictTypeController、ProvinceController的list方法如下
    
    ```
    //DictTypeController
    @GetMapping
    public Map<String,Object> list(DictTypeQuery query) {
        service.list(query);
        Map<String,Object> map = new HashMap<>();
        map.put("code",0);
        map.put("msg","");
        map.put("count",query.getCount());
        map.put("data",query.getData());
        return map;
    }
    //ProvinceController
    @GetMapping
    public Map<String,Object> list(ProvinceQuery query) {
        service.list(query);
        Map<String,Object> map = new HashMap<>();
        map.put("code",0);
        map.put("msg","");
        map.put("count",query.getCount());
        map.put("data",query.getData());
        return map;
    }
    ```

### 项目整合（二）
1. 项目的整体思路
    1. controller调用service，serivce调用mapper，mapper调用数据库
    2. service层是依赖于mybatis-plus插件
        1. ClassService继承与IService
        2. ClassServiceImpl继承与ServiceImpl
        
#### 优化service层（与上面代码进行对比查看）
1. 优化掉成员mapper
    1. DictTypeServiceImpl继承`ServiceImpl<DictTypeMapper, DictType>`
    2. 可以看到已经传递了DictTypeMapper泛型，查看ServiceImpl类，内部有个baseMapper成员
    3. 因此DictTypeServiceImpl内部不需要在设置成员，直接使用baseMapper
2. 优化配置搜索条件
    1. 会发现关键字搜索那块，ProvinceServiceImpl/DictTypeServiceImpl二者非常相似，可以抽取
    2. 新建一个MpQueryWrapper类继承自LambdaQueryWrapper，做一个增强，将搜索配置条件那块代码抽取进去
3. 改造如下
    1. MpQueryWrapper
        
        ```
        //com.zh.jk.common.enhance
        public class MpQueryWrapper<T> extends LambdaQueryWrapper<T> {
            @SafeVarargs
            public final MpQueryWrapper<T> like(Object val, SFunction<T, ?>... funcs) {
                if (val == null) return this;;
                String str = val.toString();
                if (str.length() == 0) return this;
                // this.like(funs[0],val).or().like(funs[1],val).or().like(funs[2],val).or();
                //nested 会自动去掉最后一个or.(),返回值是MpQueryWrapper的父类，因此这要做一个强制转换
                return (MpQueryWrapper<T>) nested((w)->{
                    for (SFunction<T, ?> func : funcs) {
                        w.like(func,str).or();
                    }
                });
        
            }
        }
        ```
    2. DictTypeServiceImpl
        
        ```
        @Service
        @Transactional
        public class DictTypeServiceImpl extends ServiceImpl<DictTypeMapper, DictType> implements DictTypeService {
        //    @Autowired
        //    private DictTypeMapper mapper;
            @Override
            public void list(DictTypeQuery query) {
                //配置搜索条件
        //        LambdaQueryWrapper<DictType> queryWrapper = new LambdaQueryWrapper<>();
                MpQueryWrapper<DictType> queryWrapper = new MpQueryWrapper<>();
                queryWrapper.like(query.getKeyword(),DictType::getName,DictType::getValue,DictType::getIntro);
        //        String keyword = query.getKeyword();
        //        if(!StringUtils.isEmpty(keyword)){
        //            queryWrapper.like(DictType::getName,keyword).or()
        //                    .like(DictType::getValue,keyword).or()
        //                    .like(DictType::getIntro,keyword);
        //        }
                //根据id降序
                queryWrapper.orderByDesc(DictType::getId);
        
                MpPage<DictType> page = new MpPage<>(query);
                //查询
        //        mapper.selectPage(page,queryWrapper);
                //selectPage返回值是MpPage<DictType>
                baseMapper.selectPage(page,queryWrapper);
                //填充结果
                page.updateQuery(query);
            }
        }
        ```
    3. ProvinceServiceImpl
        
        ```
        @Service
        @Transactional
        public class ProvinceServiceImpl extends ServiceImpl<ProvinceMapper, Province> implements ProvinceService {
            @Override
            public void list(ProvinceQuery query) {
                String keyword = query.getKeyword();
                //配置搜索条件
                MpQueryWrapper<Province> queryWrapper = new MpQueryWrapper<>();
                queryWrapper.like(query.getKeyword(),Province::getName,Province::getPlate);
                //根据id降序
                queryWrapper.orderByDesc(Province::getId);
                baseMapper.selectPage(new MpPage<>(query),queryWrapper).updateQuery(query);
            }
        }
        ```

#### controller层返回给客户端的结果优化
1. 通常一个后台项目返回给客户端的n个接口数据格式是一样的，统一的规范，比如规范如下：
    
    ```
    {
        "code": 1,
        "msg": "成功或者失败信息",
        "data":[
            ...
        ]
    }
    ```
2. 在pojo下新建一个result包，下面新建一个类R
    
    ```
    //com.zh.jk.pojo.result
    /**
     * 返回给用户的JSON对象
     */
    public class R extends HashMap<String,Object> {
        private static final String K_CODE = "code";
        private static final String K_MSG = "msg";
        private static final String K_DATA = "data";
        private static final int CODE_SUCCESS = 0;
        private static final int CODE_ERROR_DEFAULT = 400;
    
        public R setSuccess(boolean success) {
            return success ? setCode(CODE_SUCCESS) : setCode(CODE_ERROR_DEFAULT);
        }
        public R setCode(int code) {
            put(K_CODE,code);
            return this;
        }
        public R setMsg(String msg) {
            put(K_MSG,msg);
            return this;
        }
        public R setData(Object data) {
            put(K_DATA,data);
            return this;
        }
    }
    ```
3. 在common下新建一个util包，内部新建一个Rs类，专门针对R类扩展的一些方法
    
    ```
    //com.zh.jk.common.util
    public class Rs {
        private static final String K_COUNT = "count";
        public static R ok(PageQuery query) {
            R r = new R();
            r.put(K_COUNT,query.getCount());
            return r.setSuccess(true).setData(query.getData());
        }
        public static R error(String msg) {
            return new R().setSuccess(false).setMsg(msg);
        }
        public static R ok(String msg) {
            return new R().setSuccess(true).setMsg(msg);
        }
        public static R ok(Object data) {
            return new R().setSuccess(true).setData(data);
        }
        public static R ok() {
            return new R().setSuccess(true);
        }
    }
    ```
4. DictTypeController控制器内部方法改造
    
    ```
    @GetMapping
    public R list(DictTypeQuery query) {
        service.list(query);
        return Rs.ok(query);
    }
    @PostMapping("/remove")
    public R remove(String id){
        //id = 10 或者 id = 10,20,30
        String[] idStrs =  id.split(",");

        //批量删除
        //数组转化为集合
        //Arrays.asList(idStrs)
        if (service.removeByIds(Arrays.asList(idStrs))){
            return Rs.ok("删除成功");
        }else {
            return Rs.error("删除失败");
        }
    }
    @PostMapping("/save")
    public R save(DictType dictType){
        if ( service.saveOrUpdate(dictType)){
            return Rs.ok("保存成功");
        }else {
            return Rs.error("保存失败");
        }
    }
    ```

#### 统一异常处理
1. 如果因为某些原因java代码抛出异常了，通常情况下返回给客户端的是非常长的异常信息，那么可以进行异常的统一处理，友好的返回给客户端

