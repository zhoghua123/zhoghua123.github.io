---
layout: post
title: Java语言基础(SE)-第六节 泛型、集合
category: Java后端开发
tags: Java后端开发
description: Java后端开发
--- 

## 泛型（Generics）
1. 从 Java 5 开始，增加了泛型技术
2. 什么是泛型？
    1. **将类型变为参数，提高代码复用率**
3. 建议的类型参数名称
    
    ```
    T ：Type 
    E ：Element 
    K ：Key 
    N ：Number 
    V ：Value 
    S、U、V ：2nd, 3rd, 4th types
    ```
    
### 泛型类型（Generic Type）
1. 什么是泛型类型？
    1. 使用了泛型的**类或者接口**
    2. 比如
        1. `java.util.Comparator`
        2. `java.util.Comparable`
    
    ```
    public class Student<T> {
        private T score;
        public T getScore() {
            return score;
        }
        public void setScore(T score) {
            this.score = score;
        }
    }
    //main函数
    Student<String> stu = new Student<>();
    stu.setScore("A");
    String score1 = stu.getScore();
    Student<Double> stu2 = new Student<>();
    stu2.setScore(98.5);
    double score2 = stu2.getScore();
    ```
2. 多个类型参数   
    
    ```
    public class Student<N,S> {
        private N no;
        private S score;
        public Student(N no, S score) {
            this.no = no;
            this.score = score;
        }
    }
    
    //main函数
    Student<String, String> s1 = new Student<>("E925", "A+");
    Student<Integer, Double> s2 = new Student<>(18, 96.5);
    ```

#### 泛型类型的继承
1. JDK中的继承
    
    ```
    public interface Iterable<T>
    public interface Collection<E> extends Iterable<E>
    public interface List<E> extends Collection<E>
    public class ArrayList<E> implements List<E>
    ```
2. 示例
    
    ```
    Iterable<String> it = null;
    Collection<String> col = null;
    List<String> li = null;
    ArrayList<String> al = null;
    	
    it = col;
    col = li;
    li = al;
    
    //二者不存在继承关系
    List<Object> list = null;
    ArrayList<String> all = null;
    //错误
    //list = all;
    ```
3. 示例2：
    
    ```
    package com.zh;
    import java.util.List;
    public interface MyList<E,T> extends List<E> {
        void setNo(T no);
    }
    
    //main函数
    List<String> li = null;
    MyList<String, Integer> ml1 = null;
    MyList<String, Integer> ml2 = null;
    MyList<String, Integer> ml3 = null;
    li = ml1;
    li = ml2;
    li = ml3;
    ```

#### 原始类型（Raw Type）
1. 什么是原始类型？
    1. 没有传递具体的类型给泛型的类型参数
    
    ```
    //Box称为是B<E>的原始类型（Raw Type）
    Box rawBox = new Box();//warning :rawtypes
    Box<String> strBox = new Box<>();
    rawBox = strBox;//ok
    strBox = rawBox;//warning :unchecked
    ```
2. 当使用了原始类型时，编译器会给出 警告（可以用@SuppressWarnings消除）
3. 将非原始类型赋值给原始类型时，编译器没有任何警告和错误
4. 将原始类型赋值给非原始类型时，编译器会给出 警告（可以用@SuppressWarnings消除）
5. Box 是原始类型，Box<Object> 是非原始类型


### 泛型方法（Generic Method）
1. 什么是泛型方法？
    1. 使用了泛型的方法（实例方法、静态方法、构造方法），比如 `Arrays.sort(T[], Comparator<T>)`
    
    
    
## 集合（Collections）
1. 集合（Collections）
    1. java.util 包中有个集合框架（Collections Framework），提供了一大堆常用的数据结构
        1. ArrayList、LinkedList、Queue、Stack、HashSet、HashMap 等
2. 集合框架预览

    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/javazh-11.png) 
    
    1. 紫色代表接口，箭头表示某个类实现了某个接口
    2. 蓝色代表抽象类，不能实例化，从**下往上**是父类到子类
    3. 绿色代表类，可以实例化

### ArrayList
1. 数组的局限性
    1. 无法动态扩容
    2. 操作元素的过程不够面向对象
2. ArrayList 是 Java 中的动态数组
    1. 一个可以动态扩容的数组
    2. 封装了各种实用的数组操作
3. ArrayList 的扩容原理
    1. ArrayList 的最小容量是 10 (可查看源码)
    2. 每次扩容时，新容量是旧容量的 1.5 倍
4. ArrayList 的常用方法
    
    ```
    private int size;
    public boolean isEmpty()
    public boolean contains(Object o)
    public int indexOf(Object o)
    public int lastIndexOf(Object o) 
    public E get(int index)
    public E set(int index, E element)
    public boolean add(E e)
    public void add(int index, E element) 
    public E remove(int index)
    public boolean remove(Object o)
    public void clear()
    public boolean addAll(Collection<? extends E> c)
    public boolean addAll(int index, Collection<? extends E> c
    public boolean removeAll(Collection<?> c)
    public boolean retainAll(Collection<?> c)
    public void forEach(Consumer<? super E> action)
    public void sort(Comparator<? super E> c)
    public Object[] toArray()
    public <T> T[] toArray(T[] a)
    //根据现有数组的实际大小(现有数组的容量为1w，但是实际存了10个元素，浪费)，进行缩小容量，提高性能
    public void trimToSize()
    //指定动态数组一次性扩展到多少容量，不用每次不足再动态计算，提前扩容
    public void ensureCapacity(int minCapacity)
    ```
5. ArrayList 的基本使用
    
    ```
    ArrayList list = new ArrayList();
    list.add(11);
    list.add(false);
    list.add(null);//可以添加null值
    list.add(3.4);
    list.add(0,"jack");
    list.add('8');
    //3
    System.out.println(list.indexOf(null));
    //6
    System.out.println(list.size());
    //[jack, 11, false, null, 3.4, 8]
    System.out.println(list);
    ```
6. retainAll/removeAll
    
    ```
    //以接口作为类型，便于扩展
    List<Integer> list1 = new ArrayList<>();
    list1.add(11);
    list1.add(22);
    list1.add(33);
    list1.add(44);
    	
    List<Integer> list2 = new ArrayList<>();
    list2.add(22);
    list2.add(44);
    //[11, 33]
    //list1.removeAll(list2);
    //从list中删掉list2除中元素以外的所有元素
    //[22, 44]
    list1.retainAll(list2);
    System.out.println(list1);
    ```
7. toArray
    
    ```
    List<Integer> list = new ArrayList<>();
    list.add(11);
    list.add(22);
    list.add(33);
    //将ArrayList转化为普通数组，但是类型是Object的
    Object[]  array1 = list.toArray();
    //[Ljava.lang.Object;@7852e922
    System.out.println(array1);
    //[11, 22, 33]
    System.out.println(Arrays.toString(array1));
    	
    //转化为指定类型的普通数组
    Integer[] array2 = list.toArray(new Integer[0]);
    //[Ljava.lang.Integer;@4e25154f
    System.out.println(array2);
    //[11, 22, 33]
    System.out.println(Arrays.toString(array2));
    ```
    
#### 遍历
1. 举例
    
    ```
    List<Integer> list = new ArrayList<>();
    list.add(11);
    list.add(22);
    list.add(33);
    //方法1
    for (int i = 0; i < list.size(); i++) {
        System.out.println(list.get(i));
    }
    //方法2：使用迭代器
    //拿到迭代器
    Iterator it = list.iterator();
    //是否有下一个
    while (it.hasNext()) {
        Object obj = it.next();
        System.out.println(obj);
    }
    //方法3
    for (Object obj : list) {
        System.out.println(obj);
    }
    //方法4
    list.forEach((obj)->{
        System.out.println(obj);
    });
    ```
2. for-each 格式
    
    ```
    for(元素类型 变量名 : 数组/Iterable){
    }
    ```
    
    1. **实现了 Iterable 接口的对象，都可以使用 for-each 格式遍历元素**
        1. 比如 List、Set 等
    2. Iterable 在使用 foreach 格式遍历元素时，本质是使用了 Iterator 对象
3. 自定义 Iterable、Iterator
    1. 如何自定义一个集合，可以使用foreach格式遍历元素
        
        ```
        package com.zh;
        import java.util.Iterator;
        public class ClassRoom implements Iterable<String> {
            //存放所有学生
            private String[] students;
            public ClassRoom(String... students) {
                this.students = students;
            }
            //实现接口方法Iterable,改方法要求返回一个Iterator（迭代器）接口类型的对象
            @Override
            public Iterator<String> iterator() {
                //返回一个Iterator类型的对象
                return new ClassRoomIterator();
            }
            	
            //创建一个私有类继实现Iterator这个接口
            private class ClassRoomIterator implements Iterator<String> {
                private int index;
                //该方法用于判断当前数组是否还有下一个元素
                @Override
                public boolean hasNext() {
                    return index < students.length;
                }
                //该方法是用来返回当前数组的下一个元素
                @Override
                public String next() {
                    return students[index++];
                }
            }
        }
        
        //main函数
        ClassRoom room = new ClassRoom("jack","rose");
        //jack rose
        for (String name : room) {
            System.out.println(name);
        }
        	//方法2
        Iterator<String> it = room.iterator();
        while (it.hasNext()) {
            String obj = it.next();
            System.out.println(obj);
        }
        ```

4. **遍历的注意点**
    1. 需求：通过遍历的方式，挨个删除所有的元素
        
        ```
        List<Integer> list = new ArrayList<>();
        list.add(11);
        list.add(22);
        list.add(33);
        list.add(44);
        int size = list.size();
        for (int i = 0; i < size; i++) {
            //报错：java.lang.IndexOutOfBoundsException
            //list.remove(i);
        }
        	
        for (int i = 0; i < list.size(); i++) {
            list.remove(i);
        }
        //[22, 44] 注意！！！，并不能删除完全
        System.out.println(list);
        
        for (Integer e : list) {
            //报错： java.util.ConcurrentModificationException
            //list.remove(e);
        }
        list.forEach((e)->{
            //报错：java.util.ConcurrentModificationException
            list.remove(e);
        });
        Iterator<Integer> it = list.iterator();
        while (it.hasNext()) {
            //报错：java.util.ConcurrentModificationException
            list.remove(it.next());
        }
        ```
    2. 如果希望在遍历元素的同时删除元素
        1. 请使用 Iterator 进行遍历
        2. 然后使用 Iterator 的 remove 方法删除元素
        
        ```
        Iterator<Integer> it = list.iterator();
        while (it.hasNext()) {
            it.next();
            it.remove();
        }
        //[],删除成功
        System.out.println(list);
        ```
    3. 使用迭代器、forEach 遍历集合元素时，若使用了**集合自带**的方法修改集合的长度（比如 add、remove 等方法）
        1. 那么会抛出 java.util.ConcurrentModificationException 异常

#### ListIterator
1. ListIterator 继承自 Iterator，在 Iterator 的基础上增加了一些功能
    
    ```
    boolean hasNext();
    E next();
    boolean hasPrevious();
    E previous();
    int nextIndex();
    int previousIndex();
    void remove();
    void set(E e);
    void add(E e);
    ```
2. 举例使用
    
    ```
    ListIterator<Integer> it = list.listIterator();
    while (it.hasNext()) {
        //11 22 33
        System.out.println(it.next());
    }
    while (it.hasPrevious()) {
        //33 22 11
        System.out.println(it.previous());
    }
    
    ListIterator<Integer> it = list.listIterator();
    while (it.hasNext()) {
        it.set(it.next()+55);
    }
    //[66, 77, 88]
    System.out.println(list);
    
    while (it.hasNext()) {
        it.add(66);
        //11 22 33
        System.out.println(it.next());
        it.add(77);
    }
    //[66, 11, 77, 66, 22, 77, 66, 33, 77]
    System.out.println(list);
    ```

