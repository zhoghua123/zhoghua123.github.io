---
layout: post
title: 项目实战二-前后端分离
category: Java后端开发
tags: Java后端开发
description: Java后端开发
---  

## 前后端项目分离

### 前后端的协作模式发展
1. 早期的前后端协作模式
    1. 前端：切图仔、页面仔
        1. 将UI设计的ps图切图标，然后编写静态页面html+css
    2. 后台：动态模板技术组装成HTML
    3. 缺点：
        1. 浪费资源，每次后台返回的是整个页面的数据，即使点击某个按钮改变某一小块东西，也需要重新向后台请求服务器
2. 前后端分离
    1. 前端：切图、页面、交互、路由、业务逻辑
    2. 后台：返回JSON
    3. 优点：节省资源，利用异步网络请求，后台只返回json数据，浏览器解析json数据，动态生成对应的HTML标签，显示到用户面前
3. 前后端分离项目部署
    1. 前端项目部署在页面服务器（Nginx服务器）
    2. 后端项目部署在Tomcat服务器

### 同源策略
1. 浏览器有个[同源策略](https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy)(Same-Origin Policy)
    1. 它规定了：默认情况下，AJAX请求只能发送给同源的URL
    2. 同源是指3个相同：协议、域名（IP）、端口
2. img、script、link、iframe、video、audio等标签不受同源策略的约束
3. 解决AJAX跨域请求的常用方法
    1. CORS(Cross-Origin Resource Sharing)，跨域资源共享
4. CORS的实现需要客户端和服务器同时支持
    1. 客户端
        1. 所有的浏览器都支持（IE至少是IE10版本）
    2. 服务器
        1. 需要返回相应的响应头（比如Access-Control-Allow-Origin)
        2. 告知浏览器这是一个允许跨域访问的请求
    
#### SpringMVC实现CORS
1. 局部设置
    
    ```
    @RestController
    @RequestMapping("/users")
    //只针对某个Controller设置,*代表所有请求源
    //@CrossOrigin("*")
    //指定某个源才能访问，这个也可以放在某个方法上，只针对某个方法进行限制
    @CrossOrigin("http://localhost:63343/")
    public class UserController {
    }
    ```  
2. 全局设置
    1. 后台项目新建一个WebCfg继承自WebMvcConfigurer，全局配置
        
        ```
        @Configuration
        public class WebCfg implements WebMvcConfigurer {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                // /**表示对所有的路径开放全局跨域访问权限
                registry.addMapping("/**")
                        //开放哪些IP 、端口、域名的访问权限
                        .allowedOrigins("*")
                        //是否允许客户端发cookie信息
                        .allowCredentials(true)
                        //哪些HTTP方法允许跨域访问
                        .allowedMethods("GET", "POST")
                        //允许HTTP请求中的携带哪些Header信息
                        .allowedHeaders("*");
                        //暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）
                        //.exposedHeaders("*");
            }
        }
        ```  
    2. 需要客户端设置后才会发Cookie
        
        ```
        let xhr = new XMLHttpRequest();
        xhr.withCredentials = true;
        ```
    
### 项目举例

#### 前端项目FE
1. FE文件夹下就一个index.xml文件，引用了jquery
    
    ```
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
        <style>
            td {
                border: 1px solid #000;
            }
        </style>
    </head>
    <body>
        This is index.html
    
        <button type="button" id="load-btn">加载用户信息</button>
    
        <img src="http://www.baidu.com/img/bd_logo.png">
    
    <script src="js/jquery.min.js"></script>
    <script>
        $(() => {
            $('#load-btn').click(() => {
                $.getJSON('http://localhost:8080/users/list', (users) => {
                    const $table = $('<table>')
                    $(document.body).append($table)
    
                    for (const user of users) {
                        const $tr = $('<tr>')
                        $table.append($tr)
    
                        $tr.append(`<td>${user.name}</td>`)
                        $tr.append(`<td>${user.age}</td>`)
                    }
                })
            })
        })
    </script>
    </body>
    </html>
    ```

#### 后端项目
1. 新建springboot项目BE
2. pom.xml依赖如下
    
    ```
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.3.4.RELEASE</version>
    </parent>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <!--热部署-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>provided</scope>
        </dependency>
    </dependencies>
    ```
3. 新建入口类BeApplication
4. 新建application.yml
    
    ```
    server:
      port: 8080
    
    # 存放所有可以进行跨域的请求
    be:
      cors-origins:
        - http://localhost:63343
        - http://localhost:63342
    ```
5. 新建User模型类
6. 新建控制器
    
    ```
    @RestController
    @RequestMapping("/users")
    //只针对某个Controller设置,*代表所有请求源
    //@CrossOrigin("*")
    //指定某个源才能访问，这个也可以放在某个方法上，只针对某个方法进行限制
    //@CrossOrigin("http://localhost:63343/")
    public class UserController {
        @GetMapping("/list")
        public List<User> list() {
            List<User> users = new ArrayList<>();
            for (int i = 0; i < 10; i++) {
                users.add(new User("hahaha" + i, i + 20));
            }
            return users;
        }
    }
    ```
7. 新建BeProperties
    
    ```
    //com.zh.prop
    @ConfigurationProperties("be")
    @Component
    public class BeProperties {
        private String[] corsOrigins;
    
        public String[] getCorsOrigins() {
            return corsOrigins;
        }
    
        public void setCorsOrigins(String[] corsOrigins) {
            this.corsOrigins = corsOrigins;
        }
    }
    ```
8. 新建WebCfg类，全局配置
    
    ```
    //com.zh.cfg
    @Configuration
    public class WebCfg implements WebMvcConfigurer {
        @Autowired
        private BeProperties properties;
        
        @Override
        public void addCorsMappings(CorsRegistry registry) {
            // /**表示对所有的路径开放全局跨域访问权限
            registry.addMapping("/**")
                    //开放哪些IP 、端口、域名的访问权限
                    .allowedOrigins(properties.getCorsOrigins())
                    //是否允许客户端发cookie信息
                    .allowCredentials(true)
                    //哪些HTTP方法允许跨域访问
                    .allowedMethods("GET", "POST")
                    //允许HTTP请求中的携带哪些Header信息
                    .allowedHeaders("*");
                    //暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）
                    //.exposedHeaders("*");
        }
    }
    ```
    
#### 运行项目
1. FE用VSCode插件本地启动服务运行,假设：服务地址为http://localhost:63343
2. BE直接通过入口类运行
3. 进行测试



