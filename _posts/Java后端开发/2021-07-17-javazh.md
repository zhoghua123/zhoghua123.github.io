---
layout: post
title: Java常用企业框架-SpringMVC(四)
category: Java后端开发
tags: Java后端开发
description: Java后端开发
--- 

## 拦截器（Interceptor）
1. 拦截器（Interceptor））的功能，跟过滤器（Filter）有点类似，但是有本质区别的
2. 区别如下：
    1. 过滤器
        1. 是Servlet规范的一部分
        2. 能拦截任意请求，在请求抵达Servlet之前、响应抵达客户端之前拦截
        3. 常用于：编码设置、登录校验等
    2. 拦截器
        1. 是SpringMVC的一部分
        2. 只能拦截DispatcherServlet拦截到的内容，一般用来拦截Controller
        3. 常用于：抽取Controller的公共代码

### 拦截器使用步骤
1. 自定义一个类实现HandlerInterceptor接口
    
    ```
    public class MyInterceptor1 implements HandlerInterceptor {
        @Override
        public boolean preHandle(HttpServletRequest request,
                                 HttpServletResponse response,
                                 Object handler) throws Exception {
            System.out.println("MyInterceptor1 - preHandle - " + request.getRequestURI());
            return true;
        }
    
        @Override
        public void postHandle(HttpServletRequest request,
                               HttpServletResponse response,
                               Object handler,
                               ModelAndView modelAndView) throws Exception {
            System.out.println("MyInterceptor1 - postHandle - " + request.getRequestURI());
            //针对某个控制器，做相应的请求头设置
            //if (控制器) {
                //response.setHeader();
            //}
              //拦截器可直接修改Controller之前指定的路径
            //比如Controller中处理test2时，响应的是test1.jsp，这里可以修改响应路径资源
            //modelAndView.setViewName("/test2.jsp");
        }
    
        /*
        客户端的响应的数据（下面三个方法）已经执行完了，才会执行这个方法
        response.sendRedirect();
        request.getRequestDispatcher().forward();
        response.getWriter().write();
        * */
        @Override
        public void afterCompletion(HttpServletRequest request,
                                    HttpServletResponse response,
                                    Object handler,
                                    Exception ex) throws Exception {
            System.out.println("MyInterceptor1 - afterCompletion - " + request.getRequestURI());
        }
    }
    ```
2. HandlerInterceptor方法分析
    1. preHandle：在controller的处理方法之前调用
        1. 一般在这里进行初始化、请求预处理操作
        2. 如果返回false，那么后序将不会再调用controller的处理方法、postHandle、afterCompletion方法
        3. 当有多个拦截器时，这个方法按照正序执行
    2. postHandle：在controller的处理方法之后、在DispatcherServlet进行视图渲染之前调用
        1. 一般在这里进行请求后续加工处理操作
        2. 当有多个拦截器时，这个方法按照逆序执行
    3. afterCompletion：在DispatcherServlet进行视图渲染之后调用
        1. 一般在这里进行资源回收操作
        2. 当有多个拦截器时，这个方法按照逆序执行
3. 容器配置(applicationContext.xml中)
    
    ```
    <!-- 设置拦截器 -->
    <mvc:interceptors>
        <mvc:interceptor>
            <!-- 可以拦截DispatcherServlet接收到的所有路径 -->
            <!-- 需要拦截的路径可以写多个） -->
            <!-- **代表当前目录下的所有内容（包括子目录） -->
            <mvc:mapping path="/**"/>
            <!-- 排除asset目录的所有内容 -->
            <mvc:exclude-mapping path="/asset/**"/>
            <!-- 排除所有的html-->
            <mvc:exclude-mapping path="/**/*.html"/>
            <!--            <mvc:exclude-mapping path="/**/*.png"/>-->
            <!--            <mvc:exclude-mapping path="/**/*.js"/>-->
            <!-- 拦截器对象-->
            <bean class="com.zh.interceptor.MyInterceptor1"/>
        </mvc:interceptor>
    </mvc:interceptors>
    ```
4. TestController
    
    ```
    @RequestMapping("/test1")
    @ResponseBody
    public String test1() {
        System.out.println("test1------------------");
        return "test1 success!";
    }

    @RequestMapping("/test2")
    public String test2() {
        System.out.println("test2------------------");
        return "/test1.jsp";
    }
    ```

