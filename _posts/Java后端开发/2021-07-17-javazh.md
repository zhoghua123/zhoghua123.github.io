---
layout: post
title: Java常用企业框架-SpringMVC(四)
category: Java后端开发
tags: Java后端开发
description: Java后端开发
--- 

## 拦截器（Interceptor）
1. 拦截器（Interceptor））的功能，跟过滤器（Filter）有点类似，但是有本质区别的
2. 区别如下：
    1. 过滤器
        1. 是Servlet规范的一部分
        2. 能拦截任意请求，在请求抵达Servlet之前、响应抵达客户端之前拦截
        3. 常用于：编码设置、登录校验等
    2. 拦截器
        1. 是SpringMVC的一部分
        2. 只能拦截DispatcherServlet拦截到的内容，一般用来拦截Controller
        3. 常用于：抽取Controller的公共代码

### 拦截器使用步骤
1. 自定义一个类实现HandlerInterceptor接口
    
    ```
    public class MyInterceptor1 implements HandlerInterceptor {
        @Override
        public boolean preHandle(HttpServletRequest request,
                                 HttpServletResponse response,
                                 Object handler) throws Exception {
            System.out.println("MyInterceptor1 - preHandle - " + request.getRequestURI());
            return true;
        }
    
        @Override
        public void postHandle(HttpServletRequest request,
                               HttpServletResponse response,
                               Object handler,
                               ModelAndView modelAndView) throws Exception {
            System.out.println("MyInterceptor1 - postHandle - " + request.getRequestURI());
            //针对某个控制器，做相应的请求头设置
            //if (控制器) {
                //response.setHeader();
            //}
              //拦截器可直接修改Controller之前指定的路径
            //比如Controller中处理test2时，响应的是test1.jsp，这里可以修改响应路径资源
            //modelAndView.setViewName("/test2.jsp");
        }
    
        /*
        客户端的响应的数据（下面三个方法）已经执行完了，才会执行这个方法
        response.sendRedirect();
        request.getRequestDispatcher().forward();
        response.getWriter().write();
        * */
        @Override
        public void afterCompletion(HttpServletRequest request,
                                    HttpServletResponse response,
                                    Object handler,
                                    Exception ex) throws Exception {
            System.out.println("MyInterceptor1 - afterCompletion - " + request.getRequestURI());
        }
    }
    ```
2. HandlerInterceptor方法分析
    1. preHandle：在controller的处理方法之前调用
        1. 一般在这里进行初始化、请求预处理操作
        2. 如果返回false，那么后序将不会再调用controller的处理方法、postHandle、afterCompletion方法
        3. 当有多个拦截器时，这个方法按照**正序**执行
    2. postHandle：在controller的处理方法之后、在DispatcherServlet进行视图渲染之前调用
        1. 一般在这里进行请求后续加工处理操作
        2. 当有多个拦截器时，这个方法按照**逆序**执行
    3. afterCompletion：在DispatcherServlet进行视图渲染之后调用
        1. 一般在这里进行资源回收操作
        2. 当有多个拦截器时，这个方法按照**逆序**执行
3. 容器配置(applicationContext.xml中)
    
    ```
    <!-- 设置拦截器 -->
    <mvc:interceptors>
        <mvc:interceptor>
            <!-- 可以拦截DispatcherServlet接收到的所有路径 -->
            <!-- 需要拦截的路径可以写多个） -->
            <!-- **代表当前目录下的所有内容（包括子目录） -->
            <mvc:mapping path="/**"/>
            <!-- 排除asset目录的所有内容 -->
            <mvc:exclude-mapping path="/asset/**"/>
            <!-- 排除所有的html-->
            <mvc:exclude-mapping path="/**/*.html"/>
            <!--            <mvc:exclude-mapping path="/**/*.png"/>-->
            <!--            <mvc:exclude-mapping path="/**/*.js"/>-->
            <!-- 拦截器对象-->
            <bean class="com.zh.interceptor.MyInterceptor1"/>
        </mvc:interceptor>
    </mvc:interceptors>
    ```
4. TestController
    
    ```
    @RequestMapping("/test1")
    @ResponseBody
    public String test1() {
        System.out.println("test1------------------");
        return "test1 success!";
    }

    @RequestMapping("/test2")
    public String test2() {
        System.out.println("test2------------------");
        return "/test1.jsp";
    }
    ```
    
#### 多个拦截器调用顺序
1. 当配置多个拦截器时
    
    ```
    <!-- 设置拦截器 -->
    <mvc:interceptors>
        <mvc:interceptor>
            <!-- 可以拦截DispatcherServlet接收到的所有路径 -->
            <!-- 需要拦截的路径可以写多个） -->
            <!-- **代表当前目录下的所有内容（包括子目录） -->
            <mvc:mapping path="/**"/>
            <!-- 排除asset目录的所有内容 -->
            <mvc:exclude-mapping path="/asset/**"/>
            <!-- 拦截器对象-->
            <bean class="com.zh.interceptor.MyInterceptor1"/>
        </mvc:interceptor>

        <mvc:interceptor>
            <mvc:mapping path="/**"/>
            <mvc:exclude-mapping path="/asset/**"/>
            <bean class="com.zh.interceptor.MyInterceptor2"/>
        </mvc:interceptor>

        <mvc:interceptor>
            <mvc:mapping path="/**"/>
            <mvc:exclude-mapping path="/asset/**"/>
            <bean class="com.zh.interceptor.MyInterceptor3"/>
        </mvc:interceptor>
    </mvc:interceptors>
    ```
2. 调用吮吸日志如下：
    
    ```
    MyInterceptor1 - preHandle - /mvc05/test1
    MyInterceptor2 - preHandle - /mvc05/test1
    MyInterceptor3 - preHandle - /mvc05/test1
    test1------------------
    MyInterceptor3 - postHandle - /mvc05/test1
    MyInterceptor2 - postHandle - /mvc05/test1
    MyInterceptor1 - postHandle - /mvc05/test1
    MyInterceptor3 - afterCompletion - /mvc05/test1
    MyInterceptor2 - afterCompletion - /mvc05/test1
    MyInterceptor1 - afterCompletion - /mvc05/test1
    ```
    
    1. 从源码中可以查看有的是正向遍历、有的是逆向遍历
3. **注意：**多个拦截器，如果其中任意一个preHandle返回值为false，其他拦截器都不会往下执行
    
## SpringMVC的执行流程
1. 浏览器输入一个地址，如何到达Controller的呢？
2. DispatcherServlet继承体系如下
    1. DispatcherServlet->FrameworkServlet->HttpServletBean->HttpServlet

### 源码跟踪
1. FrameworkServlet-service
    1. 客户端请求来到DispatcherServlet，首先会去调用service方法（之前讲到Servelt时讲过）
    2. DispatcherServlet没有service，会到父类FrameworkServlet查找service，找到则调用
2. HttpServlet-service
    1. 会发现FrameworkServlet的service方法内部会调用父类的service
    2. 到父类HttpServletBean查找service没发现，会到父类HttpServlet查找，找到调用
3. FrameworkServlet-doGet
    1. HttpServlet的service方法内部会跟求请求类型选择调用doGet还是Post
    2. 但是首先还是从DispatcherServlet查找，没找到，则到FrameworkServlet
    3. 调用FrameworkServlet中的doGet、doPost，方法内部调用的是processRequest方法
4. FrameworkServlet-processRequest
    1. DispatcherServlet没有processRequest方法，则到FrameworkServlet中查找调用
    2. processRequest内部调用doService
5. DispatcherServlet-doService
    1. DispatcherServlet有doService方法，则调用
6. DispatcherServlet-doDispatch
    1. doService方法本质调用了doDispatch
    2. doDispatch的核心作用就是分发控制器处理

#### doDispatch源码分析
1. checkMultipart：检查是否四ultipart格式的请求
2. getHandler：找到第一个不为空的Handler（HandlerExecutionChain类型）-作用是后期用来处理Controller跟拦截器
3. getHandlerAdapter：获取HandlerAdapter
4. applyPreHandle：HandlerExecutionChain遍历所有拦截器，调用所有拦截器的preHandle方法
5. handle：HandlerAdapter调用handle，内部执行的是Controller的处理方法
6. applyPostHandle： applyPreHandle：HandlerExecutionChain遍历所有的拦截器，调用所有拦截器的postHandle方法
7. processDispatchResult：处理异常、渲染视图（转发、重定向）
    1. 内部调用render方法，内部InternalResourceView调用render方法
8. triggerAfterCompletion:在catch出现异常时调用,内部HandlerExecutionChain调用triggerAfterCompletion，遍历所有的拦截器，调用afterCompletion方法
9. applyAfterConcurrentHandlingStarted：在finally处，HandlerExecutionChain调用applyAfterConcurrentHandlingStarted，本质任然是遍历所有的拦截器，调用所有拦截器的afterConcurrentHandlingStarted方法

![图1](https://gitee.com/zhonghua123/blogimgs/raw/master/img/javazh-29.png)

#### 简要步骤
1. mappedHandler=getHandler：获取Handler (用来处理controller、拦截器)
2. ha =getHandlerAdapter：获取Handler Adapter
3. mappedHandler.applyPreHandle：调用拦截器的preHandle方法
4. mv=ha.handle：调用controller的处理方法
    1. 如果返回的不是视图页面(比如是JSON数据) ，在这个步骤中就已经将数据写回给客户端
5. mappedHandler.applyPostHandle：调用拦截器的postHandle方法
6. processDispatchResult：处理异常、渲染视图(转发、重定向)
7. triggerAfterCompletion：调用拦截器的afterCompletion方法


