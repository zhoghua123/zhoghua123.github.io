---
layout: post
title: 项目实战九-登录功能二
category: Java后端开发
tags: Java后端开发
description: Java后端开发
--- 

## 鉴权功能
1. 上一节讲过
    1. ShiroCfg中向容器添加Realm（TokenRealm）对象用来鉴权
    2. ShiroFilterFactoryBean对象配置拦截url
    3. TokenFilter校验token
    4. TokenMatcher用来自定义匹配算法
2. 那么如何才能使用TokenRealm进行鉴权呢？
    1. TokenFilter校验token之后，触发鉴权方法
3. TokenFilter的onAccessDenied方法，在对token进行校验之后，添加如下代码
    
    ```
    // 鉴权（进入Realm）
    // 这里调用login，并不是“登录”的意思，是为了触发Realm(TokenRealm)的相应方法（AuthorizationInfo、AuthenticationInfo）去加载用户的角色、权限信息，以便鉴权
    SecurityUtils.getSubject().login(new Token(token));
    ```
4. 上面接收的Token类型必须是AuthenticationToken类型，因此自定义Token类
    
    ```
    @Data
    public class Token implements AuthenticationToken {
        private final String token;
    
        public Token(String token) {
            this.token = token;
        }
    
        @Override
        public Object getPrincipal() {
            return token;
        }
    
        @Override
        public Object getCredentials() {
            return token;
        }
    }
    ```
5. 只有先认证通过，才会加载授权信息

### 认证功能
1. TokenRealm代码如下
    
    ```
    @Slf4j
    public class TokenRealm extends AuthorizingRealm {
    
        //自己定义一个密码的比对算法类，传进来
        public TokenRealm (TokenMatcher matcher) {
            super(matcher);
        }
    
        /*
        执行流程1：
        先对token进行判断，返回true，才会调用doGetAuthorizationInfo、doGetAuthenticationInfo方法
        * */
        @Override
        public boolean supports(AuthenticationToken token) {
            log.debug("TokenRealm - supports - {}", token);
            //只有这个token类是自定义的Token类型，才会继续往下执行
            return token instanceof Token;
        }
    
        /*
        * 执行流程3：加载权限信息
        * */
        //获取权限信息
        @Override
        protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
            return null;
        }
    
        /*
        执行流程2：
        * 认证方法
        * AuthenticationToken token：TokenFilter中调用login传递过来的token
        *
        * */
        @Override
        protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
            String tk = ((Token) token).getToken();
            log.debug("TokenRealm - doGetAuthenticationInfo - {}", tk);
            //返回一个info，调用完该方法，会去调用Realm的matcher进行具体的密码校验，因此会到自定义的TokenMatcher类去执行方法，将token跟inro传递给TokenMatcher
            return new SimpleAuthenticationInfo(tk, tk, getName());
        }
    }
    ```
2. doGetAuthenticationInfo方法执行完，会调用当前Realm()的matcher(TokenMatcher)对象的doCredentialsMatch方法进行实际的认证
    
    ```
    @Slf4j
    public class TokenMatcher implements CredentialsMatcher {
        /*自定义实现，客户端传递过来的值与数据库的值进行匹配的算法*/
        @Override
        public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) {
            log.debug("TokenMatcher - doCredentialsMatch - {} {}", token, info);
            //这里就是个摆设，目的就是直接告诉密码没有问题，这样才会进入下一个环节，加载权限信息
            return true;
        }
    }
    ```
    
    1. 该类中并没有去做实际的认证功能，直接放行，这一切都是为了到**授权流程doGetAuthorizationInfo**
    2. 因为真正的认证：密码验证在登录的impl中已经校验

### 授权功能
1. 前面**一切的目的**都是为了到达这个doGetAuthorizationInfo方法，拿到用户传递过来的token
    1. TokenFilter校验token，拿到token调用login方法传递，该方法会触发TokenRealm的认证方法doGetAuthenticationInfo
    2. doGetAuthenticationInfo将token包装成AuthenticationInfo，然后直接通过TokenMatcher用户名密码认证放行，将AuthenticationInfo的principals传递给了doGetAuthorizationInfo
    3. 最终token传递到获取权限信息方法doGetAuthorizationInfo
    
2. doGetAuthorizationInfo测试代码
    
    ```
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
        // 拿到当前登录用户的token
        String token = (String) principals.getPrimaryPrincipal();
        log.debug("TokenRealm - doGetAuthorizationInfo - {}", token);
        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();
        //进来的所有token都有这个权限
        info.addStringPermission("sysUser:list");
        return info;
    }
    ```
    
    1. 上面代表，所有的用户都有`sysUser:list`这个权限
3. 在SysUserController的list方法，添加权限限制注解
    
    ```
    //分页查询方法
    @GetMapping
    //只有用户有sysUser:list权限，才会继续进入该接口
    @RequiresPermissions("sysUser:list")
    public PageJsonVo<SysUserVo> list(SysUserPageReqVo reqVo) {
        return JsonVos.ok(service.list(reqVo));
    }
    ```
4. 在SysRoleController的list方法，添加权限限制注解
    
    ```
    //分页查询方法
    @GetMapping
    //只有用户有sysRole:list权限，才会继续进入该接口
    @RequiresPermissions("sysRole:list")
    public PageJsonVo<SysRoleVo> list(SysRolePageReqVo reqVo) {
        return JsonVos.ok(service.list(reqVo));
    }
    ```
5. 此时运行后台项目、前端项目，在前端登录页面验证码显示错误，报错404，原因是如果添加了`@RequiresPermissions`注解，就会出现这样bug
    1. 解决办法，在ShiroCfg中添加
    
    ```
    /**
     * 解决：@RequiresPermissions导致控制器接口404
     */
    @Bean
    public DefaultAdvisorAutoProxyCreator proxyCreator() {
        DefaultAdvisorAutoProxyCreator proxyCreator = new DefaultAdvisorAutoProxyCreator();
        proxyCreator.setUsePrefix(true);
        return proxyCreator;
    }
    ```
6. 再次运行项目，在前端页面登录成功后
    1. 点击系统-》用户，正常显示，说明有权限
    2. 点击 系统-》角色，弹框提示：没有相关权限，说明该用户没有该菜单权限



## 退出登录
1. 为什么token通常存放请求头？因为token不是业务参数，跟业务无关
2. SysUserController控制器添加logout方法
    
    ```
    @PostMapping("logout")
    //RequestHeader，请求头必须传递一个token，否则就会报错
    public JsonVo logout(@RequestHeader("Token") String token){
        //清除token
        Caches.removeToken(token);
        return JsonVos.ok();
    }
    ```


