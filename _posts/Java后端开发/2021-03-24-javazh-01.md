---
layout: post
title: Java语言基础(SE)-第十节 IO
category: Java后端开发
tags: Java后端开发
description: Java后端开发
---  

### 简介
1. I/O 流
    1. I/O 流 全称是 Input/Output Stream，译为“输入/输出流”
    2. 输出流：应用程序将数据写入到文件、设备等
    3. 输入流：将文件、设备等数据读入到应用程序中
2. 常用类型
    1. I/O 流的常用类型都在 java.io 包中
    
        ```
        类型                               输入流                输出流
        字节流（Byte Streams）           InputStream         OutputStream
        字符流（Character Streams）         Reader              Writer
        缓冲流（Buffered Streams）   BufferedInputStream     BufferedOutputStream
                                      BufferedReader         BufferedWriter
        数据流（Data Streams）          DataInputStream       DataOutputStream
        对象流（Object Streams）        ObjectInputStream     ObjectOutputStream
        ```
    2. 不管什么类型的流都有输入流和输出流
    

### File
1. 一个 File 对象就代表一个文件或目录（文件夹）
    
    ```
    //file1、file2都能访问test.txt文件
    File file1 = new File("F:\\Files\\Texts\\test.txt");
    File file2 = new File("F:/Files/Texts/test.txt"); 
    ```
2. 名字分隔符（name separator）：
    1. 在 UNIX、Linux、Mac 系统中：正斜杠（/）
    2. 在 Windows 系统中：反斜杠（\）
    3. 用File.separator方法可以查看当前系统支持哪种斜杠
3. 路径分隔符（path separator）：当有多个路径的时候
    1. 在 UNIX、Linux、Mac系统中：冒号（:）
    2. 在 Windows 系统中：分号（;）
    3. 用File.pathSeparator方法可以查看当前系统支持哪种分隔符
4. 在 Windows、Mac 系统中
    1. 文件名、目录名不区分大小写
5. 在 UNIX、Linux 系统中
    1. 文件名、目录名区分大小写
    
#### 常用方法
1. 常用方法如下

    ```
    String getName() //获取文件或目录的名称
    String getParent() //获取父路径
    File getParentFile() //获取父文件
    String getPath() //获取路径（相对路径）
    String getAbsolutePath() //获取绝对路径
    File getAbsoluteFile() //获取绝对路径形式的文件
    long lastModified() //最后一次修改的时间
    long length() // 文件的大小(不支持目录)
    boolean isAbsolute() //是否绝对路径
    boolean exists() //是否存在
    boolean isDirectory()
    boolean isFile()
    boolean isHidden()
    boolean canRead()
    boolean canWrite()
    String[] list() //获取当前目录下所有文件、目录的名称
    String[] list(FilenameFilter filter)
    File[] listFiles() // 获取当前目录下所有文件、目录
    File[] listFiles(FilenameFilter filter)
    File[] listFiles(File filter)
    boolean createNewFile() //创建文件(不会覆盖旧文件)
    boolean delete()//删除文件或空目录(不经过回收站，彻底删除)
    boolean mkdir() // 创建当前目录
    boolean mkdirs() //创建当前目录(包括不存在的父目录,如果没有就创建)
    boolean rename To(Filed est)//剪切到新路径
    boolean setLastModified(long time) //设置修改时间
    boolean setReadOnly() //设置可读写
    boolean setWritable(boolean writable，boolean owner Only)
    boolean setWritable(boolean writable)
    boolean setReadable(boolean readable，boolean owner Only)
    boolean setReadable(boolean readable)
    ```
2. 举例：
    
    ```
    package com.zh;
    import java.io.File;
    import java.util.function.Consumer;
    
    public class Files {
        //搜索文件夹目录
        public static void search(File dir,Consumer<File> operation) {
            if (dir == null || operation == null) return;
            //文件夹是否存在，如果是文件也不行，文件就不需要遍历
            if (!dir.exists() || dir.isFile()) return;
            File[] subfiles = dir.listFiles();
            for (File file : subfiles) {
                operation.accept(file);
                if (file.isFile()) continue;
                search(file, operation);
            }
        }
        	
        //删除
        public static void delete(File file) {
            if (file == null || !file.exists())return;
            clean(file);
            file.delete();
        }
        public static void clean(File dir) {
            if (dir == null || !dir.exists() || dir.isFile())return;
            File[] subfiles = dir.listFiles();
            //遍历删除文件夹的所有内容
            for (File sf : subfiles) {
                delete(sf);
            }
        }
        	
        //剪切
        public static void move(File src,File dest) {
            if (src == null ||dest == null)return;
            //不覆盖
            if (!src.exists() ||!dest.exists())return;
            mkparents(dest);
            src.renameTo(dest);
        }
        //没有文件路径，自动创建文件路径
        private static void mkparents(File file) {
            //获取父文件路径
            File parent = file.getParentFile();
            if (parent == null) return;
            parent.mkdirs();
        }
    }
    //打印出F:\\Files\\Texts目录下的所有文件、文件夹
    Files.search(new File("F:\\Files\\Texts"), (file)->{
        System.out.println(file);
    });
    ```

### 字符编码（Character Encoding）

#### 字符集（Character Set）
1. 在计算机里面一个中文汉字、英文字母、阿拉伯数字、标点符号都是一个字符
2. 字符集（简称 Charset）：由字符组成的集合
3. 常见的字符集有
    1. ASCII：128个字符（包括了英文字母大小写、阿拉伯数字等）
    2. ISO-8859-1：支持欧洲的部分语言文字，在有些环境也叫 Latin-1
    3. GB2312：支持中文（包括了 6763 个汉字）
    4. BIG5：支持繁体中文（包括了 13053 个汉字）
    5. GBK：是对 GB2312、BIG5 的扩充（包括了 21003 个汉字），支持中日韩
    6. GB18030：是对 GBK 的扩充（包括了 27484 个汉字）
    7. Unicode：包括了世界上所有的字符
4. ISO-8859-1、GB2312、BIG5、GBK、GB18030、Unicode 中都已经包括了 ASCII 中的所有字符

#### 字符编码（Character Encoding）
1. 每个字符集都有对应的字符编码，它决定了**每个字符如何转成二进制存储在计算机中**
2. ASCII：单字节编码，编码范围是 0x00 ~ 0x7F （0 ~ 127）
3. ISO-8859-1：单字节编码，编码范围是 0x00 ~ 0xFF
    1. 0x00 ~ 0x7F 和 ASCII 一致，0x80 ~ 0x9F 是控制字符，0xA0 ~ 0xFF 是文字符号
4. GB2312、BIG5、GBK：采用双字节表示一个汉字
5. GB18030：采用单字节、双字节、四字节表示一个字符
6. Unicode：有 Unicode、UTF-8、UTF-16、UTF-32 等编码，最常用的是 UTF-8 编码
    1. UTF-8 采用单字节、双字节、三字节、四字节表示一个字符
8. 总结：同样一个字符串，不同的编码方式，转化成的二进制不一样

#### 字符编码比较
1. 举例
    
    ```
    String str = "zh华仔";
    str.getBytes("ASCII");//[122, 104, 63, 63]
    str.getBytes("ISO-8859-1");//[122, 104, 63, 63]
    str.getBytes("UTF-8");//[122, 104, -27, -115, -114, -28, -69, -108]
    System.out.println(Arrays.toString(str.getBytes("ASCII")));
    System.out.println(Arrays.toString(str.getBytes("ISO-8859-1")));
    System.out.println(Arrays.toString(str.getBytes("UTF-8")));
    ```
2. 如果 String.getBytes 方法没有传参，就使用 JVM 的默认字符编码，一般跟随 main 方法所在文件的字符编码
3. 可以通过 Charset.defaultCharset 方法获取 JVM 的默认字符编码
    1. Charset 类的全名是 java.nio.charset.Charset

#### 乱码
1. 一般将【字符串】转为【二进制】的过程称为：**编码**（Encode）
2. 一般将【二进制】转为【字符串】的过程称为：**解码**（Decode）
3. 编码、解码时使用的字符编码必须要保持一致，否则会造成乱码
    
    ```
    String str1 = "Java不难";
    //编码
    byte[]bytes = str1.getBytes("UTF-8");
    //解码
    String str2 = new String(bytes,"GB18030");
    //乱码： Java涓嶉毦
    System.out.println(str2);
    ```
    
### 字节流（Byte Streams）
1. 字节流的特点
    1. 一次只读写一个字节
    2. 最终都继承自 InputSteam、OutputStream
2. 常用的是字节流有 FileInputStream、FileOutputStream

#### FileOutStream
1. 输出数据到文件
    
    ```
    //将“zh华仔”写入到桌面的text.txt文件夹中
    OutputStream os = new FileOutputStream("/Users/mac/Desktop/text.txt");
    //true表示追加内容，不覆盖原来的内容
    //OutputStream os2 = new FileOutputStream("/Users/mac/Desktop/text.txt",true);
    os.write(122);//z
    os.write(104);//h
    os.write("华仔".getBytes());
    //按指定编码写入
    //os.write("华仔".getBytes("UTF-8"));
    os.close();
    ```

#### FileInputStream
1. 读取文件数据
    
    ```
    InputStream is = new FileInputStream("/Users/mac/Desktop/text.txt");
    //读取第一个字节
    int byte1 = is.read();
    //读取第2个字节
    int byte2 = is.read();
    byte[] bytes = new byte[1024];
    //read返回实际读取的字节数
    int len = is.read(bytes);
    is.close();
    //122-104-6,6代表6个字节
    System.out.println(byte1 + "-" + byte2 + "-" + len);
    ```
    

#### 练习
1. 将内存中的数据写入文件
    
    ```
    //将内存中的数据写入文件
    public static void write(byte[] data, File file) {
        if (data == null || file == null || file.exists()) return;
        //没有文件路径，自动创建文件路径
        mkparents(file);
        try(OutputStream os = new FileOutputStream(file)) {
            os.write(data);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    ```
2. 从文件读取数据到内存
    
    ```
    //从文件读取数据到内存
    public static byte[] read(File file) {
        if (file == null || !file.exists()) return null;
        if (file.isDirectory()) return null;
        try(InputStream is = new FileInputStream(file)) {
            byte[] data = new byte[(int)file.length()];
            is.read(data);
            return data;
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }
    //使用
    byte[] data =  Files.read(new File("/Users/mac/Desktop/text.txt"));
    //zh华仔
    System.out.println(new String(data));
    ```
3. 复制
    
    ```
    //复制
    public static void copy(File src,File dest) {
        if(src == null || dest == null) return;
        if (!src.exists() ||!dest.exists())return;
        if(src.isDirectory()) return;
        mkparents(dest);
        InputStream is = null;
        OutputStream os = null;
        try {
            is = new FileInputStream(src);
            os = new FileOutputStream(dest);
            byte[] data = new byte[8192];//8kb
            int len;
            //每次读取data这么长的数据，一直读取
            while ((len = is.read(data)) !=-1) {
                //data读取到的数据，从0开始，写len这么长
                os.write(data,0,len);
            }
        } catch (FileNotFoundException e) {
        }catch (IOException e) {
        }finally {
            if(is != null) {
                try {
                    is.close();
                }catch (IOException e) {}
            }
        if(os != null) {
            try {
                os.close();
            }catch (IOException e) {}
            }
        }
    }
    //使用
    Files.copy(new File("/Users/mac/Desktop/text.txt"), new File("/Users/mac/Desktop/text2.txt"));
    ```
    
### try-with-resources 语句
1. 下面就是从 Java 7 开始推出的`try-with-resources`语句（可以没有catch、finally)
    
    ```
    try(资源1;资源2;...){
    }catch(Exception e){
    }finally {
    }
    ```
    
    1. 最后一个资源可以不写分号(;)
2. 可以在try后面的小括号中声明一个或多个资源（resource）
    1. 实现了 java.lang.AutoCloseable 接口的实例，都可以称之为是资源
    2. 所有的IO流都实现了java.lang.AutoCloseable接口
    3. 也就是说**try-with-resource使用是有条件的**
3. 不管try中的语句是正常还是意外结束
    1. 最终都会自动按顺序调用每一个资源的**close**方法（close 方法的调用顺序与资源的声明顺序**相反**）
    2. 调用完所有资源的 close 方法后，再执行finally中的语句
4. 简化copy方法
    
    ```
    public static void copy(File src,File dest) {
        if(src == null || dest == null) return;
        if (!src.exists() ||!dest.exists())return;
        if(src.isDirectory()) return;
        mkparents(dest);
        	
        try(
            InputStream is = new FileInputStream(src);
            OutputStream os = new FileOutputStream(dest);
        ) {
            byte[] data = new byte[8192];//8kb
            int len;
            //每次读取data这么长的数据，一直读取
            while ((len = is.read(data)) !=-1) {
                //data读取到的数据，从0开始，写len这么长
                os.write(data,0,len);
            }
        } catch (FileNotFoundException e) {
        }catch (IOException e) {
        }
    }
    ```


