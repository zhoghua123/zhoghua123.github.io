---
layout: post
title: JavaEE开发-第六节 个人简历管理系统项目开发(三)
category: Java后端开发
tags: Java后端开发
description: Java后端开发
--- 

## 反射

### 自动生成表名
1. 在BaseDaoImpl类中有个虚函数table方法让子类去实现，然后拿到子类要访问的表名
    
    ```
    private String table = table();
    //要求子类实现，告知表名
    protected abstract String table();
    ```
2. 在子类中需要实现这个table虚函数
    
    ```
    @Override
    protected String table() {
        return "award";
    }
    ```
3. 这样n个类都需要去实现这个方法，从代码从可以发现，这个表名其实就是子类继承父类BaseDaoImpl遵守的泛型的实际类
    
    ```
    public class AwardDaoImpl extends BaseDaoImpl<Award> implements AwardDao {
    }
    //AwardDaoImpl需要查询的表名就是award
    //一般情况，如果AwardDaoImpl遵守的泛型实际类为（MyName）那么对应的表名为my_name
    ```
4. 因此根据3中的分析，可以在BaseDaoImpl类中用**反射**的API封装一个自动获取表名的方法
    
    ```
    protected String table() {
        //反射
        //拿到父类的泛型
        ParameterizedType type = (ParameterizedType) getClass().getGenericSuperclass();
        //获取泛型中的参数
        Class beanCls = (Class) type.getActualTypeArguments()[0];
        //获取表名字符串
        return Strings.underlineCase(beanCls.getSimpleName());
    }
    ```
5. Strings是自动封装的一个工具类在util文件夹下：
    
    ```
    package com.zh.xr.util;
    public class Strings {
        /**
         * @param str 传值可能是小驼峰（myAge）、大驼峰（MyAge）
         * @return 则返回表名为my_age
         */
        public static String underlineCase(String str) {
            if (str == null) return null;
            int len = str.length();
            if (len == 0) return str;
    
            StringBuilder sb = new StringBuilder();
            sb.append(Character.toLowerCase(str.charAt(0)));
            for (int i = 1; i < len; i++) {
                char c = str.charAt(i);
    
                if (Character.isUpperCase(c)) {
                    sb.append("_");
                    sb.append(Character.toLowerCase(c));
                } else {
                    sb.append(c);
                }
            }
            return sb.toString();
        }
    }
    ```
6. 这样一来，如果子类没有实现父类BaseDaoImpl的table方法那就默认使用父类的获取方式，如果子类自己实现了，就用子类自己的表名

### 自动生成service
1. 正常情况下是，service内部创建Dao，dao获取数据返回，service封装成servlet直接使用的数据
2. 基类BaseServiceImpl内部提供了一个dao抽象方法，然后让其子类去实现这个方法，通过子类返回的具体Dao，才去真正调用dao的实际方法
    
    ```
    //父类BaseServiceImpl
    private BaseDao<T> dao = dao();
    protected abstract  BaseDao<T> dao();
    //子类EducationServiceImpl
    public class EducationServiceImpl extends BaseServiceImpl<Education> implements EducationService {
        @Override
        protected BaseDao<Education> dao() {
            return new EducationDaoImpl();
        }
    }
    ```
3. 从上面可以发现只需要将子类的Servce自促成换成Dao即可
    
    ```
    protected BaseDao<T> dao = newDao();
    protected BaseDao<T> newDao() {
        //子类
        // com.zh.xr.service.impl.EducationServiceImpl
        //通过反射替换后的子类Dao类型，即子类原本要通过dao函数实现返回的的Dao子类
        // com.zh.xr.dao.impl.EducationDaoImpl
        try {
            String clsName = getClass().getName()
                    .replace(".service.", ".dao.")
                    .replace("Service", "Dao");
            //创建子类实例对象
            return (BaseDao<T>) Class.forName(clsName).newInstance();
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
    ```
4. 同理子类可以选择实现父类的newDao方法

### 自动生成Servlet
1. 每个子类Servlet都需要创建一个与其对应的Service，这样才能获取对应的数据，比如：
    
    ```
    public class AwardServlet extends BaseServlet{
        private AwardService service = new AwardServiceImpl();
        ...
    }
    
    ```
2. 那么可不可以也自动创建，抽取到父类的BaseServlet方法中呢？
    1. 父类要添加泛型
        
        ```
        public class BaseServlet<T> extends HttpServlet {}
        ```
    2. 子类集成要填充泛型的实际类型
        
        ```
        public class AwardServlet extends BaseServlet<Award>{}
        ```
    3. 那么该子类对应的service为：AwardServiceImpl
    4. 因此在BaseServlet封装自动创建service的方法为：
        
        ```
        protected BaseService<T> service = newService();
        protected BaseService<T> newService() {
            //替换前
            // com.zh.xr.servlet.WebsiteServlet
            //替换后
            // com.zh.xr.service.impl.WebsiteServiceImpl
            try {
                String clsName = getClass().getName()
                        .replace(".servlet.", ".service.impl.")
                        .replace("Servlet", "ServiceImpl");
                return (BaseService<T>) Class.forName(clsName).newInstance();
            } catch (Exception e) {
                e.printStackTrace();
                return null;
            }
        }
        ```

### 模板tpl
1. 可以看到如果新增一个业务模块“比如公司信息”
2. 需要一次创建bean、dao、service、servlet
3. 而且发现这些类里面的代码都很相似，重复操作
4. 那么可以通过将这些类抽取成tpl模板，放到test文件夹中
5. 然后通过编写代码，通过IO动态执行自动添加n个模块，就相当于脚本功能一样
6. 本节视频略，在（24项目实战07_反射_模板）中讲述

### 自动生成单元测试
1. 打开一个类，在代码中右击->Generate...->test->Testing library 选择JUnit4 ->Generate test methods for:下面勾选需要实现测试的方法->点击OK即可
2. 会自动在test文件夹的java目录下生成一个当前类的测试类

## 工作经验模块、项目经验模块
1. 工作经验中涉及复杂模型数据
2. 一个模型bean中有个个属性值的类型是另外一个bean类型
3. 比如Experience工作经验bean有个公司companybean
4. 此时需要考虑数据库联合查询、保存
5. 添加经验的jsp页面公司信息选择展示等特殊功能

## 登录
1. 由于登录页面可以直接输入网址访问，因此login.jsp不能放在WEB-INF文件夹中
2. 在webapp根目录下新建一个page文件夹，然后里面放入login.jsp，跟WEB-INF文件夹同级
3. 前端登录的密码使用MD5加密，则引入下面js框架
    
    ```
    <script src="${ctx}/asset/plugin/JavaScript-MD5/md5.min.js"></script>
    ```
4. 技巧：一个表单中有密码这个input，但是如何将加密后的值传递给服务器呢？ 点击提交submint拿到的是明文，密文是在js中处理的，将表单做如下处理：
    
    ```
    //1. 密码表单新增input隐藏，然后设置name属性为password
    <div class="form-line">
        <input type="hidden" name="password">
        <input id="originPassword" type="password" class="form-control" maxlength="20" placeholder="密码" required>
    </div>
    //js中处理加密后，赋值给name属性为password的表单input
    addValidatorRules('.form-validation', function () {
        //将属性值设置为md5加密后的值，设置给nama属性为password的input标签中，
        $('[name=password]').val(md5($('#originPassword').val()))
        return true
    })
    ```

### 验证码
1. 验证码（CAPTCHA）
    1. 是Completely Automated Public Turing test to tell Computers and Humans Apart的缩写
    2. 全自动区分计算机和人类的图灵测试
    3. 可以用于防止大规模注册、暴力破解密码、刷票、论坛灌水等
2. 传统的验证码：由扭曲倾斜的文字、干扰线组成
    1. 由服务器端生成验证码图片，返回给客户端展示
3. 在java中，可以使用[Kaptcha](https://mvnrepository.com/artifact/com.google.code/kaptcha/2.3.0)库生成验证码
    1. Kaptcha产自Google
4. Kaptcha库
    1. Kaptcha是一个可高度配置的验证码生成工具，产自Google
    2. 常用的配置有：字体、内容的范围、尺寸、边框、干扰线、样式等
    3. Pom.xml中导入如下框架
        
        ```
        <dependency>
            <groupId>com.github.penggle</groupId>
            <artifactId>kaptcha</artifactId>
            <version>2.3.2</version>
        </dependency>
        ```
5. BaseServlet中添加captcha方法
    
    ```
    public void captcha(HttpServletRequest request, HttpServletResponse response) throws Exception {
        // 创建Katpcha对象
        DefaultKaptcha dk = new DefaultKaptcha();

        // 验证码的配置,配置内容存放到kaptcha.properties资源文件中
        try (InputStream is = getClass().getClassLoader().getResourceAsStream("kaptcha.properties")) {
            Properties properties = new Properties();
            properties.load(is);

            Config config = new Config(properties);
            dk.setConfig(config);
        }

        // 生成验证码字符串
        String code = dk.createText();

        // 生成验证码图片
        BufferedImage image = dk.createImage(code);

        // 设置返回数据的格式
        response.setContentType("image/jpeg");

        // 将图片数据写回到客户端
        ImageIO.write(image, "jpg", response.getOutputStream());
    }
    ```
6. 在login.jsp文件中，验证码图片标签img的src属性中设置请求
    
    ```
    //相当于get请求
    <img id="captcha" src="${ctx}/user/captcha" alt="验证码">
    
    //js代码，点击图片刷新验证码
    $('#captcha').click(function () {
        //time作用是让每次发送的请求都不一样，否则浏览器会有默认缓存，只发送一次
        //hide、fadeIn动画功能：将图片先隐藏，然后在慢慢显示
        $(this).hide().attr('src', '${ctx}/user/captcha?time=' + new Date().getTime()).fadeIn()
    })
    ```
7. 疑问：点击登录发送的请求，服务器如何拿到当时输入的验证码？登录的请求如何拿到验证码服务器返回的图片数据？就是登录请求、跟验证码请求之间的数据是如何共享的？----Session


