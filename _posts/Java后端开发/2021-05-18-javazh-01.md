---
layout: post
title: JavaEE开发-第六节 个人简历管理系统项目开发(三)
category: Java后端开发
tags: Java后端开发
description: Java后端开发
--- 

## 反射

### 自动生成表名
1. 在BaseDaoImpl类中有个虚函数table方法让子类去实现，然后拿到子类要访问的表名
    
    ```
    private String table = table();
    //要求子类实现，告知表名
    protected abstract String table();
    ```
2. 在子类中需要实现这个table虚函数
    
    ```
    @Override
    protected String table() {
        return "award";
    }
    ```
3. 这样n个类都需要去实现这个方法，从代码从可以发现，这个表名其实就是子类继承父类BaseDaoImpl遵守的泛型的实际类
    
    ```
    public class AwardDaoImpl extends BaseDaoImpl<Award> implements AwardDao {
    }
    //AwardDaoImpl需要查询的表名就是award
    //一般情况，如果AwardDaoImpl遵守的泛型实际类为（MyName）那么对应的表名为my_name
    ```
4. 因此根据3中的分析，可以在BaseDaoImpl类中用**反射**的API封装一个自动获取表名的方法
    
    ```
    protected String table() {
        //反射
        //拿到父类的泛型
        ParameterizedType type = (ParameterizedType) getClass().getGenericSuperclass();
        //获取泛型中的参数
        Class beanCls = (Class) type.getActualTypeArguments()[0];
        //获取表名字符串
        return Strings.underlineCase(beanCls.getSimpleName());
    }
    ```
5. Strings是自动封装的一个工具类在util文件夹下：
    
    ```
    package com.zh.xr.util;
    public class Strings {
        /**
         * @param str 传值可能是小驼峰（myAge）、大驼峰（MyAge）
         * @return 则返回表名为my_age
         */
        public static String underlineCase(String str) {
            if (str == null) return null;
            int len = str.length();
            if (len == 0) return str;
    
            StringBuilder sb = new StringBuilder();
            sb.append(Character.toLowerCase(str.charAt(0)));
            for (int i = 1; i < len; i++) {
                char c = str.charAt(i);
    
                if (Character.isUpperCase(c)) {
                    sb.append("_");
                    sb.append(Character.toLowerCase(c));
                } else {
                    sb.append(c);
                }
            }
            return sb.toString();
        }
    }
    ```
6. 这样一来，如果子类没有实现父类BaseDaoImpl的table方法那就默认使用父类的获取方式，如果子类自己实现了，就用子类自己的表名

### 自动生成service
1. 正常情况下是，service内部创建Dao，dao获取数据返回，service封装成servlet直接使用的数据
2. 基类BaseServiceImpl内部提供了一个dao抽象方法，然后让其子类去实现这个方法，通过子类返回的具体Dao，才去真正调用dao的实际方法
    
    ```
    //父类BaseServiceImpl
    private BaseDao<T> dao = dao();
    protected abstract  BaseDao<T> dao();
    //子类EducationServiceImpl
    public class EducationServiceImpl extends BaseServiceImpl<Education> implements EducationService {
        @Override
        protected BaseDao<Education> dao() {
            return new EducationDaoImpl();
        }
    }
    ```
3. 从上面可以发现只需要将子类的Servce自促成换成Dao即可
    
    ```
    protected BaseDao<T> dao = newDao();
    protected BaseDao<T> newDao() {
        //子类
        // com.zh.xr.service.impl.EducationServiceImpl
        //通过反射替换后的子类Dao类型，即子类原本要通过dao函数实现返回的的Dao子类
        // com.zh.xr.dao.impl.EducationDaoImpl
        try {
            String clsName = getClass().getName()
                    .replace(".service.", ".dao.")
                    .replace("Service", "Dao");
            //创建子类实例对象
            return (BaseDao<T>) Class.forName(clsName).newInstance();
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
    ```
4. 同理子类可以选择实现父类的newDao方法

### 自动生成Servlet
1. 每个子类Servlet都需要创建一个与其对应的Service，这样才能获取对应的数据，比如：
    
    ```
    public class AwardServlet extends BaseServlet{
        private AwardService service = new AwardServiceImpl();
        ...
    }
    
    ```
2. 那么可不可以也自动创建，抽取到父类的BaseServlet方法中呢？
    1. 父类要添加泛型
        
        ```
        public class BaseServlet<T> extends HttpServlet {}
        ```
    2. 子类集成要填充泛型的实际类型
        
        ```
        public class AwardServlet extends BaseServlet<Award>{}
        ```
    3. 那么该子类对应的service为：AwardServiceImpl
    4. 因此在BaseServlet封装自动创建service的方法为：
        
        ```
        protected BaseService<T> service = newService();
        protected BaseService<T> newService() {
            //替换前
            // com.zh.xr.servlet.WebsiteServlet
            //替换后
            // com.zh.xr.service.impl.WebsiteServiceImpl
            try {
                String clsName = getClass().getName()
                        .replace(".servlet.", ".service.impl.")
                        .replace("Servlet", "ServiceImpl");
                return (BaseService<T>) Class.forName(clsName).newInstance();
            } catch (Exception e) {
                e.printStackTrace();
                return null;
            }
        }
        ```

### 模板tpl
1. 可以看到如果新增一个业务模块“比如公司信息”
2. 需要一次创建bean、dao、service、servlet
3. 而且发现这些类里面的代码都很相似，重复操作
4. 那么可以通过将这些类抽取成tpl模板，放到test文件夹中
5. 然后通过编写代码，通过IO动态执行自动添加n个模块，就相当于脚本功能一样
6. 本节视频略，在（24项目实战07_反射_模板）中讲述

### 自动生成单元测试
1. 打开一个类，在代码中右击->Generate...->test->Testing library 选择JUnit4 ->Generate test methods for:下面勾选需要实现测试的方法->点击OK即可
2. 会自动在test文件夹的java目录下生成一个当前类的测试类

## 工作经验模块、项目经验模块
1. 工作经验中涉及复杂模型数据
2. 一个模型bean中有个个属性值的类型是另外一个bean类型
3. 比如Experience工作经验bean有个公司companybean
4. 此时需要考虑数据库联合查询、保存
5. 添加经验的jsp页面公司信息选择展示等特殊功能

