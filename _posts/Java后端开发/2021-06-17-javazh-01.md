---
layout: post
title: Java常用企业框架-Spring(一)
category: Java后端开发
tags: Java后端开发
description: Java后端开发
--- 

### 简介
1. Spring框架可以算是Java开发中最常用的框架，功能非常强大
    1. 最早之前java的三大框架是SSH（Struts（网络层）、Spring、Hibernate（dao层））
    2. 现在流行的java三大框架SSM（SpringMVC、Spring、MyBatis）
    3. 官方网站：[https://spring.io/](https://spring.io/)
    4. [https://spring.io/projects/spring-framework](https://spring.io/projects/spring-framework)
    5. 官网标语：Spring makes Java simple、modern、productive...
2. Spring框架的几个核心概念
    1. IoC：In version of Control， 控制反转
    2. DI：Dependency Injection， 依赖注入
    3. AOP：Aspect Oriented Programming， 面向切面编程
3. 本课程使用的版本是5.2.8
    1. [核心参考文档](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html)
    2. [API文档](https://docs.spring.io/spring-framework/docs/current/javadoc-api/)

### Spring的下载
1. jar包、文档下载：[https://repo.spring.io/](https://repo.spring.io/)
    1. 点击左边菜单第二个图标进入：Artifact Repository Browser
    2. 列表中找到libs-release-local点击箭头展开列表
    3. 点击org展开，点击springframework展开
    4. 找到Spring找到5.2.8.RELEASE点击展开
    5. 找到spring-5.2.8.RELEASE-dist.zip，点击，然后点击右边的download即可,里面包含了离线文档
2. 源码下载：[https://github.com/spring-projects/spring-framework](https://github.com/spring-projects/spring-framework)

### Spring的引入
1. 基础的项目结构
    1. servlet层
        
        ```
        //模拟举例
        public class PersonServlet {
            //使用service层
            private  PersonService service = new PersonServiceImpl();
            //模拟网络请求调用：删除一条数据
            public void remove() {
                service.remove(1);
            }
            //模拟客户端调用网络接口
            public static void main(String[] args) {
                PersonServlet servlet = new PersonServlet();
                servlet.remove();
            }
        }
        ``` 
    2. service层
        
        ```
        //接口
        public interface PersonService {
            boolean remove(Integer id);
        }
        //impl
        public class PersonServiceImpl implements PersonService {
            //使用dao层
            private PersonDao dao = new PersonDaoImpl();
            @Override
            public boolean remove(Integer id) {
                return dao.remove(id);
            }
        }
        ``` 
    3. dao层
        
        ```
        //接口
        public interface PersonDao {
            boolean remove(Integer id);
        }
        //impl
        public class PersonDaoImpl implements PersonDao {
            @Override
            public boolean remove(Integer id) {
                System.out.println("PersonDaoImpl ------ remove: " + id);
                return false;
            }
        }
        ```
3. 存在问题
    1. 耦合严重：
        1. PersonServlet依赖于PersonServiceImpl，PersonServiceImpl依赖于PersonDaoImpl
        2. 一旦某个环境的类型改变，其他依赖必须也要改变
        3. 即servlet依赖于service层，service层依赖于dao层
    2. 如何解耦？ ---工厂设计模式
 
#### 工厂设计模式来解耦
1. 新增一个工厂类：`com.zh.factory.PersonFactory;`
    
    ```
    public class PersonFactory {
        public static PersonService getService (){
            return  new PersonServiceImpl();
            //return  new PersonServiceImpl2();
        }
        public static PersonDao getDao(){
            return new PersonDaoImpl();
        }
    }
    ```
2. 将servlet、service中的依赖分别替换如下
    
    ```
    //PersonServlet中替换
    private  PersonService service = PersonFactory.getService();
    //PersonServiceImpl中替换
    private PersonDao dao = PersonFactory.getDao();
    ```
3. 这样一来，如果修改service、dao的实现类，那么就只需要在工厂类PersonFactory中修改了
4. 那么是否也可以将PersonFactory解耦呢？就是修改service、dao实现不需要修改PersonFactory？---配置文件

#### 配置文件解耦
1. service、dao实现类的类名放到配置文件中去，PersonFactory只加载配置文件
    
    ```
    //resources文件中添加配置文件factory.properties
    personService=com.zh.service.impl.PersonServiceImpl
    personDao=com.zh.dao.impl.PersonDaoImpl
    ```
2. 改造PersonFactory类工厂代码如下：
    
    ```
    public class PersonFactory {
        private static Properties properties;
        static {
            try (InputStream is = PersonFactory.class.getClassLoader().getResourceAsStream("factory.properties")) {
                properties = new Properties();
                properties.load(is);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    
        public static <T> T get(String name) {
            try {
                // 类名
                String clsName = properties.getProperty(name);
                Class cls = Class.forName(clsName);
                // 实例化对象
                return (T) cls.newInstance();
            } catch (Exception e) {
                e.printStackTrace();;
            }
            return null;
        }
        public static PersonService getService() {
            return get("personService");
        }
    
        public static PersonDao getDao() {
            return get("personDao");
        }
    }
    ```
3. 这样，如果替换service、dao的实现类，只需要修改配置文件中的实现类字符串即可

#### 封装一个通用的工厂
1. 封装通用工厂GeneralFactory
    
    ```
    public class GeneralFactory {
        private static Properties properties;
        static {
            try (InputStream is = GeneralFactory.class.getClassLoader().getResourceAsStream("factory.properties")) {
                properties = new Properties();
                properties.load(is);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    
        public static <T> T get(String name) {
            try {
                // 类名
                String clsName = properties.getProperty(name);
                Class cls = Class.forName(clsName);
                // 实例化对象
                return (T) cls.newInstance();
            } catch (Exception e) {
                e.printStackTrace();;
            }
            return null;
        }
    }
    ```
2. servlet、dao中改造
    
    ```
    //PersonServlet
    private PersonService service = GeneralFactory.get("personService");
    //PersonServiceImpl
    private PersonDao dao = GeneralFactory.get("personDao");
    ```

#### Spring的作用
1. Spring就可以用来充当工厂的角色GeneralFactory
2. Spring已经内置了这样的工厂，不需要自己实现
3. 使用步骤详见下面：基本使用
 
### 基本使用-IoC容器
1. 添加Maven依赖项
    
    ```
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>5.2.9.RELEASE</version>
    </dependency>
    ```
2. 添加一个核心配置文件 applicationContext.xml
    1. 右击resources->new->XML Configuration File ->Spring Config->applicationContext.xml,点击确定
        
        ```
        <?xml version="1.0" encoding="UTF-8"?>
        <beans xmlns="http://www.springframework.org/schema/beans"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
        
            <!--这些bean就是Spring将要创建的对象-->
            <bean id="personDao" class="com.zh.dao.impl.PersonDaoImpl"/>
        
            <bean id="personService" class="com.zh.service.impl.PersonServiceImpl">
                <!--
                1. 会主动调用PersonServiceImpl对象的dao属性的set方法-setDao方法
                2. 调用set方法传的的参数值为：ref引用的类型的实例对象
                3. 因此要在PersonServiceImpl对象中实现dao属性的set方法
                -->
                <property name="dao" ref="personDao"/>
            </bean>
        
            <bean id="personServlet" class="com.zh.servlet.PersonServlet">
                <property name="service" ref="personService"/>
            </bean>
        </beans>
        ```
    2. 那么如何获取这个xml文件，并出创建bean标签对应的对象呢？
        
        ```
        // 读取配置文件
        ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
        //创建servlet对象
        PersonServlet servlet = ctx.getBean("personServlet", PersonServlet.class);
        servlet.remove();
        ```
3. 根据核心配置文件在PersonServlet、PersonServiceImpl中添加set方法
    
    1. PersonServlet
    
        ```
        public class PersonServlet {
            private PersonService service;
            public void setService(PersonService service) {
                this.service = service;
            }
            //模拟网络请求调用：删除一条数据
            public void remove() {
                service.remove(1);
            }
        
            public static void main(String[] args) {
                // 读取配置文件
                ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
                PersonServlet servlet = ctx.getBean("personServlet", PersonServlet.class);
                servlet.remove();
            }
        }
        ```
    2. PersonServiceImpl
        
        ```
        public class PersonServiceImpl implements PersonService {
            private PersonDao dao;
            public void setDao(PersonDao dao) {
                this.dao = dao;
            }
            @Override
            public boolean remove(Integer id) {
                return dao.remove(id);
            }
        }
        ```


