---
layout: post
title: Java常用企业框架-Spring(一)
category: Java后端开发
tags: Java后端开发
description: Java后端开发
--- 

### 简介
1. Spring框架可以算是Java开发中最常用的框架，功能非常强大
    1. 最早之前java的三大框架是SSH（Struts（网络层）、Spring、Hibernate（dao层））
    2. 现在流行的java三大框架SSM（SpringMVC、Spring、MyBatis）
    3. 官方网站：[https://spring.io/](https://spring.io/)
    4. [https://spring.io/projects/spring-framework](https://spring.io/projects/spring-framework)
    5. 官网标语：Spring makes Java simple、modern、productive...
2. Spring框架的几个核心概念
    1. IoC：In version of Control， 控制反转
    2. DI：Dependency Injection， 依赖注入
    3. AOP：Aspect Oriented Programming， 面向切面编程
3. 本课程使用的版本是5.2.8
    1. [核心参考文档](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html)
    2. [API文档](https://docs.spring.io/spring-framework/docs/current/javadoc-api/)

### Spring的下载
1. jar包、文档下载：[https://repo.spring.io/](https://repo.spring.io/)
    1. 点击左边菜单第二个图标进入：Artifact Repository Browser
    2. 列表中找到libs-release-local点击箭头展开列表
    3. 点击org展开，点击springframework展开
    4. 找到Spring找到5.2.8.RELEASE点击展开
    5. 找到spring-5.2.8.RELEASE-dist.zip，点击，然后点击右边的download即可,里面包含了离线文档
2. 源码下载：[https://github.com/spring-projects/spring-framework](https://github.com/spring-projects/spring-framework)

### Spring的引入
1. 基础的项目结构
    1. servlet层
        
        ```
        //模拟举例
        public class PersonServlet {
            //使用service层
            private  PersonService service = new PersonServiceImpl();
            //模拟网络请求调用：删除一条数据
            public void remove() {
                service.remove(1);
            }
            //模拟客户端调用网络接口
            public static void main(String[] args) {
                PersonServlet servlet = new PersonServlet();
                servlet.remove();
            }
        }
        ``` 
    2. service层
        
        ```
        //接口
        public interface PersonService {
            boolean remove(Integer id);
        }
        //impl
        public class PersonServiceImpl implements PersonService {
            //使用dao层
            private PersonDao dao = new PersonDaoImpl();
            @Override
            public boolean remove(Integer id) {
                return dao.remove(id);
            }
        }
        ``` 
    3. dao层
        
        ```
        //接口
        public interface PersonDao {
            boolean remove(Integer id);
        }
        //impl
        public class PersonDaoImpl implements PersonDao {
            @Override
            public boolean remove(Integer id) {
                System.out.println("PersonDaoImpl ------ remove: " + id);
                return false;
            }
        }
        ```
3. 存在问题
    1. 耦合严重：
        1. PersonServlet依赖于PersonServiceImpl，PersonServiceImpl依赖于PersonDaoImpl
        2. 一旦某个环境的类型改变，其他依赖必须也要改变
        3. 即servlet依赖于service层，service层依赖于dao层
    2. 如何解耦？ ---工厂设计模式
 
#### 工厂设计模式来解耦
1. 新增一个工厂类：`com.zh.factory.PersonFactory;`
    
    ```
    public class PersonFactory {
        public static PersonService getService (){
            return  new PersonServiceImpl();
            //return  new PersonServiceImpl2();
        }
        public static PersonDao getDao(){
            return new PersonDaoImpl();
        }
    }
    ```
2. 将servlet、service中的依赖分别替换如下
    
    ```
    //PersonServlet中替换
    private  PersonService service = PersonFactory.getService();
    //PersonServiceImpl中替换
    private PersonDao dao = PersonFactory.getDao();
    ```
3. 这样一来，如果修改service、dao的实现类，那么就只需要在工厂类PersonFactory中修改了
4. 那么是否也可以将PersonFactory解耦呢？就是修改service、dao实现不需要修改PersonFactory？---配置文件

#### 配置文件解耦
1. service、dao实现类的类名放到配置文件中去，PersonFactory只加载配置文件
    
    ```
    //resources文件中添加配置文件factory.properties
    personService=com.zh.service.impl.PersonServiceImpl
    personDao=com.zh.dao.impl.PersonDaoImpl
    ```
2. 改造PersonFactory类工厂代码如下：
    
    ```
    public class PersonFactory {
        private static Properties properties;
        static {
            try (InputStream is = PersonFactory.class.getClassLoader().getResourceAsStream("factory.properties")) {
                properties = new Properties();
                properties.load(is);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    
        public static <T> T get(String name) {
            try {
                // 类名
                String clsName = properties.getProperty(name);
                Class cls = Class.forName(clsName);
                // 实例化对象
                return (T) cls.newInstance();
            } catch (Exception e) {
                e.printStackTrace();;
            }
            return null;
        }
        public static PersonService getService() {
            return get("personService");
        }
    
        public static PersonDao getDao() {
            return get("personDao");
        }
    }
    ```
3. 这样，如果替换service、dao的实现类，只需要修改配置文件中的实现类字符串即可

#### 封装一个通用的工厂
1. 封装通用工厂GeneralFactory
    
    ```
    public class GeneralFactory {
        private static Properties properties;
        static {
            try (InputStream is = GeneralFactory.class.getClassLoader().getResourceAsStream("factory.properties")) {
                properties = new Properties();
                properties.load(is);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    
        public static <T> T get(String name) {
            try {
                // 类名
                String clsName = properties.getProperty(name);
                Class cls = Class.forName(clsName);
                // 实例化对象
                return (T) cls.newInstance();
            } catch (Exception e) {
                e.printStackTrace();;
            }
            return null;
        }
    }
    ```
2. servlet、dao中改造
    
    ```
    //PersonServlet
    private PersonService service = GeneralFactory.get("personService");
    //PersonServiceImpl
    private PersonDao dao = GeneralFactory.get("personDao");
    ```

#### Spring的作用
1. Spring就可以用来充当工厂的角色GeneralFactory
2. Spring已经内置了这样的工厂，不需要自己实现
3. 使用步骤详见下面：基本使用
 
### 基本使用-IoC容器
1. 添加Maven依赖项
    
    ```
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>5.2.9.RELEASE</version>
    </dependency>
    ```
2. 添加一个核心配置文件 applicationContext.xml
    1. 右击resources->new->XML Configuration File ->Spring Config->applicationContext.xml,点击确定
        
        ```
        <?xml version="1.0" encoding="UTF-8"?>
        <beans xmlns="http://www.springframework.org/schema/beans"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
        
            <bean id="personDao" class="com.zh.dao.impl.PersonDaoImpl"/>
            <!--这些bean就是代表Spring将要创建的对象-->
            <bean id="personService" class="com.zh.service.impl.PersonServiceImpl">
                <!--
                property就是这个对象对应的属性，因此这个对象必须要有对应的这个属性，否则会报错
                1. 会主动调用PersonServiceImpl对象的dao属性的set方法-setDao方法
                2. 调用set方法传的的参数值为：ref引用的类型的实例对象，也要创建一个参数对象
                3. 因此要在PersonServiceImpl对象中实现dao属性的set方法
                -->
                <property name="dao" ref="personDao"/>
            </bean>
        
            <bean id="personServlet" class="com.zh.servlet.PersonServlet">
                <property name="service" ref="personService"/>
            </bean>
        </beans>
        ```
        
        1. bean标签对应对象、property对应对象的属性，ref要传入的参数类型
    2. 那么如何获取这个xml文件，并出创建bean标签对应的对象呢？
        
        ```
        // 读取配置文件
        ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
        //创建servlet对象
        PersonServlet servlet = ctx.getBean("personServlet", PersonServlet.class);
        servlet.remove();
        ```
3. 根据核心配置文件在PersonServlet添加私有的service属性、PersonServiceImpl中添加私有的dao属性，并分别实现其对应的set方法
    
    1. PersonServlet
    
        ```
        public class PersonServlet {
            private PersonService service;
            public void setService(PersonService service) {
                this.service = service;
            }
            //模拟网络请求调用：删除一条数据
            public void remove() {
                service.remove(1);
            }
        
            public static void main(String[] args) {
                // 读取配置文件
                ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
                //通过id获取bean对象，并强制转换传成PersonServlet类
                PersonServlet servlet = ctx.getBean("personServlet", PersonServlet.class);
                servlet.remove();
            }
        }
        ```
    2. PersonServiceImpl
        
        ```
        public class PersonServiceImpl implements PersonService {
            private PersonDao dao;
            public void setDao(PersonDao dao) {
                this.dao = dao;
            }
            @Override
            public boolean remove(Integer id) {
                return dao.remove(id);
            }
        }
        ```

#### 总结
1. IoC简称：Inversion of Control，控制反转
    1. 对象的创建控制权转交给了Spring
2. IoC容器指的是xml里面放了很多的bean，被创建完的对象都放在了一个容器中
3. IoC的一个很重要的作用：解耦
4. 它实现了将dao、service、servlet三层进行解耦


#### Spring集成日志框架
1. Spring可以轻松整合日志框架：logback
    
    ```
    <dependency>
        <groupId>ch.qos.logback</groupId>
        <artifactId>logback-classic</artifactId>
        <version>1.2.3</version>
    </dependency>
    ```
2. 通过导入logback，能通过日志看到`PersonServlet servlet = ctx.getBean("personServlet", PersonServlet.class);`具体做了什么
    
    ```
    21:41:12.407 [main] DEBUG org.springframework.context.support.ClassPathXmlApplicationContext - Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@4e9ba398
    21:41:13.292 [main] DEBUG org.springframework.beans.factory.xml.XmlBeanDefinitionReader - Loaded 3 bean definitions from class path resource [applicationContext.xml]
    21:41:13.439 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'personDao'
    21:41:13.523 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'personService'
    21:41:13.799 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'personServlet'
    ```


## 依赖注入（Dependency Injection）
1. 引入:
    1. 在上面讲解IoC的时候就讲解过依赖注入，比如：
    2. PersonServiceImpl这个类依赖于dao这个属性
    3. 通过applicationContext.xml这个`<property name="dao" ref="personDao"/>`属性标签，将ref这个类型的对象通过setter方法注入到了PersonServiceImpl对象中
    4. 注意：这里面的ref引用的对象正好能在applicationContext.xml文件中找到
2. 常见的注入内容可以分为3大类
    1. bean（自定义类型）
    2. 基本类型、String、BigDecimal
    3. 集合类型（数组、Map、List、Set、Properties）
3. 常见的注入方式有2种
    1. 基于setter（2属性）
    2. 基于Constructor（构造方法）
4. 项目初始化
    1. 新建一个项目，添加两个模型Dog、Persoon
        1. **注意：从Spring开始模型对象的文件就不能叫bean了，以后所说的bean都是spring那个xml文件中的bean标签，模型对象用domain文件存储**
        2. `com.zh.domain.Person`类如下文件
            
            ```
            public class Person {
                private int age;
                private String name;
                private BigDecimal money;
                private Dog dog;
                private Set<String> nickNames;
                private Properties friends;
            }
            ```
    2. 创建applicationContext.xml文件

### 基于setter的注入
1. 基本类型、String、BigDecimal的注入：
    1. 实现Person类所有属性的setter方法
    2. applicationContext.xml中如下
        
        ```
        <bean id="person" class="com.zh.domain.Person">
            <!--基本数据类型注入-->
            <property name="age" value="18"/>
            <property name="money" value="100.5"/>
            <property name="name" value="Jack"/>
        </bean>
        ```
2. bean自定义类型
    1. applicationContext.xml中如下
        
        ```
        <bean id="dog" class="com.zh.domain.Dog"/>
        <bean id="person" class="com.zh.domain.Person">
            <!--对象类型注入-->
            <!--方式1-->
            <!--<property name="dog" ref="dog"/>-->
            <!--方式2-->
            <property name="dog">
                <ref bean="dog"/>
            </property>
            <!--方式3:这种方式，这只dog跟外面的bean中的dog不一样-->
            <!--<property name="dog">-->
                <!--<bean class="com.zh.domain.Dog"/>-->
            <!--</property>-->
        </bean>
        ```
3. 集合类型
    
    ```
    <!--集合方式注入-->
    <property name="nos">
        <array>
            <value>11</value>
            <value>11</value>
        </array>
    </property>
    <property name="nos">
        <list>
            <value>11</value>
            <value>11</value>
        </list>
    </property>
    <!-- LinkeHashSet -->
    <property name="pones">
        <set>
            <value>Jack</value>
            <value>Rose</value>
            <value>James</value>
        </set>
    </property>
    <!-- LinkeHashSet -->
    <property name="friends">
        <map>
            <entry key ="Jack" value="广州“/>
            <entry key ="Rose" value=”背景“/>
            <entry key ="James" value="上海”/>
        </map>
    </property>
    
    <property name="friends">
        <props>
            <prop key="Jack">杰克</prop>
            <prop key="Rose">螺丝</prop>
        </props>
    </property>
    ```
    
### 基于Constructor的注入
1. 实现Person的构造方法
    
    ```
    public Person() {
        System.out.println("Person()");
    }

    public Person(int age) {
        this.age = age;
        System.out.println("Person(" + age + ")");
    }

    @ConstructorProperties({"age", "name"})
    public Person(int age, String name) {
        this.age = age;
        this.name = name;
        System.out.println("Person(" + age + ", " + name + ")");
    }
    ```
2. 基本类型、String、BigDecimal的注入：
    
    ```
    <bean id="person" class="com.zh.domain.Person">
        <!--方法1：-->
<!--        <constructor-arg type="int" value="22"/>-->
<!--        <constructor-arg type="java.lang.String" value="Jack"/>-->
        <!--方法2：-->
<!--        <constructor-arg index="0" value="22"/>-->
<!--        <constructor-arg index="1" value="Jack"/>-->
        <!--方法3：
        注意该方法使用：需要在构造方法前加上注解@ConstructorProperties({"age", "name"})
        -->
        <constructor-arg value="Jack666" name="name"/>
        <constructor-arg value="28" name="age"/>
    </bean>
    ```
3. bean自定义类型
    
    ```
    <bean id="dog" class="com.zh.domain.Dog"/>
    <!--    <bean id="person" class="com.zh.domain.Person">-->
    <!--        <constructor-arg ref="dog"/>-->
    <!--    <<!--    </bean>-->
    <bean id="person" class="com.zh.domain.Person">
        <constructor-arg>
            <ref bean="dog"/>
        </constructor-arg>
    </bean>
    <!-- <bean id="person" class="com.zh.domain.Person">-->
    <!--        <constructor-arg>-->
    <!--            <bean id="dog" class="com.zh.domain.Dog"/>-->
    <!--        </constructor-arg>-->
    <!--    </bean>-->
    ```
4. 集合类型
    
    ```
    <bean id="person" class="com.zh.domain.Person">
        <constructor-arg>
            <list>
                <value>Jack</value>
                <value>Rose</value>
            </list>
        </constructor-arg>
    </bean>
    ```


## 复杂对象
1. 


