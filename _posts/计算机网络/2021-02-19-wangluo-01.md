---
layout: post
title: 网络协议五：传输层
category: 计算机网络
tags: 计算机网络
description: 计算机网络
---

## 传输层（Transport）
1. 传输层有2个协议
    1. TCP（Transmission Control Protocol），传输控制协议
    2. UDP（User Datagram Protocol），用户数据报协议

![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/wlxy-33.png)

## UDP
### 数据格式
1. UDP是无连接的，减少了建立和释放连接的开销
2. UDP尽最大能力交付，不保证可靠交付
    1. 因此不需要维护一些复杂的参数，首部只有8个字节（TCP的首部至少20个字节）
3. UDP长度（Length）
    1. 占16位，首部的长度 + 数据的长度
![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/wlxy-34.png)

#### 检验和(Checksum)
1. 检验和的计算内容：伪首部 + 首部 + 数据
2. 伪首部：仅在计算检验和时起作用，并不会传递给网络层

![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/wlxy-35.png)

#### 端口（Port）
1. UDP首部中端口是占用2字节
    1. 可以推测出端口号的取值范围是：0~65535
2. 客户端的源端口是**临时**开启的**随机**端口
3. 防火墙可以设置开启\关闭某些端口来提高安全性
4. 常用命令行
    1. netstat –an：查看本机已经被占用的端口
    2. netstat –anb：查看本机已经被占用的端口、占用端口的应用程序
    3. telnet 主机 端口：查看是否可以访问主机的某个端口
        1. 安装telnet：控制面板 – 程序 – 启用或关闭Windows功能 – 勾选“Telnet Client” – 确定
        
![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/wlxy-36.png)

## TCP

### 数据格式

![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/wlxy-38.png)

1. 数据偏移
    1. 占4位，取值范围是0x0101~0x1111
    2. 乘以4：首部长度（Header Length）
    3. 首部长度是20~60字节
2. 保留
    1. 占6位，目前全为0
3. 细节问题
    1. UDP的首部中有个16位的字段记录了整个UDP报文段的长度（首部+数据）
    2. 但是，TCP的首部中仅仅有个4位的字段记录了TCP报文段的首部长度，并没有字段记录TCP报文段的数据长度
    3. 分析
        1. UDP首部中占16位的长度字段是冗余的，纯粹是为了保证首部是32bit对齐
        2. TCP\UDP的数据长度，完全可以由IP数据包的首部推测出来
            1. 传输层的数据长度 = 网络层的总长度 – 网络层的首部长度 – 传输层的首部长度

#### 检验和（Checksum）、标志位（Flags）
1. 检验和
    1. 跟UDP一样，TCP检验和的计算内容：伪首部 + 首部 + 数据
    2. 伪首部：占用12字节，仅在计算检验和时起作用，并不会传递给网络层
2. 标志位：
    1. URG（Urgent）
        1. 当URG=1时，紧急指针字段才有效。表明当前报文段中有紧急数据，应优先尽快传送
    2. ACK（Acknowledgment）
        1. 当ACK=1时，确认号字段才有效
    3. PSH（Push）
    4. RST（Reset）
        1. 当RST=1时，表明连接中出现严重差错，必须释放连接，然后再重新建立连接
    5. SYN（Synchronization）:**建立连接时使用**
        1. 当SYN=1、ACK=0时，表明这是一个建立连接的请求
        2. 若对方同意建立连接，则回复SYN=1、ACK=1
    6. FIN（Finish）:**释放连接时使用**
        1. 当FIN=1时，表明数据已经发送完毕，要求释放连接

#### 序号、确认号、窗口
1. 序号（Sequence Number）
    1. 占4字节
    2. 首先，在传输过程的每一个字节都会有一个编号
    3. 在建立连接后，序号代表：这一次传给对方的TCP数据部分的**第一个字节的编号**
2. 确认号（Acknowledgment Number）
    1. 占4字节
    2. 在建立连接后，确认号代表：**期望**对方下一次传过来的TCP数据部分的**第一个字节的编号**
3. 窗口（Window）
    1. 占2字节
    2. 这个字段有流量控制功能，用以告知对方下一次允许发送的数据大小（字节为单位）

#### TC的几个要点
1. 可靠传输
2. 流量控制
3. 拥塞控制
4. 连接管理
    1. 建立连接
    2. 释放连接

### 可靠传输

#### 停止等待ARQ协议
1. ARQ（Automatic Repeat–reQuest），自动重传请求
    1. 超时重传：A发给B，如果一定时间B没有相应（没有接收到，或者接受到是错误直接丢弃），则为超时，重新发送M1
    2. 确认丢失：B接收到之后，返回给A确认消息，但是发送失败，或者中间发送错误，没有到达A，导致A重新发送M1，但此时B会得到2分相同的M1，B会丢弃掉重复的
    3. 确认迟到：B接收到之后，返回给A确认消息比较晚了，因此A也会重新发送M1，但此时B会得到2分相同的M1，B会丢弃掉重复的

        ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/wlxy-39.png)
2. 疑问
    1. 若有个包重传了N次还是失败，会一直持续重传到成功为止么？
        1. 这个取决于系统的设置，比如有些系统，重传5次还未成功就会发送reset报文（RST）断开TCP连接
    2. 如果一个数据包非常大，分成n个传输，每个都这么传输、而且串行传输的话非常浪费时间？---连续ARQ协议+滑动窗口协议

#### 连续ARQ协议+滑动窗口协议
![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/wlxy-40.png)

1. 原理：发送方一次发送4个（根据接收方窗口的大小来确定）包，然后接收方只需要确认最后一个包即可
2. 窗口大小在TCP协议的首部设置的有
3. 疑问：
    1. 如果接收窗口最多能接收4个包，但发送方只发了2个包，接收方如何确定后面还有没有2个包？
        1. 等待一定时间后没有第3个包，就会返回确认收到2个包给发送方

#### SACK(选择性确认)
1. 在TCP通信过程中，如果发送序列中间某个数据包丢失（比如1、2、3、4、5中的3丢失了）
2. TCP会通过重传最后确认的分组后续的分组（最后确认的是2，会重传3、4、5）
3. 这样原先已经正确传输的分组也可能重复发送（比如4、5），降低了TCP性能
4. 为改善上述情况，发展出了**SACK（Selective acknowledgment，选择性确认）**技术
    1. 告诉发送方哪些数据丢失，哪些数据已经提前收到
    2. 使TCP只重新发送丢失的包（比如3），不用发送后续所有的分组（比如4、5）
5. SACK信息会放**在TCP首部的选项部分**，具体设置的值如下：
    1. Kind：占1字节。值为5代表这是SACK选项
    2. Length：占1字节。表明SACK选项一共占用多少字节
    3. Left Edge：占4字节，左边界
    4. Right Edge：占4字节，右边界
6. 一对边界信息需要占用8字节，由于TCP首部的选项部分最多40字节，所以
    1. SACK选项最多携带4组边界信息
    2. SACK选项的最大占用字节数 = 4 * 8 + 2 = 34
7. 疑问：
    1. 为什么选择在传输层就将数据“大卸八块”分成多个段，而不是等到网络层再分片传递给数据链路层？
        1. 因为可以提高重传的性能
        2. 需要明确的是：可靠传输是在传输层进行控制的
            1. 如果在传输层不分段，一旦出现数据丢失，整个传输层的数据都得重传
            2. 如果在传输层分了段，一旦出现数据丢失，只需要重传丢失的那些段即可

### 流量控制


