---
layout: post
title: 第三章 C++基础知识点
category: C-Plus语法
tags: C-Plus
description: C-Plus
---

## C与C++的区别
1. 头文件的导入区别
    1. c++支持3种头文件
        1. 带.h: 传统的C头文件，C++兼容C `#include<stdio.h>`
            1. 如果一个头文件是C和C++公用的，那就得写成C的样式
        2. 不带.h: C++特有的头文件： `#include<iostream>`
        3.  .hpp结尾：`#include<iostream.hpp>`
            1. 不常用
2. 输入、打印区别：
    
    ```
    #include<iostream>
    #include<stdio.h>    
    int main (){
    
      // c++ 中的打印
    	//cout: 就是c++的一个类对应的对象
    	cout << "hello world !" << endl;
    	
    	//c中的打印
    	printf("hello world !");
    
    
    	int i = 0;
    	//c++中的输入
    	//cin >> i;
    	//c中的输入
    	scanf("%d",&i);
    	cout << "i = " << i << endl;
    	
    	system("pause");
    	return 0;
    }
    ```
    
    1. C++兼容C的基本语法
    2. cout/cin: 就是c++的一个类对应的对象
    3. endl: 相当于C语言中的\n，如下
        
        ```
        cout << "i = " << i << "\n";
        ```
3.  命名空间
    1. 防止同名函数同名类的冲突
    2. 项目很大时，有两个相同的函数名，在不同的头文件，此时编译器就不知道该调用哪一个，因此，就需要用到命名空间。
    3. 如果using namespace std;不写，下面的每个打印跟输入对象前面都需要加上命名空间：std ::
    
        ```
        std :: cin >> i;
		  std :: cout << "hello world !" << std :: endl;
        ```
    4. 命名空间的使用：
        
        ```
        #include<iostream>
        using namespace std;
        
        //命名空间1
        namespace spaceone{
        
        	void func(){
        		cout << "spaceone" << endl;
        	}
        }
        
        //命名空间2
        namespace spacetwo{
        
        	void func(){
        		cout << "spacetwo" << endl;
        	}
        }
        
        //无名命名空间，那么这个函数只能在这个无名命名空间内部使用。外部无法使用
        // 是要内部使用，不需要外部知道
        // 类似于静态函数：只能在当前文件内部使用。
        namespace {
        
        	void func(){
        		cout << "nomame" << endl;
        	}
        }
        
        int main(){
        
           //调用命名空间1的函数
        	using namespace spaceone;
        	func();
        	//调用命名空间2的函数
        	spacetwo::func();
        
        	system("pause");
        	return 0;
        }
        ```
        
4. Class关键字：
    1. C++特有的东西，C中没有对应的东西
    2. 唯一相似的东西就是结构体
    3. C++中类，就相当于结构体的一个升级
    4. 但是他们还是有本质的区别
    5. 如果把people的定义结构struct 换成一个class，那么使用时就会报错。
        1. 结构体，可以在外面任意修改、读取他的成员变量的值
        2. 如果是类，是不允许在外面直接访问成员的
        3. 如何才能让类的成员可以在外面访问呢？ 使用public: ,表示共有的
        4. 这样，就跟结构体的使用有点相似了
        5. private：表示一些成员是私有的，不允许在外部访问
    
        ```
        #include<iostream>
        #include<stdio.h>
        #include<string.h>
        //c++特有的概念：
        using namespace std;
        
        //结构体
        struct people{
        	char name[100];
        	int age;
        	int sex;
        };
        
        //类
        class kid{
        public:
        	char name[100];
        	int age;
        	int sex;
        
        private:
        	int score;
        };
        
        int main (){
        
         //结构体的使用
        	people man;
        	strcpy_s(man.name,"name");
        	man.age = 10;
        	man.sex = 1;
        	cout << man.name << endl;
         
         //类的使用
        	kid kidd;
        	strcpy_s(kidd.name, "kidname");
        	kidd.age = 10;
        	kidd.sex = 1;
        
        	cout << kidd.name << endl;
        
        	system("pause");
        	return 0;
        }
        ```
    6. class的应用
        1. 设计一个类的时候要遵循一些原则
        2. 有些成员需要保护，那么就要设置相应的**类的成员函数**来设置
        3. 如果类函数返回的是成员变量的指针，为了避免在类外部的成员变量被修改，所以函数就要返回常量指针
        4. 如果全局变量和类成员变量重名，那么在类中访问的是类的成员变量
        5. 但是，如果我就是在类中访问全部变量呢？
            1. 那么就在类中的那个成员变量前面加**::**即可
            2. 同理，在函数内部有一个变量，与外部变量相同，那么也会默认访问内部的变量，那么如果非要访问外部的，也是在外部前加**::**
        6. 代码示例:
            
            ```
            #include<iostream>
            #include<string.h>
            
            //全局变量
            int age = 0;
            
            //定义一个类
            class man{
            	//成员变量私有
            private:
            	char name[100];
            	int age;
            
            	//设置成员变量只能通过公开的这个函数设置
            public:
            	void set_name(const char *s){
            
            		//如果name没有值，清空
            		memset(name, 0, sizeof(name));
            		
            		//不允许起名为tom
            		if (strcmp(s, "tom") == 0){
            			printf("不许起名为tom");
            			return;
            		}
            
            		strcpy_s(name,s);
            	}
            	void set_age( int a){
            		//访问的是类的成员变量
            		age = a;
            		//访问的是全局变量
            		::age = 100;
            	}
            
            	//这个方法就有漏洞了，因为返回的是name的指针，那么外部就可以拿到这个指针直接赋值为tom
            	/*
            	char *get_name(){
            	return name;
            	}
            	*/
            	
            	// 因此，在返回值前面加一个const就好了
            	const char *get_name(){
            		return name;
            	}
            
            	int get_age(){
            		return age;
            	}
            };
            
            
            int main(){
            	using namespace std;
            	man m;
            	//此时这么写就错了，因为成员变量那么是私有的。
            	//strcpy(m.name, "tom");
            
            	// 不能设置为tom
            	//m.set_name("tom");
            	m.set_name("tom2");
            
            	//如果get_name返回的值没有加const，却可以设置为tom
            	//char *p = m.get_name();
            	//strcpy_s(p,100,"tom");
            
            
            	cout << m.get_name() << endl;
            
            	//局部变量和类成员变量重名，默认实际会访问类成员变量。
            	m.set_age(10);
            	cout << m.get_age() << endl;
            	cout << age << endl;
            	system("pause");
            	return 0;
            }
            ```

    
5. 函数的区别：
    1. 在c中函数是可以不写返回值的，但是在C++中必须写返回值
        
        ```
        //c中
        test(){
        }
        //c++中
        void test(){
        }
        
        ```
    2. 在.h文件中的声明区别：
        1. C语言，在.h文件中可以这么声明: `int test ();`
        2. 但是在C++中不行，必须详细声明，而且声明啥样就必须对应相应的实现，否则就会报错。
            1. 如果没有参数： `int test (void);`
            2. 有参数，就必须声明 `int test (int i)；`
6. const，C与C++通用
7. volatile：
    1. c语言c++都有，作用是
    2. 我们知道无论任何一种语言，在编译的时候都会被优化精简掉，形成可执行程序
    3. 但是有些时候，我们不希望一些代码被优化，此时就可以用到这个关键字：volatile
8. c++中新增了一个类型：bool,取值只有false、ture
9. c++的类型转换：
    1. c语言中可以这么写
        
        ```
        void *p;
	     int *i = p;
        ```
    2. 但是在c++中
        
        ```
        void *p;
	     int *i =(void *) p;
        ```
    3. 即在c++中，不同的类型指针，是不能直接赋值的，必须强转。
10. 在堆中分配内存
    1. c中：使用malloc分配内存
        1. malloc 是一个函数，在头文件stdlib中放着
        2. 释放用free函数
            
            ```
            //堆中分配内存
            int *p = (int *)malloc(sizeof(int));
            *p = 10;
            printf("%d",*p);
            //释放
            free(p);
            ```
    2. c++中不建议(可以用)用malloc 用new
        1. new是c++提供的一个操作符，不是函数。不需要包含任何头文件
        2. 释放必须用delete
        3. new和delete时c++内建操作符，不需要引入任何头文件。
        4. 注意用malloc分配的内存不能用delete释放，用new分配的内存也不能用free释放。
        5. 使用new分配时，可以同时给他赋一个值
        6. 如果想要给一个类分配内容，c的malloc时不可以使用的，但是new可以分配c的任何基本数据类型。
        7. new时万能的，malloc只能针对c语言。
            
            ``` 
            
            //int *p = new int;
            //*p = 10;
            //使用new分配时，可以同时给他赋一个值
        	   int *p = new int(10);
        	   cout << *p << endl;
        	   //释放
            delete p;
            ```
        8. 分配一个动态数组
            1. c++中delete释放一个指针，即使他指向null也没有问题，内部做的有优化。
            
            ```
            #include<iostream>
            #include<stdlib.h>
            int main(){
            	using namespace std;
            	//动态分配一个数组
            	int *p = new int[10];
            	for (int i = 0; i < 10; i++){
            		p[i] = i;
            	}
            	for (int i = 0; i < 10; i++){
            		cout << p[i] << endl;
            	}
            	//释放整个数组的内存,必须前面加[]
            	delete []p;
            
            	//即使释放的一块内存指向null 也不会报错。
            	p = NULL;
            	delete p;
            
            	system("pause");
            	return 0;
             }

            ```

## C++函数的新特性
1. 内联函数
    1. 我们知道不管是C还是C++调用一个函数，是需要分配堆栈的，长期的调用一个函数，会非常消耗。不断地释放、分配。
    2.  当在函数前面添加一个inline关键字的时候，这就叫做内联，此时编译的时候就不会当一个函数处理了
    3. 内联函数关键字inline： 内联函数不作为函数调用，而是直接把内联函数的代码直接嵌入到调用的语句中
    4. 内联函数适合:函数代码很少，而且频繁的大量调用
    5. 内联其实就是给编译器的一个建议，具体什么为多，什么为少，并没有给出一个界定。根据情况设置
        
        ```
        //内联函数
        inline int mymax(int a, int b ){
        	
        	if (a > b) return a;
        	return b;
        }
        
        //main中调用
        for (int i = 0; i < 100; i++){
        		//如果mymax函数加了inline关键字，那么下面这句话
        		mymax(i, 10);
        		//等价于
        		//int a = 10;
        		//if (i > 10) a = i;
        	}
        ```
2. 引用变量
    1. **引用就是一个变量的外号、别名，不是变量的地址！**
    2. 引用是不能孤立存在的，在创建引用的时候一定要告诉它引用了谁
    3. 一旦引用指向了，就不能再改变了，永远指向定义时的那个变量
    4. 引用变量作为函数的参数
        
        ```
        
        //引用变量，引用作为函数的参数
        void myswap(int &a, int &b){
        
            	int temp = a;
            	a = b;
            	b = temp;
        }
        
        //main 函数内部代码：
        
        using namespace std;
        	int a = 5;
        	int b = 10;
        	//定义一个引用c，注意：c不是a的地址。  c就是a的别名、外号而已。
        	int &c = a;
        	//引用是不能孤立存在的，在创建引用的时候一定要告诉它引用了谁。
        	//这么写就是错误的。
        	//int &c；
        	//c = a;
        	//打印会发现，a和c的地址一样。
        	printf("c = %p , a= %p", &c, &a);
        
        	//引用变量作为函数的参数
        	myswap(a, b);
        	cout << "a=" << a << "\nb = " << b << endl;
        ```
    5. 引用的本质
        1. 先看下面4个函数：
            
            ```
            //不修改外部参数的值，只用来使用外部参数
            void func( int a, int b){
            	a = 10;
            	b = 20;
            }
            
            // 会修改外部参数的值
            void func2(int &a, int &b){
            	a = 10;
            	b = 20;
            }
            
            //会修改外部参数的值
            void func3(int *a, int *b){
            	*a = 10;
            	*b = 20;
            }
            
            //不修改外部参数的值，只用来使用外部参数
            //如果要使用参数的值，而且不能再函数内部被修改，那么就定义为常量引用
            void func4(const int &a, const int &b){
            	//下面2句话就会报错，因为引用参数为常量，不允许修改。
            	//a = 10;
            	//b = 20;
            }
            ```
        2. 主函数调用
            
            ```
            int x = 11;
            int y = 22;
             //1、4等价。
            func(x, y);
            printf("%d====%d\n", x, y);
            func2(x,y);
            printf("%d====%d\n", x, y);
            func3(&x, &y);
            printf("%d====%d\n", x, y);
            ```
        3. 我们会发现函数1、4结果相同，函数2、3结果相同，那么问题来了，既然效果相同为何还要用引用呢?
            1. 引用作为函数的参数，没有出栈、入栈操作，所以效率更高
            2. 由反汇编可知，调用函数的本质就是在内存中分配帧栈，给每个参数变量都分配内存，调用完毕再清除。这是一个会消耗内存、耗时的操作
            3. 而引用则不会给参数分配内存，引用就是原来参数的别名，就是拿到原来参数进行运算，不会给函数参数分配内存，因此效率更高。
3. 函数的默认参数，也叫缺省参数
    1. c++允许函数在定义的时候，提供缺省参数，如果函数在调用的时候没有提供形参，那么形参值就是缺省值。
    2. 注意，设置函数的缺省参数时，不能第一个参数设置了缺省值，但是后面的参数没有设置。但是如果后面的参数设置了缺省值，但是前面的没有，确是可以的
        
        ```
        //错误
        void func1(int a = 10, int b){}
        //正确
        void func1(int a, int b = 20){}
        ```
    3. 示例说明：
        
        ```
        //函数的缺省参数
        void func1(int a = 10, int b = 20){
            printf("a===== %d",a);
        }
        
        //调用：
        
        //不写参数就是默认使用函数中的缺省参数
	     func1();
        ```
4. 函数重载
    1. 在c中，函数不能重名，但是在C++中可以重名。
    2. 函数的名称一样，但参数不同。
    3. 注意：只能通过参数重载，不能通过返回值重载。
        1. 函数的名称是一样的，但参数不同可以重载。
        2. 函数的参数相同，返回值不同，不可以重载
        3. 比如，2个函数除了返回值类型不一样，其他都一样，这个是不行的。
    4. 注意：参数不同是通过参数的类型决定的，不是参数的名字
       
       ```
       //这两个是一样的。
       void func2(int a,int b){}；
       void func2(int b,int a){}；
       ```          

    5. 如果缺省函数和函数的重载冲突了，是不可以的
        
        ```
        //缺省参数函数：
        void func2(int a = 10）{}
        //函数重载
        void func2(）{}
        
        
        //此时调用就会报错了
        fun2();
        ```
    6. 代码示例：
        
        ```
        //函数的重载
        void func2(int a){
        	printf("a===== %d", a);
        }
        void func2(const char *s){
        	printf("s===== %s", s);
        }
        
        //main函数调用：
        //函数重载
        func2(1);
        func2("name");
        ```
5. 函数模板
    1. 当函数的实现相同，仅仅参数和返回值的类型不同时，可使用函数模板
    2. 比如下面两个函数；
        
        ```
        //2个函数实现
        double myadd(double a, double b){
        	return a + b;
        }
        int  myadd(int a, int b){
        	return a + b;
        }
        
        //调用；
        int a = 10;
        	int b = 20;
        	double d = 12.11;
        	double c = 10.11;
        	
        	cout << myadd(a, b) << endl;
        	cout << myadd(d, c) << endl;
        ```
    3. 如果使用函数模板
        
        ```
        //使用函数模板，写一个实现就可以了，也叫泛型编程
        template <class T>
        
        T myadd2(T a, T b){
        	return a + b;
        }
        
        //调用
        //调用函数模板
        	//调用的时候会将T换成，参数的类型
        	cout << myadd2(a, b) << endl;
        	cout << myadd2(d, c) << endl;
        ```
    4. 函数模板的重载：
        1. 2个模板名一样的模板，但是参数的数量不一样。
        2. 而且模板也可以设置缺省参数
        
        ```
        //函数模板重载，而且模板也可以设置缺省参数
        template <class T>
        T myadd2(T a = 0){
        	return a;
        }
        
        //调用
        cout << myadd2(10) << endl;
        system("pause");
        ```
        
        
            




    


