---
layout: post
title: 第三章 C++基础知识点
category: C-Plus语法
tags: C-Plus
description: C-Plus
---

## C与C++的区别
1. 头文件的导入区别
    1. c++支持3种头文件
        1. 带.h: 传统的C头文件，C++兼容C `#include<stdio.h>`
            1. 如果一个头文件是C和C++公用的，那就得写成C的样式
        2. 不带.h: C++特有的头文件： `#include<iostream>`
        3.  .hpp结尾：`#include<iostream.hpp>`
            1. 不常用
2. 输入、打印区别：
    
    ```
    #include<iostream>
    #include<stdio.h>    
    int main (){
    
      // c++ 中的打印
    	//cout: 就是c++的一个类对应的对象
    	cout << "hello world !" << endl;
    	
    	//c中的打印
    	printf("hello world !");
    
    
    	int i = 0;
    	//c++中的输入
    	//cin >> i;
    	//c中的输入
    	scanf("%d",&i);
    	cout << "i = " << i << endl;
    	
    	system("pause");
    	return 0;
    }
    ```
    
    1. C++兼容C的基本语法
    2. cout/cin: 就是c++的一个类对应的对象
    3. endl: 相当于C语言中的\n，如下
        
        ```
        cout << "i = " << i << "\n";
        ```
3.  命名空间
    1. 防止同名函数同名类的冲突
    2. 项目很大时，有两个相同的函数名，在不同的头文件，此时编译器就不知道该调用哪一个，因此，就需要用到命名空间。
    3. 如果using namespace std;不写，下面的每个打印跟输入对象前面都需要加上命名空间：std ::
    
        ```
        std :: cin >> i;
		  std :: cout << "hello world !" << std :: endl;
        ```
        
4. Class关键字：
    1. C++特有的东西，C中没有对应的东西
    2. 唯一相似的东西就是结构体
    3. C++中类，就相当于结构体的一个升级
    4. 但是他们还是有本质的区别
    5. 如果把people的定义结构struct 换成一个class，那么使用时就会报错。
        1. 结构体，可以在外面任意修改、读取他的成员变量的值
        2. 如果是类，是不允许在外面直接访问成员的
        3. 如何才能让类的成员可以在外面访问呢？ 使用public: ,表示共有的
        4. 这样，就跟结构体的使用有点相似了
        5. private：表示一些成员是私有的，不允许在外部访问
    
    ```
    #include<iostream>
    #include<stdio.h>
    #include<string.h>
    //c++特有的概念：
    using namespace std;
    
    //结构体
    struct people{
    	char name[100];
    	int age;
    	int sex;
    };
    
    //类
    class kid{
    public:
    	char name[100];
    	int age;
    	int sex;
    
    private:
    	int score;
    };
    
    int main (){
    
     //结构体的使用
    	people man;
    	strcpy_s(man.name,"name");
    	man.age = 10;
    	man.sex = 1;
    	cout << man.name << endl;
     
     //类的使用
    	kid kidd;
    	strcpy_s(kidd.name, "kidname");
    	kidd.age = 10;
    	kidd.sex = 1;
    
    	cout << kidd.name << endl;
    
    	system("pause");
    	return 0;
    }
    ```
5. 函数的区别：
    1. 在c中函数是可以不写返回值的，但是在C++中必须写返回值
        
        ```
        //c中
        test(){
        }
        //c++中
        void test(){
        }
        
        ```
    2. 在.h文件中的声明区别：
        1. 源文件中可以这么定义函数：
            
            ```         
            
            int test (int i){
    
        			 return 0;
        		 }
            ```
            
        2. C语言，在.h文件中可以这么声明: `int test ();`
        3. 但是在C++中不行，必须详细声明，而且声明啥样就必须对应相应的实现，否则就会报错。
            1. 如果没有参数： `int test (void);`
            2. 有参数，就必须声明 `int test (int i)；`
6. const，C与C++通用
7. volatile：
    1. c语言c++都有，作用是
    2. 我们知道无论任何一种语言，在编译的时候都会被优化精简掉，形成可执行程序
    3. 但是有些时候，我们不希望一些代码被优化，此时就可以用到这个关键字：volatile
8. c++中新增了一个类型：bool,取值只有false、ture
9. c++的类型转换：
    1. c语言中可以这么写
        
        ```
        void *p;
	     int *i = p;
        ```
    2. 但是在c++中
        
        ```
        void *p;
	     int *i =(void *) p;
        ```
    3. 即在c++中，不同的类型指针，是不能直接赋值的，必须强转。
10. 在堆中分配内存
    1. c中：使用malloc分配内存
        1. malloc 是一个函数，在头文件stdlib中放着
        2. 释放用free函数
            
            ```
            //堆中分配内存
            int *p = (int *)malloc(sizeof(int));
            *p = 10;
            printf("%d",*p);
            //释放
            free(p);
            ```
    2. c++中不建议(可以用)用malloc 用new
        1. new是c++提供的一个操作符，不是函数。不需要包含任何头文件
        2. 释放必须用delete
        3. new和delete时c++内建操作符，不需要引入任何头文件。
        4. 注意用malloc分配的内存不能用delete释放，用new分配的内存也不能用free释放。
        5. 使用new分配时，可以同时给他赋一个值
        6. 如果想要给一个类分配内容，c的malloc时不可以使用的，但是new可以分配c的任何基本数据类型。
        7. new时万能的，malloc只能针对c语言。
            
            ``` 
        	   //int *p = new int;
            //*p = 10;
            //使用new分配时，可以同时给他赋一个值
        	   int *p = new int(10);
        	   cout << *p << endl;
        	   //释放
            delete p;
            ```
        8. 分配一个动态数组
            1. c++中delete释放一个指针，即使他指向null也没有问题，内部做的有优化。
            
            ```
            #include<iostream>
            #include<stdlib.h>
            int main(){
            	using namespace std;
            	//动态分配一个数组
            	int *p = new int[10];
            	for (int i = 0; i < 10; i++){
            		p[i] = i;
            	}
            	for (int i = 0; i < 10; i++){
            		cout << p[i] << endl;
            	}
            	//释放整个数组的内存,必须前面加[]
            	delete []p;
            
            	//即使释放的一块内存指向null 也不会报错。
            	p = NULL;
            	delete p;
            
            	system("pause");
            	return 0;
             }

            ```
        
            




    


