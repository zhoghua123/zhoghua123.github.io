---
layout: post
title: 第四章 C++类和对象
category: C-Plus语法
tags: C-Plus
description: C-Plus
---    

## 类和对象
1. 类的成员变量的作用域
    1. 全局变量的作用域
        1. 我们知道，不能在.h文件中定义一个**全局变量**，因为如果两个cpp文件都引用了这个头文件，那么编译时就会报错了，因为这个全局变量重复编译了
        2. 此时就采用extern关键字
            1. 在.cpp定义这个全局变量`int a = 10;`
            2. 在.h中用extern声明这个全局变量。`extern int a;`
                1. 此时仅仅是对a 的一个声明，必须在.cpp中定义，外部才能使用。
    2. 但是如果定义一个**类的成员变量呢？**
        1. 定义一个**类的成员变量**是需要放到.h头文件中去的
        2. 因为类的成员变量的作用域局限于类内部，类的外部不可见。
2. 类的构造/析构函数
    1. 类的构造函数
        1. 构造函数的特点：
            1. 函数的名字和类的名字一样
            2. 不需要定义返回值
        2. 构造函数的调用时刻
            1. 一个类实例化为一个对象的时候，自动调用，比如：`man m;//man是一个类`
        3. 跟成员函数一样在.h文件中声明，在.cpp文件中实现
    2. 类的析构函数：
        1. 析构函数特点：
            1. 函数的名字由**~** + 类名组成
            2. 不需要定义返回值
        3. 析构函数的调用时刻
            1. 当前类的实例对象在内存中被销毁的时候自动调用。
    3. 一个类一定有构造和析构函数，
        1. 即时你创建的一个类没有写构造、析构函数，**编译器**会自动生成一个默认的构造、析构函数。
    4. 构造和析构函数必须是public的，不能是private的。
        1. 因为实例化一个对象的是有一定会再外部调用这个构造函数。同理销毁一个对象的时候也会在外部调用。
    5. 构造函数的作用
        1. 初始化成员变量
        2. 有2中初始化方式
            1. 在函数内部初始化
                
                ```
                //作用；初始化成员变量
                man::man()
                {
                	age = 10;
                	strcpy_s(name, "小李");
                	cout << "执行了man函数" << endl;
                }
                ```
            2. 初始化成员列表：
                1. 这种方式，只能在构造函数时使用
                
                ```
                //初始化成员变量列表的方法
                man::man() : age(11)
                {
                }
                ```
        3. **注意：如果一个成员变量被const修饰，即常量成员变量，那么他的初始化方式，必须使用初始化成员列表的方式赋初值**
    6. 构造函数的重载
        1. 跟其他函数一样，构造函数也可以重载
            1. 就是参数不同，其他都相同。
            2. 构造参数可以重载多个
        2. 重载构造函数的调用：
            1. 栈中构造函数的调用
                1. 创建一个单例的时候调用
    
                ```
                //重载构造函数调用： 在创建实例的时候调用
    	          man m2("小华");
                ```
            2. 堆中构造函数的调用
                
                ```
                //在堆中实例化一个对象
                man *p = new man("小李");
                //调用没有参数的构造函数，在堆中实例化
                man *p2 = new man;
                
                delete p;
                delete p2;
                ```
        3. 析构函数不能重载，只能有一个，而且是系统调用的。
            1. 由于析构函数只有一个，如果在不同的构造函数中给成员变量的指针分配了内存，都要在这个析构函数中销毁
    7. 代码举例：

        ```
        //man类.h文件
        
        #ifndef MAN_H
        #define MAN_H
        
        //声明一个全局变量
        extern int a;
        
        class man
        {
        public:
        	//当前类的构造函数
        	man();
        	//重载构造函数
        	man(const char *s);
        
        	//当前类的析构函数
        	~man();
        
        	//拷贝构造函数；也是就是指向自己的引用
        	//这个方法系统默认实现，不需要自己实现
        	man(const man &it);
        
        	//成员变量私有
        private:
        	char name[100];
        	int age;
        
        	//设置成员变量只能通过公开的这个函数设置
        public:
        	void set_name(const char *s);
        	void set_age(int a);
        	const char *get_name();
        	int get_age();
        };
        
        #endif
        
        
        //man类.cpp文件
        #include "man.h"
        #include<string.h>
        #include<iostream>
        
        using namespace std;
        //定义全局变量
        int a = 10;
        
        //构造函数
        //作用；初始化成员变量
        man::man()
        {
        age = 10;
        strcpy_s(name, "小李");
        cout << "执行了man函数" << endl;
        }
        
        /*
        //初始化成员变量列表的方法
        man::man() : age(11)
        {
        }
        */
        
        //重载构造函数
        man::man(const char *s){
        	strcpy_s(name, s);
        }
        
        //拷贝构造函数
        man :: man(const man &it){
        	cout << "执行了拷贝" << endl;
        	//拷贝参数的nanme，age
        	strcpy_s(name, it.name);
        	age = it.age;
        }
        
        //析构函数
        man::~man()
        {
        	cout << "执行了~man函数" << endl;
        }
        
        void man::set_name(const char *s){
        
        	//如果name没有值，清空
        	memset(name, 0, sizeof(name));
        	strcpy_s(name, s);
        }
        void man :: set_age(int a){
        	//访问的是类的成员变量
        	age = a;
        }
        
        // 因此，在返回值前面加一个const就好了
        const char *man :: get_name(){
        	return name;
        }
        
        int man :: get_age(){
        	return age;
        }
        
        //main文件调用：
        
        #include<iostream>
        #include<string.h>
        #include"man.h"
        
        void test(){
        	//在栈当中将man这个类实例化一个对象叫m，此时会调用构造函数man();
        	man m;
        }
        void test2(){
        	//拷贝构造函数
        	man mx;
        	// = 是拷贝的意思，拷贝一个对象，因此这个函数执行完毕，会调用一次构造函数，2次析构函数
        	man my = mx;
        }
        int main(){
        	using namespace std;
        
        	test();
        
        	//6. 拷贝构造函数
        	test2();
        
        	//5. 在堆中实例化一个对象
        	man *p = new man("小李");
        	//调用没有参数的构造函数，在堆中实例化
        	man *p2 = new man;
        
        	delete p;
        	delete p2;
        
        
        	//4. 重载构造函数调用： 在创建实例的时候调用
        	man m2("小华");
        	cout << m2.get_name() << endl;
        
        	
        	//3. 打印默认值
        	man m;
        	cout << m.get_name() << endl;
        	cout << m.get_age() << endl;
        
        
        	//2. 设置类的成员变量
        	m.set_name("tom2");
        	cout << m.get_name() << endl;
        	m.set_age(10);
        	cout << m.get_age() << endl;
        
        	//1. 全局变量
        	cout << a << endl;
        	
        	system("pause");
        	return 0;
        }
        ```
        
    7. 拷贝构造函数
        1. 也是系统提供默认的,不用写
        2. 调用时刻，当使用=的时候
        
        
        
        
    
        
    


