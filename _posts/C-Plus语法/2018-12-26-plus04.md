---
layout: post
title: 第四章 C++类和对象
category: C-Plus语法
tags: C-Plus
description: C-Plus
---    

## 类和对象
1. 类的成员变量的作用域
    1. 全局变量的作用域
        1. 我们知道，不能在.h文件中定义一个**全局变量**，因为如果两个cpp文件都引用了这个头文件，那么编译时就会报错了，因为这个全局变量重复编译了
        2. 此时就采用extern关键字
            1. 在.cpp定义这个全局变量`int a = 10;`
            2. 在.h中用extern声明这个全局变量。`extern int a;`
                1. 此时仅仅是对a 的一个声明，必须在.cpp中定义，外部才能使用。
    2. 但是如果定义一个**类的成员变量呢？**
        1. 定义一个**类的成员变量**是需要放到.h头文件中去的
        2. 因为类的成员变量的作用域局限于类内部，类的外部不可见。
2. 类的构造/析构函数
    1. 类的构造函数
        1. 构造函数的特点：
            1. 函数的名字和类的名字一样
            2. 不需要定义返回值
        2. 构造函数的调用时刻
            1. 一个类实例化为一个对象的时候，自动调用，比如：`man m;//man是一个类`
        3. 跟成员函数一样在.h文件中声明，在.cpp文件中实现
    2. 类的析构函数：
        1. 析构函数特点：
            1. 函数的名字由**~** + 类名组成
            2. 不需要定义返回值
        3. 析构函数的调用时刻
            1. 当前类的实例对象在内存中被销毁的时候自动调用。
    3. 一个类一定有构造和析构函数，
        1. 即时你创建的一个类没有写构造、析构函数，**编译器**会自动生成一个默认的构造、析构函数。
    4. 构造和析构函数必须是public的，不能是private的。
        1. 因为实例化一个对象的是有一定会再外部调用这个构造函数。同理销毁一个对象的时候也会在外部调用。
    5. 构造函数的作用
        1. 初始化成员变量
        2. 有2种初始化方式
            1. 在构造函数内部初始化
                
                ```
                //作用；初始化成员变量
                man::man()
                {
                	age = 10;
                	strcpy_s(name, "小李");
                	cout << "执行了man函数" << endl;
                }
                ```
            2. 初始化成员列表：
                1. 这种方式，只能在构造函数时使用
                
                ```
                //初始化成员变量列表的方法
                man::man() : age(11)
                {
                }
                ```
        3. **注意：如果一个成员变量被const修饰，即常量成员变量，那么他的初始化方式，必须使用初始化成员列表的方式赋初值**
    6. 构造函数的重载
        1. 跟其他函数一样，构造函数也可以重载
            1. 就是参数不同，其他都相同。
            2. 构造参数可以重载多个
        2. 重载构造函数的调用：
            1. 栈中构造函数的调用
                1. 创建一个单例的时候调用
    
                ```
                //重载构造函数调用： 在创建实例的时候调用
    	          man m2("小华");
                ```
            2. 堆中构造函数的调用
                
                ```
                //在堆中实例化一个对象
                man *p = new man("小李");
                //调用没有参数的构造函数，在堆中实例化
                man *p2 = new man;
                
                delete p;
                delete p2;
                ```
        3. 析构函数不能重载，只能有一个，而且是系统调用的。
            1. 由于析构函数只有一个，如果在不同的构造函数中给成员变量的指针分配了内存，都要在这个析构函数中销毁
    7. 代码举例：

        ```
        //man类.h文件
        
        #ifndef MAN_H
        #define MAN_H
        
        //声明一个全局变量
        extern int a;
        
        class man
        {
        public:
        	//当前类的构造函数
        	man();
        	//重载构造函数
        	man(const char *s);
        
        	//当前类的析构函数
        	~man();
        
        	//拷贝构造函数；也是就是指向自己的引用
        	//这个方法系统默认实现，不需要自己实现
        	man(const man &it);
        
        	//成员变量私有
        private:
        	char name[100];
        	int age;
        
        	//设置成员变量只能通过公开的这个函数设置
        public:
        	void set_name(const char *s);
        	void set_age(int a);
        	const char *get_name();
        	int get_age();
        };
        
        #endif
        
        
        //man类.cpp文件
        #include "man.h"
        #include<string.h>
        #include<iostream>
        
        using namespace std;
        //定义全局变量
        int a = 10;
        
        //构造函数
        //作用；初始化成员变量
        man::man()
        {
        age = 10;
        strcpy_s(name, "小李");
        cout << "执行了man函数" << endl;
        }
        
        /*
        //初始化成员变量列表的方法
        man::man() : age(11)
        {
        }
        */
        
        //重载构造函数
        man::man(const char *s){
        	strcpy_s(name, s);
        }
        
        //拷贝构造函数
        man :: man(const man &it){
        	cout << "执行了拷贝" << endl;
        	//拷贝参数的nanme，age
        	strcpy_s(name, it.name);
        	age = it.age;
        }
        
        //析构函数
        man::~man()
        {
        	cout << "执行了~man函数" << endl;
        }
        
        void man::set_name(const char *s){
        
        	//如果name没有值，清空
        	memset(name, 0, sizeof(name));
        	strcpy_s(name, s);
        }
        void man :: set_age(int a){
        	//访问的是类的成员变量
        	age = a;
        }
        
        // 因此，在返回值前面加一个const就好了
        const char *man :: get_name(){
        	return name;
        }
        
        int man :: get_age(){
        	return age;
        }
        
        //main文件调用：
        
        #include<iostream>
        #include<string.h>
        #include"man.h"
        
        void test(){
        	//在栈当中将man这个类实例化一个对象叫m，此时会调用构造函数man();
        	man m;
        }
        void test2(){
        	//拷贝构造函数
        	man mx;
        	// = 是拷贝的意思，拷贝一个对象，因此这个函数执行完毕，会调用一次构造函数，2次析构函数
        	man my = mx;
        }
        int main(){
        	using namespace std;
        
        	test();
        
        	//6. 拷贝构造函数
        	test2();
        
        	//5. 在堆中实例化一个对象
        	man *p = new man("小李");
        	//调用没有参数的构造函数，在堆中实例化
        	man *p2 = new man;
        
        	delete p;
        	delete p2;
        
        
        	//4. 重载构造函数调用： 在创建实例的时候调用
        	man m2("小华");
        	cout << m2.get_name() << endl;
        
        	
        	//3. 打印默认值
        	man m;
        	cout << m.get_name() << endl;
        	cout << m.get_age() << endl;
        
        
        	//2. 设置类的成员变量
        	m.set_name("tom2");
        	cout << m.get_name() << endl;
        	m.set_age(10);
        	cout << m.get_age() << endl;
        
        	//1. 全局变量
        	cout << a << endl;
        	
        	system("pause");
        	return 0;
        }
        ```
        
3. 拷贝构造函数
    1. 下面代码（在构造、析构函数中设置打印），执行程序、结果如下：
        
        ```
        #include<iostream>
        #include"people.h"
        
        void test(){
        	people p1;
        	people p2 = p1;
        }
        
        int main(){
        	using namespace std;
        
        	test();
        
        	system("pause");
        	return 0;
        }
        
        //打印结果如下：
        
        执行了people函数
        执行了~people函数
        执行了~people函数
        ```
        
        1. 从打印我们可以看出，执行了一次构造，2次析构，（理论上就是2次构造2次析构）那么是不是就说明，多执行了一次析构（销毁）呢？
        2. 不是的，C++默认还会给一个类实现一个函数，即时你没有手动实现，这个函数叫**拷贝构造函数**
        3. 拷贝构造函数有固定的写法，如下：
           1. 类名（const 类名 &it）
           2. 即是**一个参数为自己这种类型的常量引用构造函数**
           3. 确切来说就是: 指向自己的引用。
           4. 我们手动实现的拷贝构造函数如下：
           
           ```
           //拷贝构造函数
            people :: people(const people &it){
            	cout << "执行了拷贝构造函数" << endl;
            	name = new char[100];
            	strcpy_s(name, 100, it.get_name());
            	age = it.get_age();
            }
           ```
           
        4. 再次执行程序，打印如下：
            
            ```
            执行了people函数
            执行了拷贝构造函数
            执行了~people函数
            执行了~people函数
            ```
        5. 从打印中说明，test函数中`people p2 = p1;`执行这句话的时候，就会默认调用拷贝构造函数。 
    2. 什么才叫拷贝?
        1. 对于C的结构体而言
            
            ```
            //结构体
            typedef struct{
            	int a;
            	int b;
            } demo;
            
            //结构体的拷贝
            demo d1;
            d1.a = 10;
            d1.b = 20;
            //拷贝
            demo d2 = d1;
            ```
        2. 结构体的拷贝本质是将d1结构体中的成员值，全部复制给d2的成员。
        3. “=” 在C++中就是拷贝，把这个内存中的内容拷贝到另一个内存中。
        4. 同理对于一个类来说“=”也是拷贝，把一个对象的**成员**拷贝给另外一个对象。这个拷贝也叫**浅拷贝**
    3. **浅拷贝**：2个对象之间成员变量的简单赋值
        1. 默认的拷贝构造函数，就是浅拷贝的。
        2. 注意：这里说的是成员变量简单的赋值，那么问题就来了，如果一个成员变量是指针（即需要分配内存）呢？
            1. 那么2个对象的那个指针成员变量就会指向同一块内存，
            2. 而且，只要2个对象任意一个对象改变这个指针变量，那么另外一个对象的也会改变，
            3. 那么当这个拷贝的对象销毁时，析构函数会把那个指针成员变量当做已经分配内存来销毁，那么就意味着，同一块内存被销毁2次
            4. 那么怎么才能实现成员变量是指针的时候，也能拷贝呢？ 即改变一个对象，另外一个对象不变----**深拷贝**
    4. **深拷贝**
        1. 深拷贝条件：
            1. 必须手动实现拷贝构造函数，因为系统默认额拷贝构造函数都是浅拷贝
            2. 只有当前类的成员变量有指针类型时（即需要分配内存时）才会有深拷贝
        2. 深拷贝实现的关键：
            1. 就是在拷贝构造函数的实现中，给当前类的所有指针成员变量分配相应的内存空间。
        3. 深拷贝、浅拷贝总结:
            1. 浅拷贝就是对成员变量的简单赋值，不管成员变量是任何类型。可以自己实现，也可以系统默认实现
            2. 深拷贝必须自动实现，首先要把当前类的带指针的成员变量分配内存，然后将成员变量的值赋值。

        
        
        
    
        
    


