---
layout: post
title: 汇编进阶- 知识整合
category: 汇编
tags: 汇编
description: 汇编
---

## 1. 汇编语言简介

### 汇编语言的发展
1. 机器语言
    1. 由0和1组成
2. 汇编语言（Assembly Language）
    1. 用符号代替了0和1，比机器语言便于阅读和记忆
3. 高级语言
    1. C\C++\Java\Swift等，更接近人类自然语言
4. 操作：将寄存器BX的内容送入寄存器AX
    1. 机器语言：1000100111011000
    2. 汇编语言：mov ax, bx
    3. 高级语言：ax = bx;
5. 如下图：

    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj01.png)
    
    1. **汇编语言**与**机器语言**一一对应，每一条机器指令都有与之对应的汇编指令
    2. 汇编语言可以通过编译得到机器语言，机器语言可以通过反汇编得到汇编语言
    3. 高级语言可以通过编译得到汇编语言\机器语言，但汇编语言\机器语言**几乎不可能**还原成高级语言
        1. 因为高级语言写不同的代码可能汇编语言是一样的。
  
### 汇编语言的特点
1. 可以直接访问、控制各种硬件设备，比如存储器、CPU等，能最大限度地发挥硬件的功能
2. 汇编指令是机器指令的助记符,同机器指令一一对应。每一种CPU都有自己的机器指令集\汇编指令集，所以汇编语言不具备可移植性
3. 知识点过多，开发者需要对CPU等硬件结构有所了解，不易于编写、调试、维护
4. **不区分大小写**，比如mov和MOV是一样的
    
### 汇编语言的用途
1. 编写驱动程序、操作系统（比如Linux内核的某些关键部分）
2. 对性能要求极高的程序或者代码片段，可与高级语言混合使用（内联汇编）
3. 软件安全
    1. 病毒分析与防治
    2. 逆向\加壳\脱壳\破解\外挂\免杀\加密解密\漏洞\黑客
4. 是理解整个计算机系统的最佳起点和最有效途径
5. 为编写高效代码打下基础

### 汇编语言的种类
1. 目前讨论比较多的汇编语言有
    1. 8086汇编（8086处理器是16bit的CPU）
    2. Win32汇编
    3. Win64汇编
    4. AT&T汇编（Mac、iOS模拟器）
        1. 因为iOS的模拟器是运行在MAC上的，所以是MAC
    5. ARM汇编（嵌入式、iOS设备）
    6. ...
2. 入门建议先从学些8086汇编开始
    1. 结构简洁、经典
    2. 参考书籍：王爽《汇编语言》
    
### 学前须知
1. 要想学好汇编语言，首先要对CPU等硬件结构有一定的了解
2. 软件\程序的执行过程如下：
    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj02.png)
3. 最为关键的是需要了解CPU和内存
4. 在学习汇编语言过程中，遇到的绝大部分指令都是跟内存、CPU有关的
    
## 2. 总线
1. 每一个CPU芯片都有许多管脚，这些管脚和总线相连，CPU通过总线跟外部器件进行交互
2. 总线：一根根导线的集合
3. 总线的分类
    1. 地址总线
    2. 数据总线
    3. 控制总线
4. 视图：
    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj03.png)
    
5. 三种总线的使用：
    1. CPU从内存的3号单元读取数据
       ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj04.png) 
        1. 通过地址总线将3这个数据输送到内存，内存就会知道要访问第3个单元的数据
            1. 即地址总线用来寻址，寻找某个内存空间
            2. 用数电知识来解析就是存储器的哪些单元的引脚有效
        2. 控制总线告诉内存是要读取还是写这个单元，此时为读
            1. 用于控制读写
            2. 用数电的知识解析就是用来控制数据总线连接的晶闸管正向还是逆向导通。
        3. 这个时候就会通过数据总线将这个数据（08）传送给CPU。
            1. 用来传送数据
            2. 用数电的知识解析就是通过数据总线上的电平高低来获取二进制数据。
6. 地址总线
    1. 它的宽度决定了CPU的寻址能力
    2. 8086的地址总线宽度是20，所以寻址能力是1M（ 2^20  ）
7. 数据总线
    1. 它的宽度决定了CPU的单次数据传送量，也就是数据传送速度
    2. 8086的数据总线宽度是16，所以单次最大传递2个字节的数据
8. 控制总线
    1. 它的宽度决定了CPU对其他器件的控制能力、能有多少种控制

## 3. 内存
1. 各类存储器的逻辑连接情况
    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj05.png) 
    
    1. RAM与ROM区别？
        1. ROM: read Only memory 只读存储器，一般存放的以设备硬件相关的东西。
        2. RAM: 随机存储器，可读可写的。
2. 8086的内存
    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj06.png) 
    
    1. 所有的内存单元都有唯一的地址，叫做物理地址
    2. 各类存储器的物理地址情况
        1. 内存地址空间的大小受CPU地址总线宽度的限制。8086的地址总线宽度为20，可以定位2^20个不同的内存单元（内存地址范围0x00000~0xFFFFF），所以8086的内存空间大小为1MB
        2. 0x00000~0x9FFFF：主存储器。可读可写
        3. 0xA0000~0xBFFFF：向显存中写入数据，这些数据会被显卡输出到显示器。可读可写
        4. 0xC0000~0xFFFFF：存储各种硬件\系统信息。只读
3. 下图是各类存储器的逻辑连接-物理地址对应图
    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj07.png) 

## 4. 8086的寻址方式
1. CPU访问内存单元时，要给出内存单元的地址
2. 8086有20位地址总线，可以传送20位的地址，1M的寻址能力
3. 但它又是16位结构的CPU，它内部能够一次性处理、传输、暂时存储的地址为16位。如果将地址从内部简单地发出，那么它只能送出16位的地址，表现出来的寻址能力只有64KB  

    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj08.png) 
4. 8086采用一种在内部用2个16位地址合成的方法来生成1个20位的物理地址
    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj09.png) 
    
    1. CUP中的相关部件提供2个16位的地址，一个称为段地址，另一个称为偏移地址
    2. 段地址和偏移地址通过内部总线送入一个称为地址加法器的部件
    3. 地址加法器将两个16位地址合成为一个20位物理地址
    4. 地址加法器通过内部总线将20位物理地址送入输入输出控制电路
    4. 输入输出控制电路将20位物理地址送上地址总线
    5. 20位物理地址被地址总线传送到存储器
5. 地址加法器采用**物理地址= 段地址*16 + 偏移地址**的方法，用段地址和偏移地址合成物理地址。

## 5. 寄存器
1. 不同CPU的寄存器是不一样的。
    1. 8086/win32/win64/ARM的cpu的寄存器都不一样。
    2. ARM是最复杂的，因为他是嵌入式的，移动端的
2. CPU的典型构成
    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj10.png) 
    1. 对程序员来说，CPU中最主要部件是寄存器，可以通过改变寄存器的内容来实现对CPU的控制
    2. 不同的CPU，寄存器的个数、结构是不相同的（8086是16位结构的CPU）
    3. 8086有14个寄存器
        1. 都是16位的寄存器
        2. 可以存放2个字节 
            ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj11.png)
3. 通用寄存器
    1. AX、BX、CX、DX这4个寄存器通常用来存放一般性的数据，称为通用寄存器（有时也有特定用途）
    2. **通常，CPU会先将内存中的数据存储到通用寄存器中，然后再对通用寄存器中的数据进行运算**
    3. 假设内存中有块红色内存空间的值是3，现在想把它的值加1，并将结果存储到蓝色内存空间
        1. CPU首先会将红色内存空间的值放到AX寄存器中：mov ax,红色内存空间
        2. 然后让AX寄存器与1相加：add ax,1
        3. 最后将值赋值给内存空间：mov 蓝色内存空间,ax
    4. AX、BX、CX、DX这4个通用寄存器都是16位的
    5. 上一代8086的寄存器都是8位的，为了保证兼容， AX、BX、CX、DX都可分为2个独立的8位寄存器来使用
        1. H代表高位寄存器
        2. L代表低位寄存器
4. 字节与字 
    1. 在汇编的数据存储中，有2个比较常用的单位
    2. 字节：byte，1个字节由8bit组成，可以存储在8位寄存器中
    3. 字：word，1个字由2个字节组成，这2个字节分别称为字的高字节和低字节
    4. 1个字可以存在1个16位寄存器中，这个字的高字节、低字节分别存储在这个寄存器的高8位寄存器、低8位寄存器中
5. 段寄存器
    1. 8086在访问内存时要由相关部件提供内存单元的段地址和偏移地址，送入地址加法器合成物理地址
    2. 是什么部件提供段地址？段地址在8086的段寄存器中存放
    3. 8086有4个段寄存器：CS、DS、SS、ES，当CPU需要访问内存时由这4个段寄存器提供内存单元的段地址
        1. CS (Code Segment)：代码段寄存器
        2. DS (Data Segment)：数据段寄存器
        3. SS (Stack Segment)：堆栈段寄存器
        4. ES (Extra Segment)：附加段寄存器
    4. 每个段寄存器的具体作用是？
  
## 6. CS和IP
1. CS为代码段寄存器，IP为指令指针寄存器，它们指示了CPU当前要读取指令的地址
2. 任意时刻，8086CPU都会将CS:IP指向的指令作为下一条需要取出执行的指令
3. 指令执行的过程
    1. CPU根据代码段寄存器CS的值、IP寄存器的值，通过地址加法器合成20位的内存地址，传送给输入输出控制电路
    2. 输入输出控制电路通过地址地址总线将20位地址传输到内存，在内存的代码段找到对应的内存
    3. 寻址到内存中的数据通过数据总线传输给CPU的输入输出控制电路
    4. 输入输出控制电路，将数据传输给指令缓冲器
    5. 指令缓冲器将数据发送给执行控制器，执行控制指令
    6. IP寄存器自动加上一条指令的字节个数，然后执行下一条指令
       ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj12.png) 
    
    7. 通过上面的过程展示，8086CPU的工作过程可以简要描述如下
        1. 从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器
        2. IP = IP+所读取指令的长度，从而指向下一条指令
        3. 执行指令。跳转到步骤1，重复整个过程
    8. 在8086CPU加电启动或复位后（即CPU刚开始工作时）CS和IP被设置为CS = FFFFH,IP = 0000H,即在8086PC机刚刚启动时，CPU从内存FFFF0H单元中读取指令执行，FFFF0H单元中的指令是8086PC机开机后执行的第一条指令。
    9. 注意:
        1. 偏移地址IP只为CS服务，即代码段服务
        2. 而其他段（数据段、堆栈段、附加段）的偏移地址不是由IP提供
4. 指令和数据
    1. 在内存或者磁盘上，指令和数据没有任何区别，都是二进制信息
    2. CPU在工作的时候把有的信息看做指令，有的信息看做数据，为同样的信息赋予了不同的意义
    3. CPU根据什么将内存中的信息看做指令？
        1. **CPU将CS:IP指向的内存单元的内容看做指令**
        2. 取决于用哪种段寄存器来取值

## 7. jmp指令
1. CPU从何处执行指令是由CS、IP中的内容决定的，我们可以通过改变CS、IP的内容来控制CPU执行目标指令
2. 8086提供了一个mov指令（传送指令），可以用来修改大部分寄存器的值，比如：
    1. `mov ax,10、mov bx,20、mov cx,30、mov dx,40`
3. 但是，mov指令不能用于设置CS、IP的值，8086没有提供这样的功能
4. 8086提供了另外的指令来修改CS、IP的值，这些指令统称为转移指令，最简单的是jmp指令 
5. 若想同时修改CS/IP的内容，可用形如：“`jmp 段地址：偏移地址`” 的指令完成。如：
    1. `jmp 2AE3:3`,执行后：`CS=2AE3H,IP= 0003H`,CPU将从2AE33H处读取指令。
6. ”`jmp 段地址：偏移地址`“ 指令的功能为： 用指令给出的段地址修改CS,偏移地址修改IP
7. 若想修改IP的内容，可用形如“`jmp 某一合法寄存器`”的指令完成，如：
    
    ```
    jmp ax, 执行指令前：ax = 1000H，CS = 2000H,IP= 0003H
            执行指令后： ax = 1000H ，CS = 2000H,IP = 1000H
    ```
    
    1. “`jmp 某一合法寄存器`”指令的功能为： 用寄存器中的值修改IP
    2. `jmp ax` ，在含义上好似： `mov IP, AX`.
8. 另外，也可以“jmp 直接值”来改变IP的值，比如“`jmp 0100H`”


