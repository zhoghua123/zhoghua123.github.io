---
layout: post
title: 汇编进阶- 知识整合
category: 汇编
tags: 汇编
description: 汇编
---

## 1. 汇编语言简介

### 汇编语言的发展
1. 机器语言
    1. 由0和1组成
2. 汇编语言（Assembly Language）
    1. 用符号代替了0和1，比机器语言便于阅读和记忆
3. 高级语言
    1. C\C++\Java\Swift等，更接近人类自然语言
4. 操作：将寄存器BX的内容送入寄存器AX
    1. 机器语言：1000100111011000
    2. 汇编语言：mov ax, bx
    3. 高级语言：ax = bx;
5. 如下图：

    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj01.png)
    
    1. **汇编语言**与**机器语言**一一对应，每一条机器指令都有与之对应的汇编指令
    2. 汇编语言可以通过编译得到机器语言，机器语言可以通过反汇编得到汇编语言
    3. 高级语言可以通过编译得到汇编语言\机器语言，但汇编语言\机器语言**几乎不可能**还原成高级语言
        1. 因为高级语言写不同的代码可能汇编语言是一样的。
  
### 汇编语言的特点
1. 可以直接访问、控制各种硬件设备，比如存储器、CPU等，能最大限度地发挥硬件的功能
2. 汇编指令是机器指令的助记符,同机器指令一一对应。每一种CPU都有自己的机器指令集\汇编指令集，所以汇编语言不具备可移植性
3. 知识点过多，开发者需要对CPU等硬件结构有所了解，不易于编写、调试、维护
4. **不区分大小写**，比如mov和MOV是一样的
    
### 汇编语言的用途
1. 编写驱动程序、操作系统（比如Linux内核的某些关键部分）
2. 对性能要求极高的程序或者代码片段，可与高级语言混合使用（内联汇编）
3. 软件安全
    1. 病毒分析与防治
    2. 逆向\加壳\脱壳\破解\外挂\免杀\加密解密\漏洞\黑客
4. 是理解整个计算机系统的最佳起点和最有效途径
5. 为编写高效代码打下基础

### 汇编语言的种类
1. 目前讨论比较多的汇编语言有
    1. 8086汇编（8086处理器是16bit的CPU）
    2. Win32汇编
    3. Win64汇编
    4. AT&T汇编（Mac、iOS模拟器）
        1. 因为iOS的模拟器是运行在MAC上的，所以是MAC
    5. ARM汇编（嵌入式、iOS设备）
    6. ...
2. 入门建议先从学些8086汇编开始
    1. 结构简洁、经典
    2. 参考书籍：王爽《汇编语言》
    
### 学前须知
1. 要想学好汇编语言，首先要对CPU等硬件结构有一定的了解
2. 软件\程序的执行过程如下：
    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj02.png)
3. 最为关键的是需要了解CPU和内存
4. 在学习汇编语言过程中，遇到的绝大部分指令都是跟内存、CPU有关的
    
## 2. 总线
1. 每一个CPU芯片都有许多管脚，这些管脚和总线相连，CPU通过总线跟外部器件进行交互
2. 总线：一根根导线的集合
3. 总线的分类
    1. 地址总线
    2. 数据总线
    3. 控制总线
4. 视图：
    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj03.png)
    
5. 三种总线的使用：
    1. CPU从内存的3号单元读取数据
       ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj04.png) 
        1. 通过地址总线将3这个数据输送到内存，内存就会知道要访问第3个单元的数据
            1. 即地址总线用来寻址，寻找某个内存空间
            2. 用数电知识来解析就是存储器的哪些单元的引脚有效
        2. 控制总线告诉内存是要读取还是写这个单元，此时为读
            1. 用于控制读写
            2. 用数电的知识解析就是用来控制数据总线连接的晶闸管正向还是逆向导通。
        3. 这个时候就会通过数据总线将这个数据（08）传送给CPU。
            1. 用来传送数据
            2. 用数电的知识解析就是通过数据总线上的电平高低来获取二进制数据。
6. 地址总线
    1. 它的宽度决定了CPU的寻址能力
    2. 8086的地址总线宽度是20，所以寻址能力是1M（ 2^20  ）
7. 数据总线
    1. 它的宽度决定了CPU的单次数据传送量，也就是数据传送速度
    2. 8086的数据总线宽度是16，所以单次最大传递2个字节的数据
8. 控制总线
    1. 它的宽度决定了CPU对其他器件的控制能力、能有多少种控制

## 3. 内存
1. 各类存储器的逻辑连接情况
    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj05.png) 
    
    1. RAM与ROM区别？
        1. ROM: read Only memory 只读存储器，一般存放的以设备硬件相关的东西。
        2. RAM: 随机存储器，可读可写的。
2. 8086的内存
    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj06.png) 
    
    1. 所有的内存单元都有唯一的地址，叫做物理地址
    2. 各类存储器的物理地址情况
        1. 内存地址空间的大小受CPU地址总线宽度的限制。8086的地址总线宽度为20，可以定位2^20个不同的内存单元（内存地址范围0x00000~0xFFFFF），所以8086的内存空间大小为1MB
        2. 0x00000~0x9FFFF：主存储器。可读可写
        3. 0xA0000~0xBFFFF：向显存中写入数据，这些数据会被显卡输出到显示器。可读可写
        4. 0xC0000~0xFFFFF：存储各种硬件\系统信息。只读
3. 下图是各类存储器的逻辑连接-物理地址对应图
    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj07.png) 

## 4. 8086的寻址方式
1. CPU访问内存单元时，要给出内存单元的地址
2. 8086有20位地址总线，可以传送20位的地址，1M的寻址能力
3. 但它又是16位结构的CPU，它内部能够一次性处理、传输、暂时存储的地址为16位。如果将地址从内部简单地发出，那么它只能送出16位的地址，表现出来的寻址能力只有64KB  

    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj08.png) 
4. 8086采用一种在内部用2个16位地址合成的方法来生成1个20位的物理地址
    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj09.png) 
    
    1. CUP中的相关部件提供2个16位的地址，一个称为段地址，另一个称为偏移地址
    2. 段地址和偏移地址通过内部总线送入一个称为地址加法器的部件
    3. 地址加法器将两个16位地址合成为一个20位物理地址
    4. 地址加法器通过内部总线将20位物理地址送入输入输出控制电路
    4. 输入输出控制电路将20位物理地址送上地址总线
    5. 20位物理地址被地址总线传送到存储器
5. 地址加法器采用**物理地址= 段地址*16 + 偏移地址**的方法，用段地址和偏移地址合成物理地址。

## 5. 寄存器
1. 不同CPU的寄存器是不一样的。
    1. 8086/win32/win64/ARM的cpu的寄存器都不一样。
    2. ARM是最复杂的，因为他是嵌入式的，移动端的
2. CPU的典型构成
    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj10.png) 
    1. 对程序员来说，CPU中最主要部件是寄存器，可以通过改变寄存器的内容来实现对CPU的控制
    2. 不同的CPU，寄存器的个数、结构是不相同的（8086是16位结构的CPU）
    3. 8086有14个寄存器
        1. 都是16位的寄存器
        2. 可以存放2个字节 
            ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj11.png)
3. 通用寄存器
    1. AX、BX、CX、DX这4个寄存器通常用来存放一般性的数据，称为通用寄存器（有时也有特定用途）
    2. **通常，CPU会先将内存中的数据存储到通用寄存器中，然后再对通用寄存器中的数据进行运算**
    3. 假设内存中有块红色内存空间的值是3，现在想把它的值加1，并将结果存储到蓝色内存空间
        1. CPU首先会将红色内存空间的值放到AX寄存器中：mov ax,红色内存空间
        2. 然后让AX寄存器与1相加：add ax,1
        3. 最后将值赋值给内存空间：mov 蓝色内存空间,ax
    4. AX、BX、CX、DX这4个通用寄存器都是16位的
    5. 上一代8086的寄存器都是8位的，为了保证兼容， AX、BX、CX、DX都可分为2个独立的8位寄存器来使用
        1. H代表高位寄存器
        2. L代表低位寄存器
4. 字节与字 
    1. 在汇编的数据存储中，有2个比较常用的单位
    2. 字节：byte，1个字节由8bit组成，可以存储在8位寄存器中
    3. 字：word，1个字由2个字节组成，这2个字节分别称为字的高字节和低字节
    4. 1个字可以存在1个16位寄存器中，这个字的高字节、低字节分别存储在这个寄存器的高8位寄存器、低8位寄存器中
5. 段寄存器
    1. 8086在访问内存时要由相关部件提供内存单元的段地址和偏移地址，送入地址加法器合成物理地址
    2. 是什么部件提供段地址？段地址在8086的段寄存器中存放
    3. 8086有4个段寄存器：CS、DS、SS、ES，当CPU需要访问内存时由这4个段寄存器提供内存单元的段地址
        1. CS (Code Segment)：代码段寄存器
        2. DS (Data Segment)：数据段寄存器
        3. SS (Stack Segment)：堆栈段寄存器
        4. ES (Extra Segment)：附加段寄存器
    4. 每个段寄存器的具体作用是？
  
## 6. CS和IP
1. CS为代码段寄存器，IP为指令指针寄存器，它们指示了CPU当前要读取指令的地址
2. 任意时刻，8086CPU都会将CS:IP指向的指令作为下一条需要取出执行的指令
3. 指令执行的过程
    1. CPU根据代码段寄存器CS的值、IP寄存器的值，通过地址加法器合成20位的内存地址，传送给输入输出控制电路
    2. 输入输出控制电路通过地址地址总线将20位地址传输到内存，在内存的代码段找到对应的内存
    3. 寻址到内存中的数据通过数据总线传输给CPU的输入输出控制电路
    4. 输入输出控制电路，将数据传输给指令缓冲器
    5. 指令缓冲器将数据发送给执行控制器，执行控制指令
    6. IP寄存器自动加上一条指令的字节个数，然后执行下一条指令
       ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj12.png) 
    
    7. 通过上面的过程展示，8086CPU的工作过程可以简要描述如下
        1. 从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器
        2. IP = IP+所读取指令的长度，从而指向下一条指令
        3. 执行指令。跳转到步骤1，重复整个过程
    8. 在8086CPU加电启动或复位后（即CPU刚开始工作时）CS和IP被设置为CS = FFFFH,IP = 0000H,即在8086PC机刚刚启动时，CPU从内存FFFF0H单元中读取指令执行，FFFF0H单元中的指令是8086PC机开机后执行的第一条指令。
    9. 注意:
        1. 偏移地址IP只为CS服务，即代码段服务
        2. 而其他段（数据段、堆栈段、附加段）的偏移地址不是由IP提供
4. 指令和数据
    1. 在内存或者磁盘上，指令和数据没有任何区别，都是二进制信息
    2. CPU在工作的时候把有的信息看做指令，有的信息看做数据，为同样的信息赋予了不同的意义
    3. CPU根据什么将内存中的信息看做指令？
        1. **CPU将CS:IP指向的内存单元的内容看做指令**
        2. 取决于用哪种段寄存器来取值

## 7. jmp指令
1. CPU从何处执行指令是由CS、IP中的内容决定的，我们可以通过改变CS、IP的内容来控制CPU执行目标指令
2. 8086提供了一个mov指令（传送指令），可以用来修改大部分寄存器的值，比如：
    1. `mov ax,10、mov bx,20、mov cx,30、mov dx,40`
3. 但是，mov指令不能用于设置CS、IP的值，8086没有提供这样的功能
4. 8086提供了另外的指令来修改CS、IP的值，这些指令统称为转移指令，最简单的是jmp指令 
5. 若想同时修改CS/IP的内容，可用形如：“`jmp 段地址：偏移地址`” 的指令完成。如：
    1. `jmp 2AE3:3`,执行后：`CS=2AE3H,IP= 0003H`,CPU将从2AE33H处读取指令。
6. ”`jmp 段地址：偏移地址`“ 指令的功能为： 用指令给出的段地址修改CS,偏移地址修改IP
7. 若想修改IP的内容，可用形如“`jmp 某一合法寄存器`”的指令完成，如：
    
    ```
    jmp ax, 执行指令前：ax = 1000H，CS = 2000H,IP= 0003H
            执行指令后： ax = 1000H ，CS = 2000H,IP = 1000H
    ```
    
    1. “`jmp 某一合法寄存器`”指令的功能为： 用寄存器中的值修改IP
    2. `jmp ax` ，在含义上好似： `mov IP, AX`.
8. 另外，也可以“`jmp 直接值`”来改变IP的值，比如“`jmp 0100H`”

## 8. Debug
1. Debug是DOS/Windows都提供的实模式（8086方式）程序的调试工具。使用它，可以查看CPU各种寄存器中的内容、内内存的情况和在机器码级跟踪程序程序的运行。
2. win32系统中直接有这个工具，位置如下图。
    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj13.png) 
3. 打开方法
    1. Windows键 + R，输入debug
    2. 也可以先进入cmd，再输入debug
    3. 注意：debug里面的数值默认都是采用16进制
4. win64需要自己安装
    1. 先安装DOSBOX（搞一个假的32位环境）
    2. 将debug文件放入到C盘或者D盘的根目录下(这里放到了C盘下了)
    3. 打开DOSBox
    4. 输入：
    
        ```
        mount C C:/    //将DOSBox这个假的32位系统的C盘映射到当前系统的C盘
        C:             //进入C盘
        debug          //启动debug
        此时一闪一闪的光标，就说明已经打开debug了
        如如r就可以看看到CPU所有寄存器的值了
        ```
5. Debug的常用功能 
    1. `R`命令： 查看、改变CPU寄存器的内容
        1. 输入`r`可以查看所有寄存器的值
        2. 输入`r 寄存器名称`可以修改寄存器的值
        3. 输入`r ax`将ax寄存器的值改为0100H
            
            ```
            r ax
            1111
            r       //可以查看AX的值变化
            ```
    2. `D`命令：查看内存中的内容
        1. 输入`d`可以查看内存中的内容
        2. 输入`d 段地址:偏移地址`查看特定位置的内存数据
        3. 输入`d 段地址:起始偏移地址 结尾偏移地址`查看特定位置和特定范围的内存数据
        4. 输入`d 偏移地址`、 `d 起始偏移地址 结尾偏移地址` ，会将DS的内容作为段地址
    3. `E`命令：改写内存中的内容
        1. 输入`e 段地址:偏移地址 数据串`修改特定位置的内存数据
        2. 输入`e 段地址:偏移地址`后按Enter也可以修改特定位置的内存数据，数据之间用空格隔开
    4. `U`命令：将内存中的机器指令翻译成汇编指令
        1. 输入`u`、`u 段地址:偏移地址`可以将内存中的内容翻译为对应的汇编指令
        2. 由3部分组成
            1. 最左边一列：是指令的地址`段地址:偏移地址`
            2. 中间那一列：是指令对应的机器指令
            3. 最右边一列：是汇编指令
    5. `T`命令：执行一条机器指令
    6. `A`命令：以汇编指令的格式在内存中写入一条机器指令。
        1. 输入`a `、`a 段地址:偏移地址`可以从某位置开始写入汇编指令
    7. `q`命令：退出debug
    8. `p`命令：类似于step over（“t”命令类似于step into），可用于跳过loop循环
    9. `g`命令：跳过前面的代码，停留到指定的代码位置

## 9. DS寄存器
1. 安装8086CPU模拟器
    1. `emu8086`双击安装，然后输入注册码即可
2. CPU要读写一个内存单元时，必须要先给出这个内存单元的地址，在8086中，内存地址由段地址和偏移地址组成,格式：`段地址：[偏移地址]`
3. 8086中有一个DS段寄存器，通常用来存放要访问数据的段地址
    
    ```
    mov bx,1000h
    mov ds,bx
    mov al,[0]
    ```
    
    1. 上面3条指令的作用将10000H（1000:0）中的内存数据赋值到al寄存器中
    2. mov al,[address]的意思将DS:address中的内存数据赋值到al寄存器中
    3. 由于al是8位寄存器，所以是将一个字节的数据赋值给al寄存器
    4. 注意: 8086不支持将数据直接送入段寄存器中，mov ds,1000H是错误的
    5. 例2：
        
        ```
        ;访问内存的数据： 段地址：[偏移地址]  
        mov ax,1123h   
        ;定义数据段地址
        ;mov ds, 1000h  这句话是错误的，因为不能直接给段寄存器传值(mov) 
        ;mov 常用语内存、通用寄存器
        mov bx，1000h
        mov ds，bx  
        ;mov ds:[0h],ax  这句话可以被下面的替代，因为8086规定，不写段地址，默认为数据段 
        mov [0h]，ax
        ```

4. 大小端
    1. 就是内存存储数据的一种模式
    2. 大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中（高低\低高） (Big Endian)
    3. 小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中（高高\低低） (Little Endian)
5. 指明指令要处理的数据长度 
    1. 比如下面两条指令：
        
        ```
        mov [0h],66h   ;这句话是网内存中传递一个字节的数据
        mov [0h],0066h ;这句话是往内存中传递2个字节的数据这两者是不一样的。
        ```
    2. 8086指令能处理2种尺寸的数据：byte、word
    3. 思考：`mov [0], 20H`指令是否正确？
        
        ```
        mov byte ptr [0], 20H  将20H放入0位置内存的字节单元，占用1个字节
        mov word ptr [0], 20H  将20H放入0位置内存的字单元，占用2个字节
        ```
    4. 很多指令都可以通过“byte ptr”或者“word ptr”来指明所需要操作内存的数据长度
        
        ```
        inc byte ptr [0]
        add word ptr [0], 2
        ```
    5. 有些指令有默认的操作数据长度，比如push [0]、pop [0]的操作数据长度只能是2个字节

## 10. 栈
1. 栈：是一种具有特殊的访问方式的存储空间（后进先出， Last In Out Firt，LIFO）
2. 8086会将CS作为代码段的段地址，将`CS:IP`指向的指令作为下一条需要取出执行的指令
3. 8086会将DS作为数据段的段地址，`mov ax,[address]`就是取出`DS:address`的内存数据放到ax寄存器中
4. 8086会将SS作为栈段的段地址，任意时刻，`SS:SP`指向栈顶元素
5. 8086提供了PUSH（入栈）和POP （出栈）指令来操作栈段的数据
    1. 比如`push ax`是将ax的数据入栈，`pop ax`是将栈顶的数据送入ax
6. `push ax`
    
    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj14.png) 
    
    1. 从这张图可以看出，栈里面压入数据，sp即栈顶是从高地址相低地址下减的。
    2. push ax的执行，有以下两步骤完成：
        1. sp = sp -2，ss：sp指向当前的栈顶前面的单元，以当前栈顶前面的单元为新的栈顶；
        2. 将ax中的内容送入ss：sp指向的内存单元处，ss：sp此时指向新栈顶。
7. `pop ax`
    
    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj15.png) 
    
    1. pop ax的执行过程和push ax恰好相反
        1. 将ss：sp指向的内存单元处的数据送入ax中；
        2. sp = sp +2， ss：sp指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。 
8. 思考：
    1. 如果将10000H~1000FH这段空间当做栈，初始状态栈是空的，此时，ss = 10000H，sp=？
        
        ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj16.png) 
        
        1. 空栈，ss：sp指向栈空间最高地址单元的下一个单元
9. 栈顶超界
    1. 当栈满的时候，在使用push指令入栈，或栈空的时候在使用pop指令出栈，都将发送栈顶超界问题
    2. 栈顶超界是危险的，因为我们既然将一段空间安排为栈，那么在栈空间之外的空间里很可能存放了具有其他用途的数据、代码等，这些数据、代码可能是我们自己程序中的，也可能是别的程序中的（毕竟一个计算机系统中并不是只有我们自己的程序在运行）。但是由于我们在入栈、出栈是不小心，而将这些数据、代码意外的改写，将会引发一连串的错误。
    3. 当然我们希望cpu可以帮我们解决这个问题，比如说在CPU中有记录栈顶上限和栈底的寄存器，我们可以通过填写这些寄存器来指定栈空间的范围，然后，CPU在执行push指令的时候靠检测栈顶上限寄存器、在执行pop指令的时候靠检测栈底寄存器保证不会超界。
    4. 但是8086CPU并没有这样的寄存器，因此，我们在编程的时候要自己操心栈顶超界的问题，要根据可能用到的最大栈空间，来安排栈的大小，防止入栈的数据太多而导致超界问题；执行出栈操作的时候也要注意，以防栈空的时候继续出栈而导致的超界。


