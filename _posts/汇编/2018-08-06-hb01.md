---
layout: post
title: 第一章：CPU内部寄存器与内存
category: 汇编
tags: 汇编
description: 汇编
---

1. 目的：
    1. 针对教材补充CPU内部寄存器的知识
    2. 内存的分段与寻址
    3. **要分清楚内存跟寄存器可不是一个东西，内存是在CPU之外的存储器，寄存器是CPU内部的存储器**

## CPU的内部寄存器
1. 内部寄存器的类型 
    1. 含14个16位寄存器，按功能可分为三类
        1. 8个通用寄存器
        2. 4个段寄存器
        3. 2个控制寄存器
    2. 注意： 要深入理解每个寄存器中数据的含义
2. 通用寄存器 
    1. 通用寄存器的**一级（基本）作用：暂存中间运算结果（这是最基本的作用）**
        1. 即这8个通用寄存器不管什么情况下，里面都可以放运算结果或者中间运算结果，就是用来存放数据用的
    2. 数据寄存器（AX，BX，CX，DX）
        1. 这4个数据寄存器，可以拆开使用（1个16位拆成2个8位），目的提高运用的灵活度
        2. 一旦拆开使用它们就是独立的寄存器了，比如，AH,AL,它们之间就没有关系了。
        3. 但是如果AX是一个整体时，那么AH一定是高8位数据，AL是低8位数据。
        4. 8088/8086含4个16位数据寄存器，它们又可分为8个8位寄存器，即：
            1. AX ->AH,AL
            2. BX-> BH,BL
            3. CX->CH,CL
            4. DX -> DH,DL
        5. 这4个寄存器最常用的用法是用来存放中间运算结果
        6. 数据寄存器特有的习惯用法：（**二级作用：**）
            1. AX：累加器。所有I/O指令都通过AX与接口传送信息，中间运算结果也多放于AX中
            2. BX：基址寄存器。在**间接寻址**中用于存放基地址；（即BX中可能是运算数据，也可能是地址）
            3. CX：计数寄存器。用于在**循环或串操作**指令中存放计数值；
            4. DX：数据寄存器。在**间接寻址**的I/O指令中存放I/O端口地址；在32位乘除法运算时，存放高16位数。
    3. 地址指针寄存器（SP，BP）
        1. SP：堆栈指针寄存器，其内容为栈顶的偏移地址；
            1. 这个寄存器尽管作为通用寄存器，但是大多数情况下是作为专用寄存器来使用，即通常情况下就是使用它的**二级作用：**程序中一旦涉及到堆栈，SP**一定**是专用的，用来指向栈顶，即栈顶指针
        2. BP：基址指针寄存器，常用于在访问内存时存放内存单元的偏移地址。
            1. 跟SP的区别：BP可以指向堆栈的任意一个地方，而SP只能指向栈顶；而且在有堆栈的时候BP不一定作为专用寄存器指向堆栈某个位置，也可能是存放一般运算的中间运算数据
        3. BX与BP在应用上的区别 
            1. 作为通用寄存器（**一级作用**），二者均可用于存放数据；
            2. 作为基址寄存器（**二级作用**），用BX表示所寻找的数据在数据段；用BP则表示数据在堆栈段。
    4. 变址寄存器（SI，DI）
        1. SI：源变址寄存器
        2. DI：目标变址寄存器
        3. 变址寄存器在指令中常用于存放数据在内存中的地址
    5. 总结
        1. 这8个通用寄存器都是16位寄存器，**作为16位寄存器的时候**，他们里面的数据可以是运算的数据，可以是存放数据的地址（除了AX与CX之外，AX,CX只能存放数据。）
        2. 4个数据寄存器**作为8位寄存器**的时候，那这4个数据寄存器（AX,BX,CX,DX）存放的一定是数据，不可能是地址。
3. 控制寄存器
    1. IP:指令指针寄存器
        1. 也叫程序计数器，其内容位下一条要取指令的偏移地址
    2. FLAGS：标志寄存器
        1. 保存的是运算结果的特征。
        2. 16位中只有9位有效，又把这9位分为2类
            1. 6个状态标志位（CF,SF,AF,PF,OF,ZF）
                1. 表示运算结果的特征。
            2. 3个控制标志位（IF,TF,DF）
                2. 表示处理器当前的工作状态
        3. 状态标志位：
            1. CF（Carry Flag） 
                1. 进位标志位。加(减)法运算时，若最高位有进(借)位则CF=1 
            2. PF（Parity Flag）
                2. 奇偶标志位。运算结果的低8位中“1”的个数为偶数时PF=l 
            3. AF（Auxiliary Carry Flag）
                1. 辅助进位标志位。加(减)操作中，若Bit3向Bit4有进位(借位)，AF=1 
            4. ZF（Zero Flag）
                2. 零标志位。当运算结果为零时ZF=1 
            5. SF（Sign Flag）
                1. 符号标志位。当运算结果的最高位为1时，SF=l 
            6. OF（Overflow Flag）
                2. 溢出标志位。当算术运算的结果超出了有符号数的可表达范围时，OF=l  
        4. 控制标志位
            1. TF（Trap Flag）
                1. 陷井标志位，也叫跟踪标志位。TF=1时，使CPU处于单步执行指令的工作方式。
            2. IF（Interrupt Enable Flag）
                1. 中断允许标志位。IF=1使CPU可以响应可屏蔽中断请求。
            3. DF（Direction Flag）
                1. 方向标志位。在数据串操作时确定操作的方向。 
4. 段寄存器
    1. 作用：
        1. **内存**被分为很多逻辑段，但是类型只有四种（数据、代码、附加、堆栈）
        1. 用于存放**内存中**相应逻辑段的段基地址（就是该段的首地址）
        2. 就是为了寻址的：段基地址*16 + 偏移地址 = 物理地址
        3. 这些段寄存器初始化在程序启动内存分配后
    2. 8088/8086**内存中**的逻辑段类型（逻辑段有很多，但是类型只有四种）
        1. 代码段：存放指令代码
        2. 数据段： 存放操作的数据
        3. 附加段：存放操作的数据
        4. 堆栈段： 存放暂时不用但需保存的数据
    3. 内存中这4中类型的段，就要对应每个段的段地址，那么段地址放在哪呢？ --> **段寄存器**
        1. 代码段寄存器（CS）： 存放代码段的段基地址。
        2. 数据段寄存器（DS）：存放数据段的段基地址。
        3. 附加段寄存器（ES）：存放数据段的段基地址。
        4. 堆栈段寄存器（SS）：存放堆栈段的段基地址
    4. 问题：
        2. 既然上面说，内存可以被分为n个段，但是类型只有4种，但是段寄存器智能存放4个类型的段地址，那怎么办呢？（比如内存中分别有4个代码、数据、附加、堆栈段，那么段基地址就有16个，那么段寄存器只有4个，放不下）
        3. 解决办法:
            1. 由于段寄存器只有4个，而且是每一种一个，那么就决定了：**一个程序模块里最多只能有4个逻辑段，而且每个逻辑段都是唯一的！！！**
            2. 通俗点来说，内存中分了n个代码段，n个堆栈段，n个数据段，n个附加段，我写了个app程序，但是这个app程序，内存只会给他分配1个代码段，1个堆栈段，1个数据段，1个附加段，
            3. 而且每个段的首地址（段基地址）放在了CPU的事个段寄存器中
            4. 因此段寄存器的值表明响应逻辑段在内存中的位置
   5. 什么是逻辑段？ 为什么要分段？ 
   
## 内存： 实模型下的存储器寻址（重要！！！）
1. 要点：
    1. 内存分段管理思想
    2. 实模式下的内存地址变换
    3. 段寄存器的应用
    4. 堆栈段的概念
    
### 内存储器管理
1. 8086CPU是16位体系结构的微处理器
2. 可以同时处理（产生）16位的二进制码
    1. 可以产生64k个编码
    2. 直接管理64k个内存单元
3. 8086CPU需要管理1MB内存
    1. 需要能够产生1M个地址编码，那就需要20位的处理器
    2. 那用16位的该如何实现呢？---内存分段管理
        1. 将内存分为n个逻辑段（相当于把楼分为n层）
        2. 每个逻辑段的编号即唯一码叫做段基地址，也用16位表示
        3. 再用一个16位表示段的偏移地址（房间号）
        4. 那么内存的唯一地址（每个房间）就可以通过段地址（楼层）与段偏移地址（房间号）合成表示出来
        5. 若要产生20位的地址，那么就需要将段地址（16位）、段偏移地址（16位）合成一个20位的地址
        6. 合成方法： 段地址 * 16 + 段偏移地址 = 物理地址
        7. 总结，8086CPU是通过将两个16位地址通过**地址加法器**合成20位来实现管理1M的内存

### 内存地址变换
1. 欲实现对1MB内存空间的正确访问，每个内存单元在整个内存空间中必须具备唯一地址---物理地址
2. 内存地址变换的作用： 如何将将直接产生的16位编码变换为20位物理地址
3. 内存单元的编址：
    1. 每个内存单元的地址在逻辑上都由两部分组成
        1. 段（基）地址
            1. 指示存储单元在整个内存空间中处于哪个区域
        2. 段内地址（相对地址、偏移地址）
            1. 指示存储单元在段中的相对位置（与段中第一个单元的距离）
        3. 举例：
            1. 段：相当于楼层号
            2. 段内地址：相当于某个楼层的第几个放假
            3. 305：第三层，第5个房间
    2. 8086为16位结构，所以段地址和偏移地址均为16位
    3. 段基地址
        1. 决定存储单元在内存中的位置
    4. 相对地址（偏移地址）
        1. 该存储单元相对段内第一个单元的距离
    5. 逻辑段的起始地址称为段首
        1. 每个逻辑段内的第一个单元
        2. 段首的偏移地址为：0000H
    6. 内存的物理地址由段基地址和偏移地址组成
        1. 物理地址： 内存单元在整个内存空间中的唯一地址
        1. 物理地址 = 段地址*16（左移动4位）+ 偏移地址。
4. 逻辑段与逻辑地址
    1. 内存的分段是逻辑分段，不是物理分段。 各个逻辑段在地址上可以不相连、可以部分重合，也可以完全重合。（逻辑段比物理段节省内存）
    2. 每个内存单元具有唯一物理地址，但可能具有多个逻辑地址。即：
        1. 一个内存单元可以同时处于2个逻辑段
        2. 一个内存单元可以在不同的时刻属于相同（或不同）类型的段。  
        3. 一个内存单元在同一时刻可以属于不同类型的段        

### 为什么要分成逻辑段？ 
1. 计算机都是有操作系统统一管理的，操作系统把你编好的程序调入到内存的时候，总体原则是见缝插针式的，看见内存那块有空就插入
2. 我们编写好的程序都是放在硬盘中，要想运行程序，必须要加载到内存，成为进程才有可能执行，到内存后会根据你程序的大小以及内存的现实情况，见缝插针的放入，内存中有可能不是一整块区域的，因此要把你的程序切分分别存放，但是每块之间是关联的。
3. 综上所述，当你的程序由操作系统加载到内存后，段基地址也是有操作系统决定的，他决定把你的程序插入哪里，不是人为能控制的，即：段基地址是我们程序员无法控制的，因为段基地址决定了你的程序存储在那个区域里，而存储的过程是操作系统决定的。
4. 因此我们编写程序的时候我们无法编辑段基地址，我们只能操作偏移地址。

### 逻辑段说明；
1. 同一程序模块装入主存时，不同类型的段可以装入在相同、不同的物理空间（两个逻辑段完全或部分重合）
2. 两个不同程序模块装入主存时，同一类型的逻辑段也可以装入到相同或不同的物理空间中

### 堆栈段及堆栈段的使用
1. 堆栈
    1. 内存中一个特殊的区域，用于存放暂时不用或者需要保护的数据
    2. 常用于响应中断或子程序调用


