---
layout: post
title: 第二章：8086/8088的指令系统（二）
category: 汇编
tags: 汇编
description: 汇编
---

## 8086指令系统
1. 从功能上包括6大类：
    1. 数据传送
    2. 算术运算
    3. 逻辑运算和移位
    4. 串操作
    5. 程序控制
    6. 处理器控制
2. 学习指令的时候要注意一下几点：
    1. 指令码的含义
    2. 指令对操作数的要求
    3. 指令的对标志位的影响
    4. 指令的功能

### 数据传送指令
1. 分为下面四小类
    1. 通用数据传送
    2. 输入输出
    3. 地址传送
    4. 标志位操作
2. 注意： 除了**标志传送指令**外其他指令的执行对**标志位**不产生影响。

#### 通用数据传送指令
1. 分为如下几小类
    1. 一般数据传送指令
    2. 堆栈操作指令
    3. 交换指令
    4. 查表转换指令
    5. 字位扩展指令
2. 一般数据传送指令MOV
    1. 格式：MOV dest ，src
    2. 操作： 将操作数src复制传送到操作数dest，即src->dest
    3. 注意点：
        1. 两操作数字长必须相同；
        2. 两操作数不允许同时为存储器操作数；
        3. 两操作数不允许同时为段寄存器；
        4. 在源操作数是立即数时，目标操作数不能是段寄存器；
        5. IP和CS不作为目标操作数，FLAGS一般也不作为操作数在指令中出现。
    4. **注意了：前说过段寄存器的初始化不能由程序员控制，但是初始化之后可以**
    5. 举例：（略）
3. 堆栈操作指令
    1. 堆栈是内存中一段特定的存储区域，常用来存放中断断点，调用子程序的调用现场，程序运行中需要临时保存的数据等内容。对堆栈区间的访问遵循“先进后出”的原则
    2. 8086、8088微机中堆栈的段基址是由堆栈寄存器SS确定的，而堆栈区间的具体大小是由用户在程序中指定的，在微机中用堆栈指针SP表示，SP始终指向堆栈顶部（栈顶）。
    3. 堆栈操作的原则：
        1. 先进后出
        2. 以**字**（2个字节）为单位，也就是说堆栈操作的操作数一定为16位。
    4. 堆栈操作指令（ OPRD:可以为16位的寄存器，或者内存的2个单元。）
        1. 压栈指令
            1. 格式： `PUSH OPRD`
            2. 功能： 将指定的寄存器或存储单元的内容存入到栈顶
            3. 执行过程：
                1. SP-1 ->SP,然后操作数的高位字节送至SP所指向的单元
                2. SP-1-> SP,然后操作数的低位字节送至SP所指向的单元
        2. 压栈指令
            1. 格式： `pop OPRD`
            2. 功能： 将栈顶的数据复制到指定的寄存器或内存单元中
            3. 执行过程：
                1. SP所指向单元的数据送至操作数的低位字节,SP+1 -> SP
                2. SP所指向单元的数据送至操作数的高位字节，SP+1 -> SP
        3. 举例：
        
            ```
            1. 压栈
                PUSH AX
                若此时（AX） = 1234H, (SS) = 2000H, (SP) = 0100H,则指令的执行流程如下：
                第一步： SP-1 -> SP,即（SP） = 00FFH, (200FFH) = 12H;
                第二步： SP-1 -> SP,即（SP） = 00FEH, (200FEH) = 34H;
                
            2. 出栈
                POP [BX]
                若此时（BX）= 0010H,(SS) = 2000H,(DS) = 3000H,(SP) = 00FEH,则指令执行过程如下：
                第一步：（SP）->(30010h),SP+1->SP,即(SP) = 00FFH;
                第二步：（SP）->(30011h),SP+1->SP,即(SP) = 0100H;
            ```
        4. 标志压栈指令
            1. 指令格式： `PUSHF`
            2. 功能： 将标志寄存器FR的内容存入到栈顶
        5. 标志出栈指令
            1. 指令格式：`POPF`
            2. 功能： 将SP所指向的栈顶子单元的内容送至标志寄存器FR.
        6. 栈操作指令说明：
            1. 指令的操作数必须是16位
            2. 操作数可以是寄存器或存储器2个单元，但不能是立即数
            3. 不能从栈顶弹出一个字给CS；
            4. PUSH和POP指令在程序中一般成对出现；
            5. PUSH指令的操作方向是从高地址向低地址，而POP指令的操作正好相反。
4. 交换指令
    1. 指令格式: `XCHG dest, src`
    2. 功能： 将目的操作数dest与源操作数src的内容相互交换。
    3. 注意： 
        1. 两个操作数必须有一个是寄存器操作数
        2. 不允许使用段寄存器。
        3. 2个操作数位数必须相同。
5. 查表指令：
    1. 指令格式：`XLAT 或 XLAT 表首地址`
    2. 功能：((BX) + (AL) -> (AL)),把内存**数据段**中的一个字节的数据复制进AL,该数据的偏移地址是(BX)+(AL)
    3. 可以把内存数据段中以BX为偏移地址的一段连续的存储空间看成是一张表，而AL是表中具体数据项距表头的唯一量（索引值）。只要知道了这个位移量，就能利用XLAT指令方便地找到表中的数据。
    4. 说明： 用BX的内容代表表格首地址，AL内容为表内偏移量，BX+AL得到要查找元素的偏移地址
    5. 操作：将BX+AL所指向单元的内容送AL
6. 字位扩展指令
    1. 作用：将8位扩展为16位，或者将16位扩展为32位
    2. 前提：
        1. 全部针对的是有符号数的扩展
        2. 将符号数的符号位扩展到高位
        3. 指令位零操作数指令，采用隐含寻址，隐含操作数为AX及AX,DX
        4. 无符号数的扩展规则为在高位补0
    3. 字到字节的扩展指令
        1. 格式：`CBW`
        2. 操作： `将AL内容扩展到AX`
        3. 规则： 若最高位=1，则执行后AH=FFH;若最高位=0，则执行后AH = 00H;
    4. 将字扩展到双字的扩展指令
        1. 格式： `CWD`
        2. 操作： 将AX内容扩展到DX AX
        3. 规则： 若最高位=1，则执行后DX=FFFFH;若最高位=0，则执行后DX = 0000H;


