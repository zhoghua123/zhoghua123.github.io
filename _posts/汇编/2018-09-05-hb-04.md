---
layout: post
title: 第二章：8086/8088的指令系统（三）
category: 汇编
tags: 汇编
description: 汇编
---


## 注意： 本节都是比较难理解的指令

### 串操作指令
1. 简介
    1. 计算机在处理数据时，经常要对一组数据进行处理，这样的一组数据称为数据串
    2. 由字节组成的数据串称为字节串；同理由字组成的数据串最长可达64KB。
    3. 针对数据块或者字符串的操作。
    4. 可实现存储器到存储器的数据传送
2. 8086/8088指令系统中有专门的串操作指令，可以对数据串进行多种操作，但所有串操作指令必须遵循一些基本的规则。
    1. 无论是字节串还是字串，所处理数据的**个数**都存放在**CX**中，在有**串前缀**的前提下，每执行一次操作CX自动减1，直至减到0，串操作自动停止； 如果**没有串前缀**，需要有指令设置并判断CX。     
    2. 串操作指令的源操作数src和目的操作数dest都在内存中，是唯一一条从内存到内存的指令。串所在的区域及首地址：
        1. 源串**一般**存放在数据段，偏移地址由SI指定，即DS:[SI]，支持段超越
        2. 目的串**必须**在附加段，偏移地址有DI指定，即ES:[DI]
    3. 在串操作前要首先设置方向标志位DF。当DF = 1，指示源和目的操作数位置的偏移地址（SI）和（DI）自动由高至低，减量进行串操作，当串为字节串时，每操作一次，（SI）和（DI）减1，当串为字串时，每操作一次，（SI）和（DI）减2； 当DF = 0时，指示源和目的操作数位置的偏移地址（SI）和（DI）自动由低至高，增量进行串操作，当串为字节串时，每操作一次，（SI）和（DI）加1，当串为字串时，每操作一次，（SI）和（DI）加2
    4. 串前缀：（重复前缀）
        1. 无条件重复
            1. REP
            2. 当CX != 0时，REP后的指令将继续重复执行
            3. 常用于传送类指令前：未传完则继续传送
        2. 条件重复
            1. 相等（相减为零）重复： REPE(REPZ)
                1. CX != 0 && ZF == 1，则前缀后的指令将继续重复执行。
            2. 不相等（相减不为零）重复： REPNE(REPNZ)
                1. CX != 0 && ZF == 0，则前缀后的指令将继续重复执行。
            3. 条件前缀常用于运算类指令前，两个数的比较
3. 串操作指令实际流程
    1. 取源串地址
    2. 取目标串地址
    3. 设串长度
    4. 设操作方向
    5. 完成一个字节或字操作
    6. 修改地址指针
    7. 修改串长度值
    8. 判断是否完成
    9. 没完成回到第5步
    10. 完成结束

#### 串传送指令
1. 格式：`MOVSB ;字节传送  MOVSW ;字传送`
2. 指令功能：
    1. 将位于DS段，由（SI）所指出的存储单元的字节或字数据传送到位于ES段，由（DI）所指的存储单元中，即DS:[SI]->ES:[DI],若DF=1,(DI)-n->(DI),(SI)-n->(SI);若DF = 0,(DI)+n->(DI),(SI)+n->(SI).
    2. 其中，当使用指令MOVSW时，n=1；使用指令MOVSW时，n=2。
3. 串传送指令常于无条件重复前缀连用

#### 串比较指令
1. 格式：`CMPSB;字节比较 CMPSW ;字比较`
2. 指令功能：（目标串-源串，结果丢弃）
    1. 将位于DS段由（SI）所指出的存储单元的字节或字数据与ES段由（DI）所指的字节或字数据相比较，比较结果仅影响标志位。
    2. 通过串前缀REPZ的控制，可以在两个数据串中寻找第一个不相等的字节或字数据；
    3. 通过串前缀PEPNZ的控制，可以在两个数据串中寻找一个相等的字节或字数据。

#### 串检索指令
1. 格式：`SCASB;字节 SCASW ;字`
2. 功能：
    1. 将AL或AX中的值与位于ES段由(DI)所指出的存储单元中的字节或字数据进行比较，比较结果仅影响标志位
    2. 通过串前缀REPZ的控制，可以在数据串中寻找第一个与AL或AX不相等的字节或字数据；
    3. 通过串前缀REPBZ的控制，可以在数据串中寻找第一个与AL或AX相等的字节或字数据；
    4. 比较之后自动按照串操作指令的规则修改操作数地址指针。即（AL）-ES: [DI]或(AX)-ES:[DI+1][DI],若DF = 1,(DI)-n->(DI);若DF = 0,(DI)+n->(DI),其中，字是n = 2，字节n = 1；

#### 读数据串指令
1. 格式： `LODSB;字节 LODSW ;字`
2. 功能：
    1. 将位于DS段由（SI）所指出的存储单元的字节或者字数据传送至（AL）或（AX），并自动按照串操作指令的规则修改操作数地址指针。
    2. 即： DS:[SI]->(AL)或 DS:[SI+1][SI]->(AX),若DF = 1,(SI)-n ->(SI); 若DF = 0,(SI)+n -> (SI) ; n 同上

#### 写数据串指令
1. 格式： `STOSB;字节 STOSW ;字`
2. 指令功能：
    1. 将AL或AX中的字节或字数据写入位于ES段由（DI）所指出的存储单元中，并自动按照串操作指令的规则修改操作数地址指针。
    2. 即 （AL）->ES:[DI] 或 （AX）->ES:[DI+1][DI],若DF=1,(DI)-n->(DI);若DF=0,(DI)+n->(DI).

### 程序控制类指令
1. 简介：
    1. 指令存储在内存的代码段，8086、8088执行的指令地址是由代码寄存器CS和指令指针IP的内容确定的，CPU运行码段CS：IP所指向的那条指令。
    2. 一般情况下，CPU在执行完当前指令后会自动顺序执行下一条指令，此时，下一条指令的偏移地址IP是由控制器自动给出的。
    3. 控制转移类指令用来改变程序的正常执行顺序，这种改变是通过改变代码段的段基址CS和偏移地址IP的内容而实现的。
    4. 转移分为段内转移和段间转移两类。
        1. 段内转移，转移的目标地址与当前地址在同一个代码段内，即只需要改变指令指针IP的内容就可实现转移，而不用改变CS的值。转移的范围在64KB之内，即偏移地址IP的范围。也就是说转移的相对偏移量为16位二进制数，取值范围为-32768~32767
        2. 段间转移，转移的目标地址与当前地址不在同一个代码段内，需要同时改变CS和IP的内容才可寻址到新的指令地址。
    5. 转移的方式分为直接转移和间接转移两类
        1. 直接转移：在指令操作数中直接给出转移的目标地址（一般用标号的形式）。
        2. 间接转移： 转移的目标地址存放在寄存器或内存单元中。
        3. 注意： 所有的转移类指令均不影响状态标志位。
    6. 跳转或者转移的目标地址距离当前的正常指令的地址偏移量称为**相对偏移地址**
2. 程序控制类指令的本质是： 
    1. 控制程序的方向
3. 决定程序执行方向的因素
    1. CS/IP
    2. 修改IP，会使程序改变在当前代码段中的执行顺序
    3. 同时修改CS和IP，会使程序走向另一个代码段执行
4. 程序控制类指令以“隐含”的方式修改CS和IP,以实现控制程序走向的目的（**Intel指令集不允许由指令直接修改CS和IP**）
5. 通过修改IP或CS和IP，实现程序的三种基本控制结构
    1. 顺序，选择（分支），循环
6. 学习程序控制类指令需要重点关注：
    1. **如何实现对CS和IP的修改？**
7. 程序控制类指令类型：
    1. 转移指令
    2. 循环指令
    3. 过程调用
    4. 中断控制

#### 转移指令
1. 通过修改指令的偏移地址或段基地址+偏移地址实现程序转移。
2. 分为2小类
    1. 无条件转移类指令
        1. 无条件转移到目标地址
    2. 条件转移类指令
        1. 一定条件才会转移（条件通常指状态标志位）
3. 无条件转移指令
    1. 无条件段内直接转移指令
        1. 指令格式： `JMP 目标地址标号`
        2. 指令功能：代码段的基地址CS不变，偏移地址IP由当前地址变成目标指令处的偏移地址，从而实现程序的转移跳转
        3. 尽管改指令的操作数是语句标号或指令标号，但实际上的操作数是**相对偏移量**，即编译程序首先根据**目标地址**计算出距离**当前指令**的**相对偏移量**，然后将这个相对偏移量放在**操作码**后，所以改指令执行的操作是： （IP）+相对偏移量 -> (IP).
        4. 如果相对偏移量是8位二进制数的范围（-128~127），则该指令为**二字节指令**，即1字节为操作码0EBH和1字节操作数；如果相对偏移量是16位二进制数的范围（-32768~32767），则该指令为**三字节指令**，即1字节的操作码0E9H和2字节的操作数
        5. 注意： JMP指令的相对偏移量是有编译程序自动计算的，用户只需要把目标地址的标号写在程序中就可以了。
        6. 举例： 
            
            ```
            假设目标地址标号为LABLE,位于码段的2300H处，指令JMP LABLE 位于码段的2308H处，执行该指令后偏移地址IP的值是多少？ 相对偏移量是多少？ 
            JMP LABLE 为段内直接转移指令，执行后（IP） = 2300H;
            由于2300H距离2308H的相对偏移量不足1个字节的范围，故该指令是2个字节指令，按正常顺序执行JMP LABLE 后的IP 值应为（IP） = 230AH,故2者的相对偏移量是-10，即为1字节补码0F6H,通过符号扩展为0FFF6H，因此，（IP）+相对偏移量 = 230AH+ FFF6H = 2300H ->新（IP）.
            ```
    2. 无条件段内间接转移指令
        1. 格式： `JMP dest`
        2. 指令功能：码段的基地址CS不变，偏移地址IP由当前地址变成由**寄存器**或**存储器**寻址的目标偏移地址，从而实现程序的转移跳转。
        3. 其中dest是寄存器或存储器操作数。
    3. 无条件段间直接转移指令。
        1. 格式： `JMP 目标地址处标号（是远标号）`
        2. 码段的基址CS变成目标地址处的段基址，偏移地址变成目标地址处的偏移地址，从而实现程序的跨段的转移跳转。
        3. 注意：该指令不计算相对偏移量，直接将目标地址的段属性和偏移地址属性赋值给CS和IP即可。
    4. 无条件段间间接转移指令
        1. 格式： `JMP dest`
        2. 指令功能：目标地址的段基址和偏移地址存放于存储器的4个连续地址中，其中前2个字节为偏移地址，后2个字节为段基址，在指令中给出的是存放目标地址的4个连续字节的首地址的偏移地址。
        3. 注意： dest 只能有内存储器给出了，不能有寄存器给出了。
4. 条件转移指令

