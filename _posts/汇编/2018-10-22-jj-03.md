---
layout: post
title: 汇编进阶- 知识整合（三）
category: 汇编
tags: 汇编
description: 汇编
---

## 16. 函数的本质

### call和ret指令 
1. **8086/8088的指令系统（三）-过程调用和返回指令,这节有详细说明该指令**
2. call 标号：
    1. 将下一条指令的偏移地址入栈后
    2. 转到标号处执行指令
3. ret：将栈顶的值出栈，赋值给ip
4. call和ret联合使用的作用其实就是高级语言中的函数调用
5. 实践，考虑以下几种情况
    1. 有无参数
    2. 有无返回值
    3. 现场保护
    4. 局部变量
    5. 堆栈平衡

### 函数返回值
1. 函数返回值几种常见的存放方式如下:
    
    ```
    assume cs:code, ds:data, ss:stack

    ; 栈段
    stack segment
        db 100 dup(0)
    stack ends  
    
    ; 数据段
    data segment  
        a dw 0
        db 100 dup(0) 
        string db 'Hello!$'
    data ends
    
    ; 代码段
    code segment
    start:
        ; 手动设置ds、ss的值
        mov ax, data
        mov ds, ax
        mov ax, stack
        mov ss, ax  
        
        ; 业务逻辑 
        call mathFunc3
        
        mov bx, ax  
        
        ; 退出
        mov ax, 4c00h
        int 21h 
        
    ; 返回2的3次方
    ; 返回值放到ax寄存器中
    ; 这种方式是最常见的方式，基本上所有的平台（linx、mac、iOS、安卓等）都会把函数的返回值
    ; 默认放在AX中     
    mathFunc3:  
        mov ax, 2
        add ax, ax
        add ax, ax 
        
        ret 
    
    ; 返回2的3次方
    mathFunc2:  
        mov ax, 2
        add ax, ax
        add ax, ax 
        ; 返回值放到a中  
        mov a, ax
        
        ret  
        
    ; 返回2的3次方  
    mathFunc1:  
        mov ax, 2
        add ax, ax
        add ax, ax 
        ; 返回值放到ds:0中  
        mov [0], ax
        
        ret 
                    
    code ends  
    
    end start
    ```
2. 总结；
    1. 基本上所有的平台（linx、mac、iOS、安卓等）都会把函数的返回值默认放在AX中
    2. 因为AX本身就在CPU中，不需要去到内存中存取，效率高。

### 函数的参数
1. 函数传参如下：
    
    ```
    assume cs:code, ds:data, ss:stack

    ; 栈段
    stack segment
        db 100 dup(0)
    stack ends  

    ; 数据段
    data segment  
        db 100 dup(0) 
    data ends

    ; 代码段
    code segment
    start:
        ; 手动设置ds、ss的值
        mov ax, data
        mov ds, ax
        mov ax, stack
        mov ss, ax  
        
        ; 业务逻辑
        push 1122h
        push 3344h 
        call sum3 
        add sp, 4
        
        ;寄存器传参
        mov cx, 1122h 
        mov dx, 2233h 
        call sum1 
        
        ;数据段内存传参
        mov word ptr [0], 1122h 
        mov word ptr [2], 2233h 
        call sum2  
        
        ; 退出
        mov ax, 4c00h
        int 21h 
        
    ; 返回值放ax寄存器
    ; 传递2个参数(放入栈中)
    ; 最常用的方法   
    sum3:   
        ; 访问栈中的参数  
        ; SS: [sp + 2] 这样是错误的，因为语法不允许这样写，只能用BP
        mov bp, sp
        mov ax, ss:[bp+2]
        add ax, ss:[bp+4]
        ret 
              
    ; 返回值放ax寄存器
    ; 传递2个参数(分别放ds:0、ds:2)    
    sum2:         
        mov ax, [0]
        add ax, [2]
        ret 
                
    ; 返回值放ax寄存器
    ; 传递2个参数（分别放cx、dx中）    
    sum1:  
        mov ax, cx
        add ax, dx
        ret 
                    
    code ends  
    
    end start
    ```
2. 总结
    1. 最常用的方式就是使用栈传参
    2. 但是我们知道调用函数前会将函数的下一条指令偏移地址存入栈中，函数退出时也会弹出那个偏移地址给IP
    3. 那么怎么办呢？ 
    4. 部分代码如下：（下面这段代码，即使是监听C语言的反汇编，也是同样的代码）
        
        ``` 
        push 1122h
        push 3344h 
        call sum3 
        add sp, 4
        ```
        
        1. 图片分析
            ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj17.png)
        2. 有图片可知，因此可以理解下面函数的处理：
            
            ```
            sum3:   
            ; 访问栈中的参数  
            ; SS: [sp + 2] 这样是错误的，因为语法不允许这样写，只能用BP
            mov bp, sp
            mov ax, ss:[bp+2]
            add ax, ss:[bp+4]
            ret 
            ``` 
            
#### 栈平衡
1. 从上面的代码看出，函数调用完毕之后，栈中会多了两个参数占用内存
2. 这样的话，栈空间早晚会被用完的
3. 同时也不符合，函数调用完毕之后局部变量自动销毁的功能
5. **栈平衡：函数调用前后的栈顶指针要一致**
6. 栈如果不平衡的结果：栈空间迟早会被用完
7. 因此在函数调用完毕之后要将栈回到原位置
    
    ```
    add sp, 4
    ```
    
    1. 栈一回到原来的位置，尽管那些数据还存在栈中，但是已经是垃圾数据，下一次使用时会自动覆盖掉这些数据。 

