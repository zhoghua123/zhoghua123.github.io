---
layout: post
title: 汇编五 - 汇编语言补充
category: 汇编
tags: 汇编
description: 汇编
---

## 知识点

1. 学习环境为什么要选择VC6?
    1. 为了更好地学习细节，因为越是高版本的开发环境，在编译的时候替我们添加的额外代码越多，不利于我们学习
    2. 凡是搞底层的人开发环境一定是VC6
2. UltraEdit
    1. 用于查看二进制文件的一款PC软件。
3. 熟练背会二进制与16进制之间的对应关系。
4. 数据宽度
    1. 数学上的数字，是没有大小限制的，可以无限的大。但在计算机中，由于受硬件的制约，数据都是有长度限制的（我们称之为数据宽度），超过最多宽度的数据会被丢弃。
    2. 计算机中常见的数据宽度
        1. 位:bit，一个二进制位 
        2. 字节(byte)：8个bit，至少
        3. 字(word)：16个bit
        4. 双字(doubleword)：32个bit
5. 原码、反码、补码
    1. 正数：三码合一
    2. 负数：
        1. 反码：符号位不变，其余所有二进制码取反。
        2. 补码：符号位不变，其余所有二进制码取反，然后再加1.
        3. 补码的补码等于源码。
    3. 计算机在内存中以补码的方式存储。
    4. 16位存储的方式
        ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbbc01.png) 
        1. 无符号数存储的范围：0~FF
        2. 有符号数存储的范围：
            1. 正数：0~7F
            2. 负数：FF~80
            3. 一个圆形被分割成2半，左边负数，右边正数。(注意，负数都是补码的形式存储的，FF就是-1)
6. 计算机只会做位运算（与、或、非、异或、左移、右移动），不会四则运算
    1. 加：(计算机使用位运算实现加法)
        1. 2个数先异或,结果为X
        2. 判断是否有进位，用与判断，将2个数与的结果有值为Y，则说明有进位，没有值则没有进位
            1. 没有进位，这异或的结果X就是加法的值。
            2. 有进位
                1. 将Y左移一位，然后与X异或，得结果为Z
                2. 再次执行2，进行判断，直到没有进位，得到最终结果。
    2. 减：
        1. 本质还是加法运算
        2. 4-5 => 4+ (-5).
        3. -5的补码为FB
    3. 乘：本质是加法
    4. 除：本质是减法
    5. 如下图：
        ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbbc02.png) 
7. 学汇编的目的是为了了解程序运行的原理。
    1. 当学习一种新语法，不太理解时
    2. 直接转化成汇编，就能看到本质。
8. 配置汇编的学习环境
    1. 下载DTDEBUG
        1. 百度搜索下载`DTDebug(VT-O)专业版V1.0.025`
    2. 配置路径。
        1. 下载之后解压，打开文件夹,然后打开DTDebug文件夹
        2. 双击DTDebug.exe
        3. 然后，选择工具栏->options->appearance->Directories
        4. 设置udd路径，找到DTDebug文件加下的udd文件即可。
        5. 设置plugin路径，找到DTDebug文件加下的plugin文件即可。
        6. 然后关闭重新打开DTDebug即可。
    3. 窗口简介
        1. 工具栏打开View->CPU,然后展示一个窗口，这个窗口有4个区域
        2. 第一个区域：通常用于写汇编代码的区域，叫反汇编窗口
        3. 第二个区域：register(FPU),寄存器窗口。
        4. 第三个区域：左下角，为内存窗口
        5. 第四个区域：右下角，堆栈窗口
    4. 常用快捷键：
        
        ```
        F8 :单步执行
        ```
        
        
## 寄存器
1. 寄存器有多大？
    1. 32位CPU: 8位、16位、32位，3种
    2. 64位CPU: 8位、16位、32位，64位，4种。
2. 当前计算机的cup是多少位？
    1. 05年以后买的电脑都是64位的。
3. 为何要学32位的汇编？
    1. 因为64位就是从32位拓展过来的，并没有整体变化。
    2. 只是增加了一些寄存器，汇编指令还是一样的。

### 通用寄存器
1. 32位通用寄存器,共8个，每个32位
    
    ```
    EAX     ESP
    EBX     EBP
    ECX     ESI
    EDX     EDI
    ```
2. 所有的通用寄存器
    
    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbbc03.png) 
    
    1. 注意观察：ESP/EBP/ESI/EDI,这四个没有8位的寄存器。
    2. AH/BH/CH/DH分别是由AX/BX/CX/DX的高八位。

## 内存
1. **虚拟内存映射到物理内存，注意物理内存还不是内存条，他还需要再一次映射到内存条中。**
    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbbc04.png) 
2. 内存地址32位
3. 往内存中写数据时一定要注明宽度
    
    ```
    mov byte ptr ds:[0018fff0],1
    常见宽带：BYTE /WORD /DWORD
    ```

### 内存地址在汇编中的5种表示形式
1. 形式一：`[立即数]`
    
    ```
    //从内存中读取数据
    MOV EAX,DWORD PTR DS:[0X13FFC4]
    //向内存中写入数据
    MOV DWORD PTR DS:[0X13FFC4] EAX,
    ```
2. 形式二：`[reg]` reg代表寄存器，可以是8个通用寄存器中的任意一个。
    
    ```
    读取内存的值：
    ;立即数（内存地址）传到ECX寄存器
    MOV ECX,0X13FFD0
    ;速去内存的值
    MOV EAX,DWORD PTR DS:[ECX]
    
    向内存中写入数据
    MOV EDX,0X13FFD8
    ;将立即数存入内存
    MOV DWORD PTR DS:[EDX],0X87654321
    ```
3. 形式三：`[reg+立即数]`
    
    ```
    读取内存的值：
    MOV ECX,0X13FFD0
    ;速去内存的值
    MOV EAX,DWORD PTR DS:[ECX+4]
    
    向内存中写入数据
    MOV EDX,0X13FFD8
    ;将立即数存入内存
    MOV DWORD PTR DS:[EDX+0xC],0X87654321
    ```
4. 形式四：`[reg+reg*{1,2,4,8}]`
    1. 乘的数字只能是1、2、4、8
        
    ```
    读取内存的值：
    MOV EAX,13FFC4
    MOV ECX,2
    MOV EDX,DWORD PTR DS:[EAX+ECX*4]
    ```
5. 形式五：`[reg+ret*{1,2,4,8}+立即数]`
    
    ```
    读取内存的值：
    MOV EAX,13FFC4
    MOV ECX,2
    MOV EDX,DWORD PTR DS:[EAX+ECX*4+4]
    ```


