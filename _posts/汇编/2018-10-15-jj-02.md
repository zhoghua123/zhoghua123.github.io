---
layout: post
title: 汇编二 - 寄存器、栈
category: 汇编
tags: 汇编
description: 汇编
---


## 寄存器
1. 不同CPU的寄存器是不一样的。
    1. 8086/win32/win64/ARM的cpu的寄存器都不一样。
    2. ARM是最复杂的，因为他是嵌入式的，移动端的
2. CPU的典型构成
    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj10.png) 
    1. 对程序员来说，CPU中最主要部件是寄存器，可以通过改变寄存器的内容来实现对CPU的控制
    2. 不同的CPU，寄存器的个数、结构是不相同的（8086是16位结构的CPU）
    3. 8086有14个寄存器
        1. 都是16位的寄存器
        2. 可以存放2个字节 
            ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj11.png)
3. 通用寄存器
    1. AX、BX、CX、DX这4个寄存器通常用来存放一般性的数据，称为通用寄存器（有时也有特定用途）
    2. **通常，CPU会先将内存中的数据存储到通用寄存器中，然后再对通用寄存器中的数据进行运算**
    3. 假设内存中有块红色内存空间的值是3，现在想把它的值加1，并将结果存储到蓝色内存空间
        1. CPU首先会将红色内存空间的值放到AX寄存器中：mov ax,红色内存空间
        2. 然后让AX寄存器与1相加：add ax,1
        3. 最后将值赋值给内存空间：mov 蓝色内存空间,ax
    4. AX、BX、CX、DX这4个通用寄存器都是16位的
    5. 上一代8086的寄存器都是8位的，为了保证兼容， AX、BX、CX、DX都可分为2个独立的8位寄存器来使用
        1. H代表高位寄存器
        2. L代表低位寄存器
4. 字节与字 
    1. 在汇编的数据存储中，有2个比较常用的单位
    2. 字节：byte，1个字节由8bit组成，可以存储在8位寄存器中
    3. 字：word，1个字由2个字节组成，这2个字节分别称为字的高字节和低字节
    4. 1个字可以存在1个16位寄存器中，这个字的高字节、低字节分别存储在这个寄存器的高8位寄存器、低8位寄存器中
5. 段寄存器
    1. 8086在访问内存时要由相关部件提供内存单元的段地址和偏移地址，送入地址加法器合成物理地址
    2. 是什么部件提供段地址？段地址在8086的段寄存器中存放
    3. 8086有4个段寄存器：CS、DS、SS、ES，当CPU需要访问内存时由这4个段寄存器提供内存单元的段地址
        1. CS (Code Segment)：代码段寄存器
        2. DS (Data Segment)：数据段寄存器
        3. SS (Stack Segment)：堆栈段寄存器
        4. ES (Extra Segment)：附加段寄存器
    4. 每个段寄存器的具体作用是？
  
##  CS和IP
1. CS为代码段寄存器，IP为指令指针寄存器，它们指示了CPU当前要读取指令的地址
2. 任意时刻，8086CPU都会将CS:IP指向的指令作为下一条需要取出执行的指令
3. 指令执行的过程
    1. CPU根据代码段寄存器CS的值、IP寄存器的值，通过地址加法器合成20位的内存地址，传送给输入输出控制电路
    2. 输入输出控制电路通过地址地址总线将20位地址传输到内存，在内存的代码段找到对应的内存
    3. 寻址到内存中的数据通过数据总线传输给CPU的输入输出控制电路
    4. 输入输出控制电路，将数据传输给指令缓冲器
    5. 指令缓冲器将数据发送给执行控制器，执行控制指令
    6. IP寄存器自动加上一条指令的字节个数，然后执行下一条指令
       ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj12.png) 
    
    7. 通过上面的过程展示，8086CPU的工作过程可以简要描述如下
        1. 从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器
        2. IP = IP+所读取指令的长度，从而指向下一条指令
        3. 执行指令。跳转到步骤1，重复整个过程
    8. 在8086CPU加电启动或复位后（即CPU刚开始工作时）CS和IP被设置为CS = FFFFH,IP = 0000H,即在8086PC机刚刚启动时，CPU从内存FFFF0H单元中读取指令执行，FFFF0H单元中的指令是8086PC机开机后执行的第一条指令。
    9. 注意:
        1. 偏移地址IP只为CS服务，即代码段服务
        2. 而其他段（数据段、堆栈段、附加段）的偏移地址不是由IP提供
4. 指令和数据
    1. 在内存或者磁盘上，指令和数据没有任何区别，都是二进制信息
    2. CPU在工作的时候把有的信息看做指令，有的信息看做数据，为同样的信息赋予了不同的意义
    3. CPU根据什么将内存中的信息看做指令？
        1. **CPU将CS:IP指向的内存单元的内容看做指令**
        2. 取决于用哪种段寄存器来取值

## jmp指令
1. CPU从何处执行指令是由CS、IP中的内容决定的，我们可以通过改变CS、IP的内容来控制CPU执行目标指令
2. 8086提供了一个mov指令（传送指令），可以用来修改大部分寄存器的值，比如：
    1. `mov ax,10、mov bx,20、mov cx,30、mov dx,40`
3. 但是，mov指令不能用于设置CS、IP的值，8086没有提供这样的功能
4. 8086提供了另外的指令来修改CS、IP的值，这些指令统称为转移指令，最简单的是jmp指令 
5. 若想同时修改CS/IP的内容，可用形如：“`jmp 段地址：偏移地址`” 的指令完成。如：
    1. `jmp 2AE3:3`,执行后：`CS=2AE3H,IP= 0003H`,CPU将从2AE33H处读取指令。
6. ”`jmp 段地址：偏移地址`“ 指令的功能为： 用指令给出的段地址修改CS,偏移地址修改IP
7. 若想修改IP的内容，可用形如“`jmp 某一合法寄存器`”的指令完成，如：
    
    ```
    jmp ax, 执行指令前：ax = 1000H，CS = 2000H,IP= 0003H
            执行指令后： ax = 1000H ，CS = 2000H,IP = 1000H
    ```
    
    1. “`jmp 某一合法寄存器`”指令的功能为： 用寄存器中的值修改IP
    2. `jmp ax` ，在含义上好似： `mov IP, AX`.
8. 另外，也可以“`jmp 直接值`”来改变IP的值，比如“`jmp 0100H`”

## Debug
1. Debug是DOS/Windows都提供的实模式（8086方式）程序的调试工具。使用它，可以查看CPU各种寄存器中的内容、内内存的情况和在机器码级跟踪程序程序的运行。
2. win32系统中直接有这个工具，位置如下图。
    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj13.png) 
3. 打开方法
    1. Windows键 + R，输入debug
    2. 也可以先进入cmd，再输入debug
    3. 注意：debug里面的数值默认都是采用16进制
4. win64需要自己安装
    1. 先安装DOSBOX（搞一个假的32位环境）
    2. 将debug文件放入到C盘或者D盘的根目录下(这里放到了C盘下了)
    3. 打开DOSBox
    4. 输入：
    
        ```
        mount C C:/    //将DOSBox这个假的32位系统的C盘映射到当前系统的C盘
        C:             //进入C盘
        debug          //启动debug
        此时一闪一闪的光标，就说明已经打开debug了
        如如r就可以看看到CPU所有寄存器的值了
        ```
5. Debug的常用功能 
    1. `R`命令： 查看、改变CPU寄存器的内容
        1. 输入`r`可以查看所有寄存器的值
        2. 输入`r 寄存器名称`可以修改寄存器的值
        3. 输入`r ax`将ax寄存器的值改为0100H
            
            ```
            r ax
            1111
            r       //可以查看AX的值变化
            ```
    2. `D`命令：查看内存中的内容
        1. 输入`d`可以查看内存中的内容
        2. 输入`d 段地址:偏移地址`查看特定位置的内存数据
        3. 输入`d 段地址:起始偏移地址 结尾偏移地址`查看特定位置和特定范围的内存数据
        4. 输入`d 偏移地址`、 `d 起始偏移地址 结尾偏移地址` ，会将DS的内容作为段地址
    3. `E`命令：改写内存中的内容
        1. 输入`e 段地址:偏移地址 数据串`修改特定位置的内存数据
        2. 输入`e 段地址:偏移地址`后按Enter也可以修改特定位置的内存数据，数据之间用空格隔开
    4. `U`命令：将内存中的机器指令翻译成汇编指令
        1. 输入`u`、`u 段地址:偏移地址`可以将内存中的内容翻译为对应的汇编指令
        2. 由3部分组成
            1. 最左边一列：是指令的地址`段地址:偏移地址`
            2. 中间那一列：是指令对应的机器指令
            3. 最右边一列：是汇编指令
    5. `T`命令：执行一条机器指令
    6. `A`命令：以汇编指令的格式在内存中写入一条机器指令。
        1. 输入`a `、`a 段地址:偏移地址`可以从某位置开始写入汇编指令
    7. `q`命令：退出debug
    8. `p`命令：类似于step over（“t”命令类似于step into），可用于跳过loop循环
    9. `g`命令：跳过前面的代码，停留到指定的代码位置

## DS寄存器
1. CPU要读写一个内存单元时，必须要先给出这个内存单元的地址，在8086中，内存地址由段地址和偏移地址组成,格式：`段地址：[偏移地址]`
2. 8086中有一个DS段寄存器，通常用来存放要访问数据的段地址
    
    ```
    mov bx,1000h
    mov ds,bx
    mov al,[0]
    ```
    
    1. 上面3条指令的作用将10000H（1000:0）中的内存数据赋值到al寄存器中
    2. mov al,[address]的意思将DS:address中的内存数据赋值到al寄存器中
    3. 由于al是8位寄存器，所以是将一个字节的数据赋值给al寄存器
    4. 注意: 8086不支持将数据直接送入段寄存器中，mov ds,1000H是错误的
    5. 8086规定，不写段地址，默认为数据段 
    5. 例2：
        
        ```
        ;访问内存的数据： 段地址：[偏移地址]  
        mov ax,1123h   
        ;定义数据段地址
        ;mov ds, 1000h  这句话是错误的，因为不能直接给段寄存器传值(mov) 
        ;mov 常用语内存、通用寄存器
        mov bx，1000h
        mov ds，bx  
        ;mov ds:[0h],ax  这句话可以被下面的替代，因为8086规定，不写段地址，默认为数据段 
        mov [0h]，ax
        ```
3. 大小端
    1. 就是内存存储数据的一种模式
    2. 大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中（高低\低高） (Big Endian)
    3. 小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中（高高\低低） (Little Endian)
4. 指明指令要处理的数据长度 
    1. 比如下面两条指令：
        
        ```
        mov [0h],66h   ;这句话是网内存中传递一个字节的数据
        mov [0h],0066h ;这句话是往内存中传递2个字节的数据这两者是不一样的。
        ```
    2. 8086指令能处理2种尺寸的数据：byte、word
    3. 思考：`mov [0], 20H`指令是否正确？
        
        ```
        mov byte ptr [0], 20H  将20H放入0位置内存的字节单元，占用1个字节
        mov word ptr [0], 20H  将20H放入0位置内存的字单元，占用2个字节
        ```
    4. 很多指令都可以通过“byte ptr”或者“word ptr”来指明所需要操作内存的数据长度
        
        ```
        inc byte ptr [0]
        add word ptr [0], 2
        ```
    5. 有些指令有默认的操作数据长度，比如push [0]、pop [0]的操作数据长度只能是2个字节

## 栈
1. 栈：是一种具有特殊的访问方式的存储空间（后进先出， Last In Out Firt，LIFO）
2. 8086会将CS作为代码段的段地址，将`CS:IP`指向的指令作为下一条需要取出执行的指令
3. 8086会将DS作为数据段的段地址，`mov ax,[address]`就是取出`DS:address`的内存数据放到ax寄存器中
4. 8086会将SS作为栈段的段地址，任意时刻，`SS:SP`指向栈顶元素
5. 8086提供了PUSH（入栈）和POP （出栈）指令来操作栈段的数据
    1. 比如`push ax`是将ax的数据入栈，`pop ax`是将栈顶的数据送入ax
6. `push ax`
    
    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj14.png) 
    
    1. 从这张图可以看出，栈里面压入数据，sp即栈顶是从高地址相低地址下减的。
    2. push ax的执行，有以下两步骤完成：
        1. sp = sp -2，ss：sp指向当前的栈顶前面的单元，以当前栈顶前面的单元为新的栈顶；
        2. 将ax中的内容送入ss：sp指向的内存单元处，ss：sp此时指向新栈顶。
7. `pop ax`
    
    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj15.png) 
    
    1. pop ax的执行过程和push ax恰好相反
        1. 将ss：sp指向的内存单元处的数据送入ax中；
        2. sp = sp +2， ss：sp指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。 
8. 思考：
    1. 如果将10000H~1000FH这段空间当做栈，初始状态栈是空的，此时，ss = 10000H，sp=？
        
        ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hbjj16.png) 
        
        1. 空栈，ss：sp指向栈空间最高地址单元的下一个单元
9. 栈顶超界
    1. 当栈满的时候，在使用push指令入栈，或栈空的时候在使用pop指令出栈，都将发送栈顶超界问题
    2. 栈顶超界是危险的，因为我们既然将一段空间安排为栈，那么在栈空间之外的空间里很可能存放了具有其他用途的数据、代码等，这些数据、代码可能是我们自己程序中的，也可能是别的程序中的（毕竟一个计算机系统中并不是只有我们自己的程序在运行）。但是由于我们在入栈、出栈是不小心，而将这些数据、代码意外的改写，将会引发一连串的错误。
    3. 当然我们希望cpu可以帮我们解决这个问题，比如说在CPU中有记录栈顶上限和栈底的寄存器，我们可以通过填写这些寄存器来指定栈空间的范围，然后，CPU在执行push指令的时候靠检测栈顶上限寄存器、在执行pop指令的时候靠检测栈底寄存器保证不会超界。
    4. 但是8086CPU并没有这样的寄存器，因此，我们在编程的时候要自己操心栈顶超界的问题，要根据可能用到的最大栈空间，来安排栈的大小，防止入栈的数据太多而导致超界问题；执行出栈操作的时候也要注意，以防栈空的时候继续出栈而导致的超界。
10. 栈的总结
    1. 我们可以用一个段存放数据，将它定义为**数据段**
    2. 我们可以用一个段存放代码，将它定义为**代码段**
    3. 我们可以用一个段当做栈，将它定义为**栈段**
    4. 对于数据段，将他的段地址放在Ds中，用mov、add、sub等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当做数据来访问。
    5. 对于代码段，将它的段地址放在CS中，将段中第一条指令的偏移地址放在IP中，这样CPU就将执行我们定义的代码段中的指令。
    6. 对于栈段，将它的段地址放在SS中，将栈顶单元的偏移地址放在SP中，这样CPU在需要进行栈操作的时候，比如执行push、pop指令等，就将我们定义的栈段当做栈空间来用。





