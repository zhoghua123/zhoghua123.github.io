---
layout: post
title: 推送通知(二)-iOS>10的推送通知
category: iOS开发
tags: 推送通知
description: 推送通知
---

> 接下来主要讲的是iOS10的推送通知

## 简介
1. iOS10新加了一个独立框架：**UserNotification.framework**,废弃了 UILocalNotification（在UIKit.framework中）这个类，采用了全新的UserNotifications.framework来推送通知，从此推送通知也有了自己的标签UN（,以及对推送功能的一系列增强改进（两个extension,延展)和界面的体验优化）。
2. 废话不多说,学习一个新的框架当然就是从他常用的类开始

## 常见类之间的关系
1. 该框架的类的结构分为2部分
    1. 管理通知相关的类     
        ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/管理通知相关类.png)  
    2. 创建通知相关的类     
        ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/创建通知相关类.png)  

## 本地通知
1. 设置通知内容
    1. 创建通知内容对象
    2. 设置属性
    3. 设置通知的附件:视频/音频/图片/gif
    4. 设置互交类型
2. 设置通知触发机制
3. 创建一个`UNNotificationRequest`类的实例    
    1. 一定要为它设置`identifier`, 在后面的查找，更新， 删除通知，这个标识是可以用来区分这个通知与其他通知
    2. 如果另一个`request`具有和之前`request`相同的标识，不同的内容， 可以达到更新通知的目的
4. 把`request`加到`UNUserNotificationCenter`， 并设置触发器，等待触发
3. 代码举例如下:
    
    ```javascript
    //推送本地通知：//使用UNNotification本地通知
    -(void)sendLocalNotification{
        //1. 设置通知内容
        //需创建一个包含待通知内容的UNMutableNotificationContent对象，注意不是UNNotificationContent ,此对象为不可变对象。
        UNMutableNotificationContent *content = [[UNMutableNotificationContent alloc] init];
        //通知主标题
        content.title = @"主标题";
        //通知子标题
        content.subtitle = @"子标题";
        //设置通知的内容
        content.body = @"这是通知的内容????????????????????????";
        //或者也可以这样创建：
        //content.title = [NSString localizedUserNotificationStringForKey:@"主标题" arguments:nil];
        //content.body= [NSString localizedUserNotificationStringForKey:@"Hello_message_body" arguments:nil];
        //设置应用程序图标右上角的数字
        content.badge = @0;
        //设置有通知时的音效
        UNNotificationSound *sound = [UNNotificationSound defaultSound];
        content.sound = sound;
        
        //设置通知的附件:通知右边的图片
        //将本地图片的路径形成一个图片附件，加入到content中
        NSString *path = [[NSBundle mainBundle] pathForResource:@"beautiful" ofType:@"png"];
        NSError *error = nil;
        UNNotificationAttachment *img_attachment = [UNNotificationAttachment attachmentWithIdentifier:@"att1" URL:[NSURL fileURLWithPath:path] options:nil error:&error];
        content.attachments = @[img_attachment];
        
        //设置为@""以后，进入app将没有启动页
        content.launchImageName = @"";
        
        //通知的互交类型,Identifier可不是乱写的而是,在注册通知时设置好的
        content.categoryIdentifier = @"seeCategory1";
        //设置额外信息(比如:告诉app点击通知时跳转到哪一个界面)
        content.userInfo = @{@"type" : @1 };
        
        //2. 设置通知触发机制
        //通知触发机制
        //UserNotifications提供了三种触发器：
        //UNTimeIntervalNotificationTrigger：一定时间后触发（若重复提醒，时间间隔要大于60s）
        //UNCalendarNotificationTrigger：在某月某日某时触发
        //UNLocationNotificationTrigger：在用户进入或是离开某个区域时触发
        //UNPushNotificationTrigger: 远程推送
        //设置通知发出的时间
        UNTimeIntervalNotificationTrigger *time_trigger = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:5 repeats:NO];
        
        //3.创建通知请求
        //创建UNNotificationRequest通知请求对象//创建一个发送请求
        //通知请求标识,便于管理该通知
        NSString *requestIdentifer = @"time interval request";
        UNNotificationRequest *request = [UNNotificationRequest requestWithIdentifier:requestIdentifer content:content trigger:time_trigger];
        
        //4.将通知请求添加到通知中心
        [[UNUserNotificationCenter currentNotificationCenter] addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) {}];
    }

    ```
4. 根据上面内容，大家会发现在创建UNNotificationRequest的时候，会需要UNMutableNotificationContent以及UNTimeIntervalNotificationTrigger这两个类。下面我就对相关的类，以及类扩展，做相应的说明

### UNNotificationContent以及UNMutableNotificationContent（通知内容和可变通知内容）
1. 通知内容分为可变的以及不可变的两种类型，类似于可变数组跟不可变数组。
2. 后续我们通过某一特定标识符更新通知，便是用可变通知了。
3. 不管是可变通知还是不可变通知，都有以下的几个属性：
    1. 附件数组，存放UNNotificationAttachment类
    
        ```
        @property (NS_NONATOMIC_IOSONLY, copy) NSArray <UNNotificationAttachment *> *attachments ;
        ```
    2. 应用程序角标，0或者不传，意味着角标消失
        
        ```
        @property (NS_NONATOMIC_IOSONLY, copy, nullable) NSNumber *badge;
        ```
    3. 主体内容
        
        ```
        @property (NS_NONATOMIC_IOSONLY, copy) NSString *body ;
        ```
    4. 点击通知启动app时的图标
        1. 程序在后台时,此时程序没有杀死
        2. 设置任意字符串即可,只会显示启动图片的图标
        
        ```
        @property (NS_NONATOMIC_IOSONLY, copy) NSString *launchImageName;
        ```
    5. `UNNotificationSound`类，可以设置默认声音，或者指定名称的声音
        
        ```
        @property (NS_NONATOMIC_IOSONLY, copy, nullable) UNNotificationSound *sound ;
        ```
    6. 推送内容的子标题
        
        ```
        @property (NS_NONATOMIC_IOSONLY, copy) NSString *subtitle ;
        ```
    7. 通知线程的标识
        
        ```
        @property (NS_NONATOMIC_IOSONLY, copy) NSString *threadIdentifier;
        ```
    8. 推送内容的标题
        
        ```
        @property (NS_NONATOMIC_IOSONLY, copy) NSString *title ;
        ```
    9. 远程通知附加的额外信息
        
        ```
        @property (NS_NONATOMIC_IOSONLY, copy) NSDictionary *userInfo;
        ```
    10. 通知的互交类型
        1. Identifier可不是乱写的,而是在通知中心(`UNUserNotificationCenter`)在程序启动注册应用通知时给整个应用程序设置的所有互交类型,并且每个互交类型都有它的Identifier
        
        ```
        @property (NS_NONATOMIC_IOSONLY, copy) NSString *categoryIdentifier;
        ```
    
    
#### UNNotificationAttachment
 1. 在UNNotificationContent类中，有个附件数组的属性，这就是包含UNNotificationAttachment类的数组了。
 2. 苹果的解释说，UNNotificationAttachment（附件通知）是指可以包含音频，图像或视频内容，并且可以将其内容显示出来的通知。
 3. 使用本地通知时，可以在通知创建时，将附件加入即可。
 4. 对于远程通知，则必须实现使用`UNNotificationServiceExtension`类通知服务扩展。   
 5. 创建附件的方法是
 
    ```
    + (nullable instancetype)attachmentWithIdentifier:(NSString *)identifier URL:(NSURL *)URL options:(nullable NSDictionary *)options error:(NSError *__nullable *__nullable)error;
    ```
    
    1. 在使用时，必须指定使用文件附件的内容，并且文件格式必须是支持的类型之一。
    2. 创建附件后，将其分配给内容对象的附件属性。
    3. 对于远程通知，您必须从您的服务扩展做到这一点。
 6. 附件通知支持的类型如下图：   
     ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/attachment.png) 
7. 注意：URL必须是一个有效的文件路径，不然会报错
8. options参数是一个字典,但是其key实枚举,如下;
    1. `UNNotificationAttachmentOptionsTypeHintKey`:
        1. 此键的值(value)是一个描述文件类型的统一类型标识符（UTI）一个NSString。
        2. 如果不提供该键，附件的文件扩展名来确定其类型
        3. 常用的类型标识符有:`kUTTypeImage,kUTTypeJPEG2000,kUTTypeTIFF,kUTTypePICT,kUTTypeGIF ,kUTTypePNG,kUTTypeQuickTimeImage等。`
        4. 使用这些标识符之前要导入`#import<MobileCoreServices/MobileCoreServices.h>`框架
        5. 使用方法如下：
            
            ```
            dict[UNNotificationAttachmentOptionsTypeHintKey] = (__bridge id _Nullable)(kUTTypeImage);
            ```
    2. `UNNotificationAttachmentOptionsThumbnailHiddenKey`: 
        1. 是一个BOOL值,为YES时候，缩略图将隐藏(即通知中(右中)带的图片)，默认为NO。
        2. 使用方法如下:
            
            ```
             dict[UNNotificationAttachmentOptionsThumbnailHiddenKey] =  @YES;
            ```
    3. `UNNotificationAttachmentOptionsThumbnailClippingRectKey`
        1. 剪贴矩形的缩略图。
        2. 使用方法; 
            
            ```
            dict[UNNotificationAttachmentOptionsThumbnailClippingRectKey] = (__bridge id _Nullable)((CGRectCreateDictionaryRepresentation(CGRectMake(0.5, 0.5, 0.25 ,0.25))));
            ```
        3. `(0.5, 0.5, 0.25 ,0.25)`这句话的意思是,以原缩略图左上角为原点截取一个x坐标为:`0.5*长度`,y坐标为:`0.5*宽度`,宽度为:`0.25*宽度`,长度为:`0.25*长度`的矩形图片作为新的缩略图(即通知右中的图片).
    4. `UNNotificationAttachmentOptionsThumbnailTimeKey`
        1. 一般影片附件会用到，指的是用影片中的某一秒来做这个缩略图；
        2. 使用方法如下：
            
            ```
dict[UNNotificationAttachmentOptionsThumbnailTimeKey] =@10;
            ```
        3. 这里我们可以直接传递一个NSNumber的数值，比如使用影片第10s的画面来做缩略图就按照上面的来写。此外，要注意的是，这个秒数必须是这个影片长度范围内的，不然报错。
        
#### UNTimeIntervalNotificationTrigger

1. `UNPushNotificationTrigger`
    1. （远程通知触发）一般我们不会使用的
2. `UNTimeIntervalNotificationTrigger`
    1. （本地通知） 一定时间之后，重复或者不重复推送通知。我们可以设置timeInterval（时间间隔）和repeats（是否重复）。
    2. 使用方法：
        
        ```
        UNTimeIntervalNotificationTrigger *triggerOne = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:5 repeats:NO];
        ```
    3. 解释：上面的方法是指5秒钟之后执行。`repeats`这个属性，如果需要为重复执行的，则`TimeInterval`必须大于60s,否则会报: ` Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'time interval must be at least 60 if repeating'`的错误!
3. `UNCalendarNotificationTrigger`
    1. （本地通知） 一定日期之后，重复或者不重复推送通知 
    2.  例如，你每天8点推送一个通知，只需要dateComponents为8。如果你想每天8点都推送这个通知，只要repeats为YES就可以了。
    3. 代码举例:
        
        ```
        // 周一早上 8：00 上班
        NSDateComponents *components = [[NSDateComponents alloc] init];
        // 注意，weekday是从周日开始的，如果想设置为从周一开始，大家可以自己想想~
        components.weekday = 2;
        components.hour = 8;
        UNCalendarNotificationTrigger *trigger = [UNCalendarNotificationTrigger triggerWithDateMatchingComponents:components repeats:YES];
        ```
    4. `UNLocationNotificationTrigger`
        1. (本地通知）地理位置的一种通知，使用这个通知，你需要导入
        2. `#import<CoreLocation/CoreLocation.h>`这个系统类库。示例代码如下：
        
            ```
            //1、如果用户进入或者走出某个区域会调用下面两个方法
            - (void)locationManager:(CLLocationManager *)manager
                didEnterRegion:(CLRegion *)region
            - (void)locationManager:(CLLocationManager *)manager
                didExitRegion:(CLRegion *)region代理方法反馈相关信息
            
            //2、一到某个经纬度就通知，判断包含某一点么
            // 不建议使用！！！！！！CLRegion *region = [[CLRegion alloc] init];// 不建议使用！！！！！！
            
            
            CLCircularRegion *circlarRegin = [[CLCircularRegion alloc] init];
            [circlarRegin containsCoordinate:(CLLocationCoordinate2D)];
            
            UNLocationNotificationTrigger *trigger4 = [UNLocationNotificationTrigger triggerWithRegion:circlarRegin repeats:NO];

            ```
        3. 注意，这里建议使用`CLCircularRegion`这个继承自`CLRegion`的类，因为我看到苹果已经飞起了`CLRegion`里面是否包含这一点的方法，并且推荐我们使用`CLCircularRegion`这个类型
        4. 


