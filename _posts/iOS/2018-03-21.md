### 推动通知的监听
1. 此次iOS10系统的更新，苹果给了我们2个代理方法来处理通知的接收和点击事件，这两个方法在`<UNUserNotificationCenterDelegate>`的协议中
2. 苹果把本地通知跟远程通知合二为一
3. 区分本地通知跟远程通知的类是`UNPushNotificationTrigger`

#### 代理方法1:
1. 调用时刻:
    1. 应用程序在前台台时调用(通知即将展示,还没有展示时),即不点击通知就会调用
    2. 程序处于后台/杀死状态时都不会调用
2. 作用:
    1. 在展示通知前进行处理，即有机会在展示通知前再修改通知内容。
3. 特点:
    1. 如果该方法没有实现或者没有回调用`completionHandler`则前台通知将不会呈现,也接收不到
4. 应用程序可以通过`completionHandler()`回调,选择怎样呈现这个通知: 只有角标变化的通知/只有声音提示/只有弹框提示或者3种的组合
5. 代码如下:
    
    ```
    -(void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler{
    // 原始请求
    UNNotificationRequest *request = notification.request;
    // 获取请求的额外信息
    NSDictionary * userInfo = notification.request.content.userInfo;//userInfo数据
    // 请求的内容
    UNNotificationContent *content = request.content; // 原始内容
    NSString *title = content.title;  // 标题
    NSString *subtitle = content.subtitle;  // 副标题
    NSNumber *badge = content.badge;  // 角标
    NSString *body = content.body;    // 推送消息体
    UNNotificationSound *sound = content.sound;  // 指定的声音
    //本地通知的判断:notification.request.trigger类型判断是远程还是本地推送
    if ([notification.request.trigger isKindOfClass:[UNPushNotificationTrigger class]]) {
        NSLog(@"iOS10代理方法一的远程通知:%@",[notification description]);
        
    }else{
        NSLog(@"iOS10代理方法一的本地通知:%@",[notification description]);
    }
    //设置怎样接收通知:只有角标变化的通知/只有声音提示/只有弹框提示/3中的组合
    completionHandler(UNNotificationPresentationOptionBadge|UNNotificationPresentationOptionSound|UNNotificationPresentationOptionAlert);
    }
    ```
    
#### 代理方法二:
1. 调用时刻
    1. 应用程序在后台/杀死状态下都会调用
    2. 用户点击通知打开app
    3. 下拉通知,选择一个互交动作:点击互交按钮/文本输入后点击发送
    4. 跟后台发送content-available没任何关系,必须操作才会调用
2. 作用: 点击通知处理通知内容
3. 如果不写`completionHandler（）`这个方法，会报错误
4. 代码举例:
    
    ```
    -(void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)(void))completionHandler{
    
    //1.获取到通知详情
    UNNotificationRequest *request = response.notification.request; // 原始请求
    NSDictionary * userInfo = request.content.userInfo;//userInfo数据
    UNNotificationContent *content = request.content; // 原始内容
    //2.判断通知的种类
    if ([response.notification.request.trigger isKindOfClass:[UNPushNotificationTrigger class]]) {
        NSLog(@"代理方法二的远程通知");
    }else{
        NSLog(@"代理方法二的本地通知");
    }
    
    //3.根据response的种类判断用户的互交类型
    //可根据actionIdentifier来做业务逻辑
    if ([response isKindOfClass:[UNTextInputNotificationResponse class]]) {
        //交互类型为文本输入
        UNTextInputNotificationResponse * textResponse = (UNTextInputNotificationResponse*)response;
        //拿到用户交互的内容
        NSLog(@"用户输入的内容为: %@",textResponse.userText);
    }else{ //交互类型为点击按钮
        //点击第一个交互按钮
        if ([response.actionIdentifier isEqualToString:@"see1"]) {
            //看一看的处理
            NSLog(@"用户点击的按钮为see1");
        }
        //点击第二个交互按钮
        if ([response.actionIdentifier isEqualToString:@"see2"]) {
            //删除已经推动过的推送需求
            NSLog(@"用户点击的按钮为see2");
            //忽略的处理
            [[UNUserNotificationCenter currentNotificationCenter] removeDeliveredNotificationsWithIdentifiers:@[response.notification.request.identifier]];
        }
    }
    completionHandler();
    }
    ```

