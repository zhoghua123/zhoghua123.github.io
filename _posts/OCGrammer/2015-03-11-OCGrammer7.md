---
layout: post
title: OC语法补充之-Copy与MutableCopy
category: OC语法
tags: OC语法
description: OC语法
---

## 概念
1. 拷贝的特点:
    1. 生成一个跟原对象一样的副本
    2. 修改副本并不会影响原对象,修改原对象也不会影响副本对象
2. iOS开发中提供了两种拷贝的方法
    1. `copy`: 只会产生不可变的副本对象(如: NSString)
    2. `MutableCopy`:只会产生可变的副本对象(如: `NSMutableNSString`)
3. 拷贝的深度分为两种
    1. 深拷贝: 产生新对象的拷贝
    2. 浅拷贝: 没有产生新对象的拷贝
4. iOS中的拷贝原则都遵从第1条的2个特点.

## 深拷贝与浅拷贝
1. 代码举例:
    
    ```javascript
    //不可变对象的拷贝
    - (void)test {
        NSString *string = @"hhhh";
        //没有产生新对象(浅拷贝)
        NSString *str1 = [string copy];
        //产生新对象(深copy)
        NSMutableString *str2 = [string mutableCopy];
        NSLog(@"string====%p===str1===%p==str2==%p",string,str1,str2);
        /*
         打印结果
    string====0x1038fa0c0===str1===0x1038fa0c0==str2==0x60400005fcb0
         */
    }
    
    //可变对象的拷贝
    - (void)test2 {
        NSMutableString *string = [NSMutableString string];
        [string appendString:@"hhhh"];
        //产生新对象(深copy)
        NSString *str1 = [string copy];
        //产生新对象(深copy)
        NSMutableString *str2 = [string mutableCopy];
        NSLog(@"string====%p===str1===%p==str2==%p",string,str1,str2);
        /*
         打印结果如下:
         string====0x60400005fb90===str1===0x10bdcc030==str2==0x60400005fbc0
         */
    }

    ```
2. 根据test与test2总结:
    1. 当原对象是可变的,无论是copy还是mutablecopy,都会产生新对象,深拷贝.
    2. 当原对象是不可变的,mutablecopy会产生新对象(深拷贝),copy不会产生新对象(浅拷贝)

## 如何让一个对象具有copy功能
1. 通常`NSString/NSArray/NSDictionary`等都遵守了`NSCopying`协议,并且实现了相应的方法,所以能使用copy
2. `NSObject`对象没有遵守,因此`NSObject`要实现`copy`,那就必须遵守,跟实现一些条件
3. 一个对象要想能够调用`copy`方法,应遵守`copy`的条件:
    1. 遵守`NSCopying`协议
    2. 实现`copyWithZone:(NSZone *)zone`方法
4. `NSObject`对象没有必要去实现`mutableCopy`,因为不存在可变这个概念
5. 当对象调用了`copy`方法时,内部就会调用`copyWithZone:(NSZone *)zone`,如果没有实现,那么就会错:
    
    ```
    -[Person copyWithZone:]: unrecognized selector sent to instance ...
    ```
6. 代码举例: 
    
    ```javascript
    #import <Foundation/Foundation.h>

    @interface Person : NSObject<NSCopying>
    @property (nonatomic,assign) NSInteger age;
    //@property (nonatomic,strong) NSString *name;
    @property (nonatomic,copy) NSString *name;
    @end
    
    #import "Person.h"

    @implementation Person
    -(id)copyWithZone:(NSZone *)zone{
        Person *p = [[Person allocWithZone:zone]init];
        p.age = self.age;
        p.name = self.name;
        return self;
    }
    //strong中set方法
    //-(void)setName:(NSString *)name{
    //    _name = name;
    //}
    //copy中set方法与strong的不同
    -(void)setName:(NSString *)name{
        _name = [name copy];
    }
    @end
    
    //应用
   //如何让一个对象实现copy功能
    - (void)test3 {
        Person *p1 = [[Person alloc] init];
        p1.age = 5;
        NSLog(@"p1的对象%p===age = %zd",p1,p1.age);
        Person *p2 = [p1 copy];
        //改变P2并不会影响p1
        p2.age = 10;
        NSLog(@"p2的对象%p===age = %zd",p2,p2.age);
        /*
         打印结果:
         p1的对象0x6040000267a0===age = 5
         p2的对象0x6040000267a0===age = 10
         */
    }
    ```

## copy用于@property中的作用
1. 代码举例: 
    
    ```javascript
    //copy用于@property中的作用
    - (void)test4 {
        NSMutableString *sttt = [NSMutableString stringWithFormat:@"gggg"];
        Person *p1 = [[Person alloc] init];
        p1.age = 5;
        p1.name = sttt;
        [sttt appendString:@"xxxxx"];
        NSLog(@" sttt当前内容为:%@====p1.name= %@",sttt,p1.name);
    }
    ```
    
    ```
    //此时如果name用的是strong修饰,set方法内部是直接赋值,p1.name直接指向了sttt这个对象,如果改变了sttt,p1.name也会跟着改变.
    //打印结果:  sttt当前内容为:ggggxxxxx====p1.name= ggggxxxxx
    //但是name如果用的是copy修饰,set方法内部进行了copy,如果改变了sttt,p1.name不变.
    //打印结果:  sttt当前内容为:ggggxxxxx====p1.name= gggg
    ```
2. 什么时间用`strong`?什么时间用`copy`呢?
    1. `strong`: 对象的属性希望跟着外边的内容变化而变化
    2. `copy`: 对象的属性不受外边的影响,具有保护对象属性值的作用.
3. 面试题:
    1. `@property (nonatomic,copy) NSMutableString *name;`这句话合适吗?
        1. 不合适,因为属性`name`的真实类型是不可变的即`NSString`类型
        2. 该类的`set`方法为:
            
            ```
            -(void)setName:(NSMutableString *)name{
             _name = [name copy];
             }
            ```
        3.  由于`copy`方法返回的是一个不可变对象,然而`_name`却是`NSMutableString`类型修饰!!!
        4. 但是如果用`strong`修饰没有问题,`name`是`NSMutableString`的


