---
layout: post
title: OC语法之-核心语法
category: OC语法
tags: OC语法
description: OC语法
---
## 多文件开发
1. C语言中我们知道,多文件开发是将函数的实现全部写在.c文件(one.c),函数的声明全部写在.h文件(one.h),然后只要将.h文件导入(#include"one.h")带有主函数的.c(two.c)文件即可,然后分别编译one.c/two.c文件得到one.o/two.o文件,然后一起连接这两个.o文件生成可执行文件a.out,然后运行即可.  
2. 如果我们在two.c文件中导入的不是.h文件而是one.c文件,当同时进行连接one.o/two.o时,就会报错:说我们重复定义,因为#include相当于copy,two.c中已经有了one.c的全部内容,因此如果在把他们一起连接那么实际上就会有两份one.c了

3. 对比C语言来看,OC也同理,为了方便,我们也进行多文件开发,分为.h/.m文件,因此也不能导入.m文件,否者也会报错:重复定义,XCode编译连接时会把所有的.m一起编译连接     
4. 同C语言对比一样,我们把每一个类单独用一对.m/.h文件来写,通常这个.m/.h文件的名字为该类的名字;.h中放类的声明,.m文件中放类的实现
5. 与C语言中不同的是,.m文件中一定要导入对应的.h文件,因为.m文件中用到了.h文件类的声明的成员变量跟方法      
6. 如果那个文件用到了该类,直接将该类的.h文件导入即可,千万不可以导入.m文件,错误跟C语言一样,重复定义
7. 从上面我们可以看出.h跟.m没有任何必然联系系,不用一样的名字也可以
8. XCode编译是把所有的.m文件编译成.o(目标文件),然后连接是把所有的.o文件连接在一起形成可执行文件a.out   

## 点语法

代码如下:

```javascript
#import <Foundation/Foundation.h>
@interface Person : NSObject
{
    int _age;
    NSString *_name;
}

- (void)setAge:(int)age;
- (int)age;

@end

#import "Person.h"
@implementation Person

- (void)setAge:(int)age
{
    //_age = age;
    
    NSLog(@"setAge:");
    
    // 会引发死循环
    //self.age = age; // [self setAge:age];
}
- (int)age
{
    NSLog(@"age");
    return _age;
    // 会引发死循环
    //return self.age;// [self age];
}
@end
//点语法调用:
 Person *p = [Person new];
//点语法的赋值就是调用set方法
p.age = 10; // [p setAge:10];
//点语法的取值就是调用get方法
int a = p.age; // [p age];
```

1. 点语法跟set方法/get方法有关的
2. 这个点不是访问这个对象的成员变量的(不是age也不是_age)(这个最容易误解!!!),java中的点语法时访问成员变量的
3. 点语法的本质是方法调用
4. 编译器遇到点语法时,会自动转化为方法调用,因此点语法是编译器特性(**编译器特性**)
5. 点语法的赋值就是调用set方法

    ```
    p.age = 10; <=>[p setAge:10];
    ```
6. 点语法的取值就是调用get方法

    ```
    int a = p.age; <=> [p age];
    ```
7. 满足点语法的条件:
    1. 有set/get方法的声明
    2. 有set/get方法的实现
    3. set/get方法实现中,可以没有成员变量操作
        比如:
        
        ```
        1. 声明
         - (void)setAge:(int)age;
         - (int)age;
         2.实现:
         - (void)setAge:(int)age
         {
         NSLog(@"这里随便写");
         }
         - (int)age
         {
         NSLog(@"这里随便写");
         //return 1;
         }
        ``` 
    4. 没有set方法,就只能使用点语法的取值操作
    5. 没有get方法,就只能使用点语法的赋值操作
    
## 成员变量的作用域
1. 局部变量/全局变量都有他的作用域,而成员变量既不属于局部变量,也不属于全局变量,那么他的作用域是什么呢?
2. 局部变量与全局变量的作用域相对的是代码块,即在代码块内有用还是在代码块外有用;那么成员变量的作用域就是相对于这个类了,即在类中有用,还是在类外有用
3. 相对于类内还是类外分为以下4种:
    1. **@private:**只能在当前类的对象方法中直接访问(@implementation中设置成员变量默认是@private,类扩展中设置也是!!!)
        1. **注意了**,在 @implementation中或者类扩展中声明的成员变量虽然默认是@private,但是也只能是@private,即使加上@public也没有用,因为别人包含或者继承这个类的时候,只会包含你的.h文件!!!
    2. **@protected:**可以在当前类及其子类的对象方法中直接访问(在@interface中默认就是@protected)
    3. **@public:**在任何地方都能直接访问对象的成员变量
    4. **@package:**同一个体系(框架)内可以访问,介于@private与@public之间
4. 注意:@interface和@implementation中不能声明同名的成员变量

代码举例:

```javascript
//Person.h文件
#import <Foundation/Foundation.h>

@interface Person : NSObject
{
    int _no;
    // 在任何地方都能直接访问对象的成员变量
    @public 
    int _age;
    // 只能在当前类的对象方法中直接访问
    @private  
    int _height;
    // 能在当前类和子类的对象方法中直接访问
    @protected 
    int _weight;
    int _money;
}

- (void)setHeight:(int)height;
- (int)height;
- (void)test;
@end

//Person.m文件
#import "Person.h"
@interface Person()
{   // 类扩展中:默认就是私有@private
    //说明:类扩展中声明成员变量<=>@implementatiom中声明成员变量
    int _klkl;
    @public//没有用仍然是@private类型
    int _lkk;
}
@end

@implementation Person
{
    int _aaa;// 默认就是私有@private
    
    @public//写上这个也没有用,因为别人包含或者继承这个类的时候,只会包含你的.h文件!!!
    int _bbb;
    // @implementation中不能定义和@interface中同名的成员变量
    // int _no;
}

- (void)test
{
    //只能在当前类实现中访问
    _age = 19;
    
    _height = 20;
    
    _weight = 50;
    
    _aaa = 10;
}

- (void)setHeight:(int)height
{
    _height = height;
}

- (int)height
{
    return _height;
}
@end

//Student.h文件
#import "Person.h"

@interface Student : Person
- (void)study;
@end

//Student.m文件
#import "Student.h"
@implementation Student
- (void)study
{
    //不能在子类中直接访问
    // _height = 10;
    //用set/get方法设置,方法是可以继承的
    [self setHeight:10];
    int h = [self height];
    //内在子类中直接访问
    _weight = 100;
    //不能在子类中直接访问
    //_klkl = 10;
}
@end

//main.m文件
int main(int argc, const char * argv[])
{

    @autoreleasepool {
        Student *stu = [Student new];
        [stu setHeight:100];
        NSLog(@"%d", [stu height]);

        Person *p = [Person new];
        p->_age = 100;
         //@public没用!!!
        //p->_bbb = 10;
        //只能在当前类中访问
        //p->_height = 20;
        //前类和子类
        //p->_weight = 10;
    }
    return 0;
}
```

## @property和@synthesize
1. 这两个关键字帮助我们自动生成get/set方法,跟点语法一样,也是**编译器特性**
2. Xcode4.4之前
    
    ```javascript
    
    #import <Foundation/Foundation.h>
    
    @interface Person : NSObject
    {
        //下面这些成员变量也可以不写
        int _age;
        double _weight;
        NSString *_name;
    }
    
    // @property：可以自动生成某个成员变量的setter和getter声明
    @property int age;
    //- (void)setAge:(int)age;
    //- (int)age;
    
    /*
     @property int _age;
     //- (void)set_age:(int)_age;
     //- (int)_age;
     */
    
    @property int height;
    - (void)test;
    @property double weight;
    @property NSString *name;
    @end
    
    #import "Person.h"
    
    @implementation Person
    
    /*
     1.这句话的作用: @synthesize自动生成age的setter和getter实现，并且会访问_age这个成员变量,如果不存在，就会自动生成@private类型的_age成员变量
    2. @synthesize age生成怎样的get方法/set方法
    3. = _age 这个set/get方法中访问哪个成员变量
    4. 注意:如果只写@synthesize age,默认会访问age这个成员变量，如果没有age，就会自动生成@private类型的age变量
     5. 等价如下:
     -(void)setAge:(int)age{
     _age = age;
     }
     -(int)age{
     return _age;
     }
     6. 手动实现:
     若手动实现了setter方法,编译器就只会自动生成getter方法
     若手动实现了getter方法,编译器就只会自动生成setter方法
     若手动实现了setter方法/getter方法,编译器就不会自动生成不存在的成员变量
     */
    @synthesize age = _age;
    
    @synthesize height = _height;
    
    @synthesize weight = _weight, name = _name;
    -(void)test{
        NSLog(@"%zd",_height);
    }
    @end
    ```
3. Xcode4.4之后   
   只需要写`@property int age;`就可以了,会做以下几件事:
   1. 生成get/set方法的声明
   2. 生成带下划线的成员变量_age(注意这变量是@private)
   3. 生成get/set方法的实现
   
4. **@dynamic age;:**
    1. 告诉编译器,属性age的setter与getter方法由用户自己实现，不需要自动生成,或者,getter和setter方法在别处生成了（比如父类中），并没有在本类生成。
    2. 存取方法在运行时动态创建与绑定:主要使用在CoreData的实现NSManagerObject子类时使用
    
## id
1. id是一种数据类型
2. 万能指针，能指向\操作任何OC对象`id  == NSObject *`
3. id时没有`*`的!!!
4. id类型不能使用点语法!!!

## 构造方法
1. +new方法
    1. 该方法是一个类方法
    2. 通过该方法可以创建一个对象
    3. 该方法实际上做了两件事
        1. 调用+alloc分配存储空间
        2. 在调用-init进行初始化
    4. 完整地创建一个可用的对象
        1. 分配存储空间  +alloc
        2. 初始化 -init
        
    ```
     // Person *p = [Person new];
     // 1.调用+alloc分配存储空间
    // Person *p1 = [Person alloc];
    // 2.调用-init进行初始化
    // Person *p2 = [p1 init];
    ```
2. 构造方法
    1. 构造方法就是这个-init方法 
    2. 作用:用来初始化对象,是个对象方法，-开头
3. 重写构造方法
    1. 对象初始化完毕,默认成员变量都是0
    2. 重写构造方法的目的:为了让对象创建出来，成员变量就会有一些固定的值
    3. 在对象相应的类中,重写父类的构造方法(-init)
    4. 重写构造方法的注意点:
        1. 先调用父类的构造方法（[super init]）
        2. 再进行子类内部成员变量的初始化
        
    ```javascript
    #import "Person.h"
    @implementation Person
    
    // 重写-init方法
    //- (id)init
    //{
    //    // 1.一定要调用回super的init方法:初始化父类中声明的一些成员变量和其他属性
    //    self = [super init]; // 当前对象 self
    //此时的super是NSObject,那NSObject的init做了什么事情呢?
    /*
    -(id)init{
        isa = [Person class];
        return self;
    }
    */
    //    // 2.如果对象初始化成功，才有必要进行接下来的初始化
    //    if (self != nil)
    //    { // 初始化成功
    //        _age = 10;
    //    }
    //    
    //    // 3.返回一个已经初始化完毕的对象
    //    return self;
    //}
    //简写如下:
    - (id)init
    {
        //注意之这里是=不是==!!!!
        if ( self = [super init] )
        { // 初始化成功
            _age = 10;
        }
        
        // 3.返回一个已经初始化完毕的对象
        return self;
    }

    @end
    ```
4. 构造方法的执行过程
     ![](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/构造方法执行过程.png)
     
5. 自定义构造方法


