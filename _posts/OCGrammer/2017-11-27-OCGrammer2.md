---
layout: post
title: OC语法之-OC三大特性
category: OC语法
tags: OC语法
description: OC语法
---

> 面向对象的三大特性:封装/继承/多态

## 封装

1. 又叫做成员变量的封装,也就是说是针对成员变量的     
2. 为什么要对成员变量进行封装?   
为了防止像成员变量传入不合理的值,比如age这个成员变量,`p->age = -10;`这就不合理 
3. **@public**作用
    * 使一个对象在**不是当前类的实现@plementation中**(即外部)能够访问自己的成员变量(p->age),默认的情况下是不能访问,受保护的(@protected);
    * **注意:**一个类是可以直接在其实现内部(@implementation --@end)访问它的成员变量的,跟@public无关!!!
    
```javascript
#import <Foundation/Foundation.h>
@interface Person : NSObject
{   //是该成员变量能被外界(即不是在当前类中时!!!)访问
    @public
    int age;
}
- (void)walk;
@end

// 2.类的实现
@implementation Person
// 可以直接使用当前类的成员变量的!!!,因为这是在当前类的实现中
- (void)walk
{
    NSLog(@"%d岁的人走了一段路", age;
}
@end
//这里已经不是Person类了,属于外界了
int main()
{
    Person *p2 = [Person new];
    //没有@public是不可以直接访问该对象的成员变量的!!!
    p2->age = 30;
    [p2 walk];
    return 0;
}
```
### set方法和get方法

1. set方法和get方法的使用场合
    * @public的成员可以被随意赋值，应该使用set方法和get方法来管理成员的访问（类似机场的安检、水龙头过滤，过滤掉不合理的东西），比如僵尸的生命值不能为负数
2. set方法
    1. 作用： 提供一个方法给外界设置成员变量值，可以在方法里面对参数进行相应过滤
    2. 命名规范：
        1. 方法名必须以set开头
        2. set后面跟上成员变量的名称，成员变量的首字母必须大写
        3. 返回值一定是void
        4. 一定要接收一个参数，而且参数类型跟成员变量类型一致
        5. 形参的名称不能跟成员变量名一样!!!(注意哦)
3. get方法
    1. 作用：返回对象内部的成员变量
    2. 命名规范：
        1. 肯定有返回值，返回值类型肯定与成员变量类型一致
        2. 方法名跟成员变量名一样
        3. 不需要接收任何参数    
代码举例:   

```javascript
#import <Foundation/Foundation.h>
@interface Student : NSObject
{
    // 成员变量尽量不要用@public
    // @public
    int age;
    // 只读（readonly）：只允许外界访问我的no，不允许外界修改我的no
    // 只需要提供get方法
    int no;
}

// set方法
- (void)setAge:(int)newAge;
// get方法
- (int)age;
- (void)study;
@end

@implementation Student

// set方法的实现
- (void)setAge:(int)newAge
{
    // 对传进来的参数进行过滤
    if (newAge <= 0)
    {
        newAge = 1;
    }
    //如果newAge也用age,那么就会混淆了
    age = newAge;
}

- (int)age
{
    return age;
}

- (void)study
{
    NSLog(@"%d岁的学生在学习", age);
}

@end

int main()
{
    Student *stu = [Student new];
    //stu->age = -10;
    //stu->age = 10;
    [stu setAge:10];
    
    NSLog(@"学生的年龄是%d岁", [stu age]);
    
    //[stu study];
    return 0;
}
```
### 成员变量/局部变量/全局变量命名规范

1. 成员变量的命名规范`_age`
  1. 一定要以下划线 _ 开头
     2. 让成员变量和get方法的名称区分开
     3. 可以跟局部变量区分开，一看到下划线开头的变量，一般都是成员变量 
2. 全局变量通常这样命名:`age_`
3. 局部变量:`age`

```javascript
#import <Foundation/Foundation.h>
@interface Student : NSObject
{   
   //成员变量
    int _no;
}

// no的set和get方法
- (void)setNo:(int)no;
- (int)no;

@end

@implementation Student

- (void)setNo:(int)no
{
    _no = no;
}
- (int)no
{
    return _no;
}
@end

int main()
{
    Student *stu = [Student new];
    [stu setNo:10];
    [stu no];
    return 0;
}
```
### 类方法
直接可以用类名来执行的方法（类本身会在内存中占据存储空间，里面有类\对象方法列表）
   
**类方法和对象方法对比:**

1. 类方法: 
    1. 加号 + 开头
    2. 只能由类（名）来调用
    3. 类方法中不能访问成员变量（实例变量）
2. 对象方法
    1. 减号 - 开头
    2. 只能由对象来调用
    3. 对象方法中能访问当前对象的成员变量（实例变量）
3. 类方法的好处和使用场合
    1. 不依赖于对象，执行效率高
    2. 能用类方法，尽量用类方法
    3. 场合：当方法内部不需要使用到成员变量时，就可以改为类方法     
**注意:**可以允许类方法和对象方法同名   
代码举例:   

```javascript
#import <Foundation/Foundation.h>
@interface Person : NSObject
{
    int age;
}
// 类方法都是以+开头
+ (void)printClassName;
- (void)test;
+ (void)test;

@end

@implementation Person

+ (void)printClassName
{
    // error：instance variable 'age' accessed in class method
    // 实例变量age不能在类方法中访问
    //NSLog(@"这个类叫做Person-%d", age);
}

- (void)test
{
    NSLog(@"111-%d", age);
    
    //[Person test];
}
+ (void)test
{
    // 会引发死循环
    //[Person test];
    NSLog(@"333");
}
@end

int main()
{
    //类方法调用
    [Person printClassName];
    [Person test];
    //对象方法调用
    Person *p = [Person new];
    [p test];
    //对象误调用类方法
    /*
     -[Person printClassName]: unrecognized selector sent to instance 0x7fa520c0b370
     */
    // 系统会认为现在调用的printClassName是个对象方法
    //[p printClassName];
    
    return 0;
}
```
### self关键字
一句话总结:**self永远指向当前方法的调用者**  

1. 谁调用了当前方法，self就代表谁
    1. self出现在对象方法中，self就代表对象
    2. self出现在类方法中，self就代表类
2. 在对象方法利用"self->成员变量名"访问当前对象内部的成员变量,可以用于区分同名的局部变量
3. [self 方法名]可以调用其他对象方法\类方法         

代码举例:   

```javascript
#import <Foundation/Foundation.h>
@interface Dog : NSObject
{
    int _age;
}
- (void)bark;
- (void)run;
+ (void)run;
- (void)test;
+ (void)test;

@end

@implementation Dog
- (void)bark
{
    NSLog(@"汪汪汪");
}
- (void)run
{
    [self bark];
    //此时的self是当前对象
    //调用的是对象方法-test
    [self test];
    NSLog(@"跑跑跑");
}
+ (void)run{
    //调用的是对象方法+test,此时的self是当前类
    [self test];
    NSLog(@"调用了+run方法");
}
- (void)test
{
    // 会引发死循环 此时的self是当前对象
    //[self test];
    NSLog(@"调用了-test方法");
    
    //成员变量和局部变量同名时，默认采取就近原则，访问的是局部变量,但是我非要访问成员变量
    //用self访问成员变量，区分同名的局部变量
    int _age = 20;
    // self：指向了方法调用者,代表着当前对象.直接写_age,那么指的就是局部变量_age(20)了
    NSLog(@"Dog的年龄是%d岁", self->_age);
}
+ (void)test
{
    NSLog(@"调用了+test方法");
    
    // 会引发死循环 ,此时的self是当前类
    //[self test];
}

@end

int main()
{
    Dog *d = [Dog new];
    [d run];
    return 0;
}
```

## 继承


