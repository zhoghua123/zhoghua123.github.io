---
layout: post
title: OC语法之-内存管理
category: OC语法
tags: OC语法
description: OC语法
---
## 基本原理
1. 管理范围：任何继承了NSObject的对象，对其他基本数据类型（int、char、float、double、struct、enum等）无效
2. 对象的基本结构
    1. 每个OC对象都有自己的引用计数器，是一个整数，表示“对象被引用的次数”，即有多少人正在使用这个OC对象
    2. 每个OC对象内部专门有4个字节的存储空间来存储引用计数器
3. 引用计数器的作用:
    1. 当使用alloc、new或者copy创建一个新对象时，新对象的引用计数器默认就是1
    2. 当一个对象的引用计数器值为0时，对象占用的内存就会被系统回收。换句话说，如果对象的计数器不为0，那么在整个程序运行过程，它占用的内存就不可能被回收，除非整个程序已经退出
4. 操作引用计数器
    1. 给对象发送一条`retain`消息,可以使引用计数器值+1（`retain`方法返回对象本身）
    2. 给对象发送一条`release`消息,可以使引用计数器值-1(没有返回值)
    3. 可以给对象发送`retainCount`消息获得当前的引用计数器值
5. 对象的销毁
    1. 当一个对象的引用计数器值为0时，那么它将被销毁，其占用的内存被系统回收
    2. 当一个对象被销毁时，系统会自动向对象发送一条dealloc消息
    3. 一般会重写dealloc方法，在这里释放相关资源，dealloc就像对象的遗言
    4. 一旦重写了dealloc方法，就必须调用[super dealloc]，并且放在最后面调用
    5. 不要直接调用dealloc方法
    6. 一旦对象被回收了，它占用的内存就不再可用，坚持使用会导致程序崩溃（野指针错误）
6. 概念
    1. 僵尸对象 ：所占用内存已经被回收的对象，僵尸对象不能再使用
    2. 野指针 ：指向僵尸对象（不可用内存）的指针，给野指针发送消息会报错（EXC_BAD_ACCESS）
    3. 空指针 ：没有指向任何东西的指针（存储的东西是nil、NULL、0），给空指针发送消息不会报错
    
代码举例:

```javascript
////Person.h文件
#import <Foundation/Foundation.h>

@interface Person : NSObject

@property int age;

@end

//Person.m文件
#import "Person.h"

@implementation Person

// 当一个Person对象被回收的时候，就会自动调用这个方法
- (void)dealloc
{
    NSLog(@"Person对象被回收");
    
    // super的dealloc一定要调用，而且放在最后面
    [super dealloc];
}

@end

//main.m文件
#import <Foundation/Foundation.h>
#import "Person.h"

int main()
{
    // 1
    Person *p = [[Person alloc] init];
    
    NSUInteger c = [p retainCount];
    
    NSLog(@"计数器：%ld", c);
    
    // 2  retain方法返回的是对象本身
    [p retain];
    
    // 1
    [p release];
    
    // 0 野指针：指向僵尸对象（不可用内存）的指针
    [p release];
   
    // 给野指针发送消息,会报错
    // 野指针不能复活!!!
    [p retain];
    // -[Person setAge:]: message sent to deallocated instance 0x100109a10
    // 给已经释放的对象发送了一条-setAge:消息：
    p.age = 10;
    
    //安全操作:指针p变成空指针,给空指针发送消息不报错
    //p = nil;
    
    // EXC_BAD_ACCESS : 访问了一块坏的内存（已经被回收、已经不可用的内存
    // 野指针错误
    // OC不存在空指针错误，给空指针发送消息，不报错
    [p release];
    [p release];
    [p release];
    [p release];
    //不会报错
    [nil release];
    
    return 0;
}
```
## 内存管理原则
当一个对象进行管理的时候比较简单,但是多个对象联系起来的时候,就比较麻烦了.那么他们只要遵守以下原则,就仍然很好管理.

1. 只要还有人在用某个对象，那么这个对象就不会被回收
2. 你想使用（占用）某个对象，就应该让对象的计数器+1（让对象做一次retain操作）
3. 你不想再使用（占用）(**当前对象死掉或者换掉占有**)某个对象，就应该让对象的计数器-1（让对象做一次release）
4. 谁创建，谁release
    1. 如果你通过alloc、new或[mutable]copy来创建一个对象，那么你必须调用release或autorelease
    2. 换句话说，不是你创建的，就不用你去[auto]release
5. 谁retain，谁release
    1. 只要你调用了retain，无论这个对象是如何生成的，你都要调用release
6. 总结
    1. 有始有终，有加就有减
    2. 曾经让对象的计数器+1，就必须在最后让对象计数器-1
    
代码举例:

```javascript
//Book.h
#import <Foundation/Foundation.h>

@interface Book : NSObject
{
    int _price;
}
- (void)setPrice:(int)price;
- (int)price;
@end
//Book.m
#import "Book.h"
@implementation Book

- (void)setPrice:(int)price
{
    _price = price;
}

- (int)price
{
    return _price;
}
- (void)dealloc
{
    NSLog(@"Book对象被回收");
    [super dealloc];
}
@end

//Person.h
#import <Foundation/Foundation.h>
#import "Book.h"

@interface Person : NSObject
{
    Book *_book;
}
- (void)setBook:(Book *)book;
- (Book *)book;
@end
//Person.m
#import "Person.h"

@implementation Person
- (void)setBook:(Book *)book
{   //拥有做一次retain
    _book = [book retain];
}

- (Book *)book
{
    return _book;
}

- (void)dealloc
{
    //死前做一次release
    [_book release];
    NSLog(@"Person对象被回收");
    [super dealloc];
}
@end


//main.m
#import <Foundation/Foundation.h>
#import "Person.h"
#import "Book.h"

int main()
{
    // b-1
    Book *b = [[Book alloc] init];
    // p-1
    Person *p1 = [[Person alloc] init];
    
    //p1想占用b这本书那就使b做retain一次(封装在set方法中),p1死之前要把b做relase(封装在delloc中)一次
    // b-2
    [p1 setBook:b];
    
    // p-0
    // b-1
    [p1 release];
    p1 = nil;
    
    // b-0
    [b release];
    b = nil;
    return 0;
}
```
## set方法的内存管理
从上面的例子我们可以看到:

1. 当A对象(Person)想拥有B(Book)对象时,在A对象的set方法中对B对象进行一次retain操作;
2. 当A对象不想拥有B对象时,在A对象的delloc中对B对象做一次Release操作
3. 疑问:上面做的并不严谨,因为A对象不再拥有B对象,有两种情况:
    1. A对象计数器为0,被销毁时
    2. A对象替换掉旧的B对象,从新拥有一个新的B对象
4. 那么是第2种情况该怎么办呢?很显然要对旧的B也要进行一次release,那么在哪处理呢?
5. set方法的代码规范(A可能会替换掉B)
    1. 基本数据类型：直接复制

       ```
        - (void)setAge:(int)age
         { 
            _age = age;
         }
       ```
    2. OC对象类型
    
        ```
         - (void)setCar:(Car *)car
         {
            // 1.先判断是不是新传进来对象
            if ( car != _car )
            {
                // 2.对旧对象做一次release
                [_car release];
         
                // 3.对新对象做一次retain
                _car = [car retain];
            }
         }
        ```
6. dealloc方法的代码规范(A死去不再拥有B)
    1. 一定要[super dealloc]，而且放到最后面
    2. 对self（当前）所拥有的其他对象做一次release
    
    ```
     - (void)dealloc
     {
        [_car release];
        [super dealloc];
     }
    ```
    
将上面的例子中Person中的`- (void)setBook:(Book *)book`方法修改如下:

```
- (void)setBook:(Book *)book
{
    // 1.先判断是不是新传进来对象
    if (book != _book) {
        // 2.对旧对象做一次release
        [_book release];
         // 3.对新对象做一次retain
        _book = [book retain];
    }
    
}
```
main.m的代码如下:

```
#import <Foundation/Foundation.h>
#import "Person.h"
#import "Book.h"

int main()
{
    // b-1
    Book *b = [[Book alloc] init];
    //b2-1
    Book *b2 = [[Book alloc] init];
    // p-1
    Person *p1 = [[Person alloc] init];
    
    // b-2
    [p1 setBook:b];
    //P1 替换新的book b-1 b2-2
     [p1 setBook:b2];
    
    
    // p-0
    // b-1
    [p1 release];
    p1 = nil;
    
    // b-0
    [b release];
    b = nil;
    //b2-0
    [b2 release];
    b2 = nil;
    return 0;
}
```

