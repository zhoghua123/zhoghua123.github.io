---
layout: post
title:  第十九章-VC6.0的使用、C函数的反汇编、C补充
category: C语言
tags: C
keywords: C
--- 

## 新建项目
1. 新建项目
    1. 打开VC6.0
    2. 文件->新建->工程->Win32 Console Application(win32控制台应用程序)
    3. 设置工程名称:
    4. 选择保存路径
    5. 确定
    6. 选择一个空工程
    7. 点击完成，确定即可
2. 添加文件
    1. 点击文件视图：FileView
    2. 选择SourceFiles
    3. 点击工具栏的文件->新建->文件->C++ Source File
    4. 设置名称
    5. 确定即可


## 插入汇编代码

```
__asm{
    //汇编代码
}
```

## 常用快捷键

```
F7 编译
F5 运行
ctrl + F5 编译+运行
F9 设置、取消断点
F10 单步执行（单步步过）
F11 单步步入
```

## 调试程序
1. 查看汇编代码
    1. 设置断点
    2. 运行程序到断点处
    3. 右击->GO TO Disassembly
    4. 返回：`shift +F5`
2. 查看内存与寄存器
    1. 在工具栏的最右边找到memory与registers
    2. 通过F10执行，可以查看寄存器以及内存数据的变化。
3. VC6.0在转化为汇编调用call语句的时候，会转化成调用jmp指令，这个不影响。

## C函数的本质
1. C函数
    
    ```
    int  plus(int x, int y)
    {
    	return 0;
    }
    ```
2. 反汇编
    
    ```
    push        ebp
    mov         ebp,esp
    //为函数执行，划出内存64个字节，即40h，这一块也叫函数的缓冲区
    sub         esp,40h
    push        ebx
    push        esi
    push        edi
    /****将内存缓冲区全部填充为0CCCCCCCCh******/
    //将edi指向缓冲区的开始位置
    lea         edi,[ebp-40h]
    //ecx 中存放循环的次数，10h为16次
    mov         ecx,10h
    //eax中存放0CCCCCCCCh
    mov         eax,0CCCCCCCCh
    //rep循环,循环次数由ecx决定，stos串写入指令
    //把eax的值存放到edi指向的位置,然后修改地址指针，循环执行16次
    rep stos    dword ptr [edi]
    //清空eax的值为0
    xor         eax,eax
    pop         edi
    pop         esi
    pop         ebx
    mov         esp,ebp
    pop         ebp
    ret
    ```
3. C语言中参数是如何传递的？
    1. 使用堆栈传参，参数从右到左传递
4. C语言中返回值存储在EAX中

##  C中的变量

### 全局变量
1. **编译**的时候就已经确定了内存的地址和宽度，变量名就是内存的地址别名。
2. **如果不重新编译，全局变量的内存地址不变。游戏外挂中的找基址，其实就是找全局变量**
3. 全局变量中的值任何程序都可以改，是公用的。

### 局部变量
1. 局部变量是函数内部申请的，如果函数没有执行，那么局部变量没有内存空间
2. 局部变量的内存是在堆栈中分配的，程序执行时才分配，我们无法预知程序何时执行，因此我们无法确定局部变量的内存地址。
3. 因为局部变量的内存地址是不确定的，所以，局部变量只能在函数内部使用，其他函数不能使用。
4. 全局变量有默认值为0，局部变量必须先初始化，再使用。

### 变量存储的位置
1. 局部变量存储在函数帧栈的缓冲区中。
2. **C语言下，要熟记帧栈图！！！！！**：
    
    ```
    EBP 原EBP的内容
    EBP+4 返回地址
    EBP+8 参数区
    EBP-4 局部变量区域，即缓冲区
    EAX 存储返回值
    ```
    
    1. 寄存器保护区
    2. 缓冲区
    3. EBP
    4. EBP+4 返回地址
    5. EBP+8 参数区
    6. EBP-4 局部变量区域，即缓冲区
3. 这两句函数的汇编有什么意义呢？ 
    
    ```
    //此时的eax为函数内部计算的中间结果，相当于局部变量，因此放在缓冲区域内。
    mov [ebp-4],eax
    //函数即将返回，将函数最总的即时结果放入到eax，这是约定俗成。
    mov eax, [ebp-4]
    ```

### 函数嵌套调用的内存布局

![存储图片](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/cbc-01.png)

```
int plus1(int x,int y)
{
    return x+y;
}
int plus(int x,int y,int z)
{
    int m = plus1(1,2);
    ret m+z;  
}
int main()
{
    int r ;
    r = plus(1,3,4);
    return 0;
}
```

1. 反汇编中有这么几句代码
    
    ```
    //将esp恢复到分配缓冲区前的位置
    add esp,44h
    //比较esp与ebp的值
    cmp esp,ebp
    //检查是否上面的比较相等，不相等直接报错
    call __chkesp(00401120)
    
    mov esp，ebp
    ```
    
    1. 为何多了3句呢？通常回复esp直接是这一句`mov esp，ebp`就行了 这是debug环境下为了检查堆栈平衡
    2. 查看是否破坏了堆栈，如果破坏了堆栈，那么直接回报错在`__chkesp`函数了。
  
## ASCII码表的本质
1. 原理：
    1. 由于计算机只能存储1和0，不能存储字符形状，因此就把我们通常使用的符号编上编码，存入到计算机内存
    2. 这些编码与符号的对应关系，就叫ASCII表
    3. 共127个符号，这127个符号可以表达出美国人所有的语言。
2. 那么如何显示呢？ 
    1. 从内存中取出来的也是一个编号，比如：`41h`
    2. 如果我们想要输出为字符，用putchar函数
    3. 这个函数将这个编号，按照ascii表的对应关系，找到相应的字符`A`，然后将`A`画在终端上。

## 中文字符
1. 中文是怎么存储的呢？ ASCII表中并没有中文对应
2. ASCII有个扩展表，128-255，编码了一些奇异符号。
3. 中国把这些扩展重新编码，整成一张表，叫GB2312或GB2312-80
4. 这张表，0-127和原来一样，**127以后，两个大于127的字符连接在一起时，就表示一个汉字**
5. 在这些编码里，0-127中本来就有的数字、标点、字母统统重新编了2个字节长的编码，这就是常说的**全角**字符，而原来在127号以下的那些就交**半角**字符了
    1. 输入法有全角半角切换，中文分号与英文分号不同的由来。
6. 即2个大于127的编码表示一个汉字。即汉字占用2个字节。
7. 用反汇编查看可以发现，一个汉字对应2个字节，而且每个字节的编码值大于127.

### GB2312或GB2312-80的弊端
1. 两种编码可能使用相同的数字代表2个不同的符号。
    1. 同一个编码，中国代表一个汉字。日本也这么弄，那就代表是日文。
2. **Unicode**编码就是为了解决这个问题出现的。


