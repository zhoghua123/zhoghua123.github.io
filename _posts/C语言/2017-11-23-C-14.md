---
layout: post
title: 第十四章 动态内存分配
category: C语言
tags: C
keywords: C
---

## 前言
从前面我们知道:    

1. 内存是当定义一个变量时,系统才会分配内存给这个变量
2. 这些内存要么是代码块结束时释放,要么是整个程序结束时释放,都是由系统自动控制    

**疑问:**我们能不能,不定义变量而先分配一块内存,并且我们来控制他的销毁时刻呢?  
**堆区:**就是这种情况,内存由程序员随时开辟,并且必须由程序员释放,否则只有等到程序结束会回收
由于我们直接分配了一段内存,而且不指明任何类型变量,那我们怎么来用这块内存呢?内存是由地址构成,因此只要我们拿到这块内存的第一个地址就行了,即用void *指针表示这个块内存     
## 怎样建立内存的动态分配  
> 对于内存的动态分配是通过系统提供的库函数来实现的,主要有malloc,calloc,free,realloc这4个函数,函数的声明在stdlib.h文件中

1. **malloc**函数     
    函数原型为:  
    void *malloc(unsigned int size);    
    其作用是在内存的动态存储区域中分配一个长度为size的连续存储空间.函数的返回值是所分配内存的d一个字节地址,或者说,此函数是一个指针函数,返回的指针指向该分配区域的开头位置.如:  
    //开辟100字节的零时分配域,函数值为第一个字节的地址
    `malloc(100);`  
    注意:指针类型为void * ,即不指向任何数据类型,只提供一个地址,如果函数未能成功的执行(如内存空间不够),则返回空指针(NULL);

2. **calloc**函数   
    函数原型为:  
    void *calloc(unsigned n,unsigned size); 
    其作用是在内存的动态存储区域中分配n个长度为sized的连续空间,这个空间一般比较大,足以保存一个数组.    
    用calloc函数可以为一维数组开辟动态存储空间,n为数组元素的个数,每个元素的长度为size.这就是动态数组,函数返回指向所分配的起始位置的指针,如果分配不成功,则返回空指针(NULL);如:   
    
    //开辟5*40个 字节的临时分配区域,把起始地址赋值给指针变量p
    `p = calloc(50,4);`     
    
3. **free**函数     
    函数原型为:  
    void free(void *p);     
    其作用是释放指针变量p所指向的动态空间,使这部分空间能重新被其他变量使用.p应是最近一次调用calloc或者malloc函数时得到的函数返回值.如:  
    `free(p);`  
    函数free无返回值. 

4. **realloc**函数  
函数原型为:  
void *realloc(void *p ,unsigned int size);  
如果已经通过malloc或者calloc函数申请了一些动态存储空间,想改变其大小,可以用realloc函数重新分配   
用realloc函数将p所指向的动态空间的大小改变为size.p的值不变,如果重分配不成功,返回NULL.如:     
`realloc(p,50);`    





