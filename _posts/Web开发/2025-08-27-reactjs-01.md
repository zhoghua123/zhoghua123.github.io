---
layout: post
title: ReactJS语法-虚拟DOM
category: Web开发
tags: Web开发
description: Web开发
--- 

## 虚拟DOM（Virtual Document Object Model）
1. DOM的本质：就是用JS表示的UI元素，即用浏览器中的JS提供API获取html中的某个元素。
2. 虚拟DOM：并不是由浏览器提供的，而是我们程序员手动模拟实现的，类似于浏览器中的DOM，但是有着本质的区别；
3. 虚拟DOM的使用目的：为了实现DOM节点的高效更新。
    1. 场景：有个列表页面，有n行n列数据，点击每列表头可以对整个表进行升降排序。
    2. 普通实现方案：当点击x列时，首先将数据源按照该列进行排序，然后使用for循环重新生成每列元素标签，填充最新数据。
    3. 缺点：如果某次排序仅仅变动了其中的2行数据，那么每次点击整个表格部分DOM要重新创建，非常消耗浏览器性能。
    4. 理想方法：每次点击排序只需要更新这两条需要调整的元素即可。
    5. 解决方案：1. 用js对象来描述整个表格的DOM---旧DOM。2.点击排序后的数据，用JS创建新的对象DOM---新DOM 3. 将旧、新进行对比，校验出不同的地方。 4. 只更新不同数据的元素。
4. 虚拟DOM的本质：使用JS对象来模拟DOM树
    1. 用虚拟DOM实现`<p title="123">真好<span>456</span></p>`
    2. 实现虚拟DOM如下：
        
        ```
        var p = {
            tagName:"p",
            arrts:{
                title: "123",
                id: ""
            },
            children:{
                "真好",
                {
                    tagName:"span",
                    children:{
                        "456"
                    }
                }
            }
        }
        ```
5. React框架已经实现了虚拟DOM的，无需自己麻烦创建。
6. 新旧DOM如何进行比对呢？-----Diff算法
![pic](https://gitee.com/zhonghua123/blogimgs/raw/master/img/webjs-57.png/)

### Diff算法
 1. tree diff:新旧DOM树，逐层对比的方式，就叫做 tree diff,每当我们从前到后，把所有层的节点对比完后，必然能够找到那些 需要被更新的元素；
 2. component diff：在对比每一层的时候，组件之间的对比，叫做 component diff;当对比组件的时候，如果两个组件的类型相同，则暂时认为这个组件不需要被更新，如果组件的类型不同，则立即将旧组件移除，新建一个组件，替换到被移除的位置；
 3. element diff:在组件中，每个元素之间也要进行对比，那么，元素级别的对比，叫做 element diff；
 4. key：key这个属性，可以把 页面上的 DOM节点 和 虚拟DOM中的对象，做一层关联关系；

 ### 代码举例
 1. main.js文件
    
    ```
    // 1. 在 React 需要安装 两个包 react  react-dom
    // 1.1 react 这个包，是专门用来创建React组件、组件生命周期等这些东西的；
    // 1.2 react-dom 里面主要封装了和 DOM 操作相关的包，比如，要把 组件渲染到页面上
    import React from 'react'
    import ReactDOM from 'react-dom'
    
    // 2. 创建 DOM 元素
    // React.createElement() 方法，用于创建 虚拟DOM 对象，它接收 3个及以上的参数
    // 参数1： 是个字符串类型的参数，表示要创建的元素类型
    // 参数2： 是一个属性对象，表示 创建的这个元素上，有哪些属性
    // 参数3： 从第三个参数的位置开始，后面可以放好多的虚拟DOM对象，这写参数，表示当前元素的子节点
    // <div title="this is a div" id="mydiv">这是一个div</div>
    var myH1 = React.createElement('h1', null, '这是一个大大的H1')
    var myDiv = React.createElement('div', { title: 'this is a div', id: 'mydiv' }, '这是一个div', myH1)
    
    //3. 使用ReactDOM把元素渲染到页面指定的容器中上
    / ReactDOM.render('要渲染的虚拟DOM元素', '要渲染到页面上的哪个位置中')
    // 注意： ReactDOM.render() 方法的第二个参数，不接受 "#app" 这样的字符串，而是需要传递一个 原生的 DOM 对象
    ReactDOM.render(myDiv，document.getElementById('app'))
    ```
2. index.html
    
    ```
    <body>
      <!-- 这是一个容器，将来 使用 react 渲染的虚拟DOM，都会放到这个容器中 -->
      <div id="app"></div>
    </body>
    ```
    
## JSX
1. 如果创建很多虚拟DOM使用React.createElement，那么会很麻烦，是否可以向直接写HTML标签的样式来快速创建虚拟DOM呢？---JSX
2. React 官方，就提出了一套 JSX 语法规范，能够让我们在 JS 文件中，书写类似于 HTML 那样的代码，快速定义虚拟DOM结构；
3. 本质：哪怕我们写了 JSX 这样的标签，也并不是直接把 我们的 HTML 标签渲染到页面上，而是先转换成 React.createElement 这样的JS代码，再渲染到页面中；（JSX是一个对程序员友好的语法糖）
4. 如果要在 JSX 语法内部，书写 JS 代码了，那么，所有的JS代码，必须写到 {} 内部；
5. 当 编译引擎，在编译JSX代码的时候，如果遇到了<那么就把它当作 HTML代码去编译，如果遇到了 {} 就把 花括号内部的代码当作 普通JS代码去编译；
6. 在{}内部，可以写任何符合JS规范的代码；
7. 在JSX中，如果要为元素添加class属性了，那么，必须写成className，因为 class在ES6中是一个关键字；和class类似，label标签的 for 属性需要替换为 htmlFor.
8. 在JSX创建DOM的时候，所有的节点，必须有唯一的根元素进行包裹（下面案例div包裹了h1,p,label）；
9. 如果要写注释了，注释必须放到 {} 内部
10. 如果要直接使用 JSX 语法，需要先安装相关的 语法转换工具，
    
    ```
    运行 cnpm i babel-preset-react -D
    ```
5. 举例
    
    ```
    //js代码
    var mytitle = '这是使用变量定义的 tilte 值'
    
    //创建10个p标签
    var arr = []
    for (var i = 0; i < 10; i++) {
      //虚拟DOM
      var p = <p className="myp" key={i}>但是，你知道它的本质吗？？？</p>
      arr.push(p)
    }
    
    //1. JSX创建虚拟DOM
    var mydiv = <div>
    这是使用 jsx 语法创建的div元素
    {//mytitle 是js语法，因此要用{} }
    <h1 title={mytitle + 'aaaaa'}>哈哈哈，JSX真好用啊</h1>
   {//必须写成className}
    <p className="myp">但是，你知道它的本质吗？？？</p>
    <label htmlFor=""></label>

    {//创建10个p标签}
    {arr}
    </div>
    
    //2. 渲染
    ReactDOM.render(mydiv，document.getElementById('app'))
    ```

## React 组件

### 最基本的组件
1. 在React中，构造函数，就是一个最基本的组件
2. 如果想要把组件放到页面中，可以把 构造函数的名称，当作 组件的名称，以 HTML标签形式引入页面中即可
3. **注意：** React在解析所有的标签的时候，是以标签的首字母来区分的，如果标签的首字母是小写，那么就按照 普通的 HTML 标签来解析，如果 首字母是大写，则按照 组件的形式去解析渲染
4. 结论：组件的首字母必须是大写
    
```
//1. 定义组件Hello,首字母必须大写
function Hello() {
    return <div>
        <h1>这是在Hello组件中定义的元素</h1>
    </div>
}
    
//2. 渲染组件
ReactDOM.render(<div>
    <Hello></Hello>
</div>，document.getElementById('app'))
```

#### 组件传值
    
 ```
//1. 定义组件Hello,首字母必须大写
function Hello(props) {
    // 在组件中，如果想要使用外部传递过来的数据，必须，显示的在 构造函数参数列表中，定义 props 属性来接收；
    // 通过 props 得到的任何数据都是只读的，不能从新赋值
    // props.name = '000'
    return <div>
        <h1>这是在Hello组件中定义的元素---{props.name}</h1>
    </div>
}
    
// var name = 'zs'
// var age = 20
var person = {
  name: 'ls',
  age: 22,
  gender: '男',
  address: '北京'
}
//2. 渲染组件
ReactDOM.render(<div>
    {//<Hello name={person.name} age={person.age} gender={person.gender} address={person.address}></Hello>}
    {//简要写法}
    <Hello {...person}></Hello>
</div>，document.getElementById('app'))
// 注意：这里 ...Obj  语法，是 ES6中的属性扩散， 表示，把这个对象上的所有属性，展开了，放到这个位置
```

#### jsx文件
1. 将上面封装的Hello组件，单独放到一个Hello.jsx文件中
    
    ```
    import React from 'react'
    function Hello(props) {
      return <div>
        <h1>这是在Hello组件中定义的元素 --- {props.name}</h1>
        <p id="">哈哈哈哈</p>
      </div>
    }
    
    // 把创建的组件暴露出去
    export default Hello
    ```
2. main.js中引用
    
    ```
    import Hello from './components/Hello.jsx'
    ```
   
### 创建组件的第二种方式
1. 创建一个Hello2组件
    
    ```
    import React from 'react'
    // 使用 class 创建的类，通过 extends 关键字，继承React.Component，这个类，就是一个组件的模板了
    // 如果想要引用这个组件，可以把 类的名称， 以标签形式，导入到 JSX 中使用
    class Hello2 extends React.Component {
        // 在 class 实现的组件内部，必须定义一个 render 函数
        render() {
            // 在 render 函数中，还必须 return 一个东西，如果没有什么需要被return 的，则需要 return null
            return <div>
              <h1>这是 使用 class 类创建的组件</h1>
            </div>
        }
    
    }
    ```
    
#### 组件数据传值  

```
class Hello2 extends React.Component {
    constructor(props) {
    // 注意： 如果使用 extends 实现了继承，那么在 constructor 的第一行，一定要显示调用一下 super()
    //  super() 表示父类的构造函数
    super(props)
    // 在 constructor 中，如果想要访问 props 属性，不能直接使用 this.props， 而是需要在 constructor 的构造器参数列表中，显示的定义 props 参数来接收，才能正常使用；
    console.log(props)
    
        // 注意： 这是固定写法，this.state 表示 当前组件实例的私有数据对象
        // 如果想要使用 组件中 state 上的数据，直接通过 this.state.*** 来访问即可
        this.state = {
          msg: '这是 Hello2 组件的私有msg数据',
          info: '瓦塔西***'
        }
    }
    render() {
        // 虽然在 React dev tools 中，并没有显示说 class 组件中的 props 是只读的，但是，经过测试得知，其实 只要是 组件的 props，都是只读的；
        // this.props.address = '123'

        return <div>
          <h1>这是 使用 class 类创建的组件</h1>
          <h3>外界传递过来的数据是： {this.props.address} --- {this.props.info}</h3>
          <h5>{this.state.msg}</h5>
        </div>
    }
    
}

ReactDOM.render(<div>
  <Hello2 address="xxx" info="XXX程序员"></Hello2>
</div>, document.getElementById('app'))
```

#### 访问组件的私有数据

```
class Hello2 extends React.Component {
    constructor(props) {
        super(props)
        // 注意： 这是固定写法，this.state 表示 当前组件实例的私有数据对象，就好比 vue 中，组件实例身上的 data(){ return {} } 函数
        // 如果想要使用 组件中 state 上的数据，直接通过 this.state.*** 来访问即可
        this.state = {
          msg: '这是 Hello2 组件的私有msg数据',
          info: '瓦塔西***'
        }
    }
    
    render() {
        return <div>
          <h1>这是 使用 class 类创建的组件</h1>
          <h3>外界传递过来的数据是： {this.props.address} --- {this.props.info}</h3>
          //访问私有数据
          <h5>{this.state.msg}</h5>
          
          //修改组件私有数据
          {/* 1.1 在React中，如果想要为元素绑定事件，不能使用 网页中 传统的 onclick 事件，而是需要 使用 React 提供的  onClick */}
          {/* 1.2 也就是说：React中，提供的事件绑定机制，使用的 都是驼峰命名，同时，基本上，传统的 JS 事件，都被 React 重新定义了一下，改成了 驼峰命名 onMouseMove  */}
          {/* 2.1 在 React 提供的事件绑定机制中，事件的处理函数，必须直接给定一个 function，而不是给定一个 function 的名称 */}
          {/* 2.2 在为 React 事件绑定 处理函数的时候，需要通过 this.函数名， 来把 函数的引用交给 事件 */}
          <input type="button" value="修改 msg" id="btnChangeMsg" onClick={this.changeMsg} />
          <br />

        </div>
    }
    
    changeMsg = () => {

    // 直接使用 this.state.msg = '123' 为 state 上的数据重新赋值，可以修改 state 中的数据值，但是，页面不会被更新；
    // 所以这种方式，React 不推荐，以后尽量少用；
    // this.state.msg = '123'

    // 如果要为 this.state 上的数据重新赋值，那么，React 推荐使用 this.setState({配置对象}) 来重新为 state 赋值
    // 注意： this.setState 方法，只会重新覆盖那些 显示定义的属性值，如果没有提供最全的属性，则没有提供的属性值，不会被覆盖；
    /* this.setState({
      msg: '123'
    }) */

    // this.setState 方法，也支持传递一个 function，如果传递的是 function，则在 function 内部，必须return 一个 对象；
    // 在 function 的参数中，支持传递两个参数，其中，第一个参数是 prevState，表示为修改之前的 老的 state 数据
    // 第二个参数，是 外界传递给当前组件的 props 数据
    this.setState(function (prevState, props) {
      // console.log(props)
      return {
        msg: '123'
      }
    }, function () {
      // 由于 this.setState 是异步执行的，所以，如果想要立即拿到最新的修改结果，最保险的方式， 在回调函数中去操作最新的数据
      console.log(this.state.msg)
    })
    // 经过测试发现， this.setState 在调用的时候，内部是异步执行的，所以，当立即调用完 this.setState 后，输出 state 值可能是旧的
    // console.log(this.state.msg)
  }
}
```
