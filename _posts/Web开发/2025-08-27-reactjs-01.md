---
layout: post
title: ReactJS语法-虚拟DOM、JSX、组件、组件样式
category: Web开发
tags: Web开发
description: Web开发
--- 

## 虚拟DOM（Virtual Document Object Model）
1. DOM的本质：就是用JS表示的UI元素，即用浏览器中的JS提供API获取html中的某个元素。
2. 虚拟DOM：并不是由浏览器提供的，而是我们程序员手动模拟实现的，类似于浏览器中的DOM，但是有着本质的区别；
3. 虚拟DOM的使用目的：为了实现DOM节点的高效更新。
    1. 场景：有个列表页面，有n行n列数据，点击每列表头可以对整个表进行升降排序。
    2. 普通实现方案：当点击x列时，首先将数据源按照该列进行排序，然后使用for循环重新生成每列元素标签，填充最新数据。
    3. 缺点：如果某次排序仅仅变动了其中的2行数据，那么每次点击整个表格部分DOM要重新创建，非常消耗浏览器性能。
    4. 理想方法：每次点击排序只需要更新这两条需要调整的元素即可。
    5. 解决方案：1. 用js对象来描述整个表格的DOM---旧DOM。2.点击排序后的数据，用JS创建新的对象DOM---新DOM 3. 将旧、新进行对比，校验出不同的地方。 4. 只更新不同数据的元素。
4. 虚拟DOM的本质：使用JS对象来模拟DOM树
    1. 用虚拟DOM实现`<p title="123">真好<span>456</span></p>`
    2. 实现虚拟DOM如下：
        
        ```
        var p = {
            tagName:"p",
            arrts:{
                title: "123",
                id: ""
            },
            children:{
                "真好",
                {
                    tagName:"span",
                    children:{
                        "456"
                    }
                }
            }
        }
        ```
5. React框架已经实现了虚拟DOM的，无需自己麻烦创建。
6. 新旧DOM如何进行比对呢？-----Diff算法
![pic](https://gitee.com/zhonghua123/blogimgs/raw/master/img/webzh_57.png/)

### Diff算法
 1. tree diff:新旧DOM树，逐层对比的方式，就叫做 tree diff,每当我们从前到后，把所有层的节点对比完后，必然能够找到那些 需要被更新的元素；
 2. component diff：在对比每一层的时候，组件之间的对比，叫做 component diff;当对比组件的时候，如果两个组件的类型相同，则暂时认为这个组件不需要被更新，如果组件的类型不同，则立即将旧组件移除，新建一个组件，替换到被移除的位置；
 3. element diff:在组件中，每个元素之间也要进行对比，那么，元素级别的对比，叫做 element diff；
 4. key：key这个属性，可以把 页面上的 DOM节点 和 虚拟DOM中的对象，做一层关联关系；

 ### 代码举例
 1. main.js文件（**注意，该文件是webpack下默认的打包入口文件，其他js文件导入该文件即可**）
    
    ```
    // 1. 在 React 需要安装 两个包 react  react-dom
    // 1.1 react 这个包，是专门用来创建React组件、组件生命周期等这些东西的；
    // 1.2 react-dom 里面主要封装了和 DOM 操作相关的包，比如，要把 组件渲染到页面上
    import React from 'react'
    import ReactDOM from 'react-dom'
    
    // 2. 创建 DOM 元素
    // React.createElement() 方法，用于创建 虚拟DOM 对象，它接收 3个及以上的参数
    // 参数1： 是个字符串类型的参数，表示要创建的元素类型
    // 参数2： 是一个属性对象，表示 创建的这个元素上，有哪些属性
    // 参数3： 从第三个参数的位置开始，后面可以放好多的虚拟DOM对象，这写参数，表示当前元素的子节点
    // <div title="this is a div" id="mydiv">这是一个div</div>
    var myH1 = React.createElement('h1', null, '这是一个大大的H1')
    var myDiv = React.createElement('div', { title: 'this is a div', id: 'mydiv' }, '这是一个div', myH1)
    
    //3. 使用ReactDOM把元素渲染到页面指定的容器中上
    / ReactDOM.render('要渲染的虚拟DOM元素', '要渲染到页面上的哪个位置中')
    // 注意： ReactDOM.render() 方法的第二个参数，不接受 "#app" 这样的字符串，而是需要传递一个 原生的 DOM 对象
    ReactDOM.render(myDiv，document.getElementById('app'))
    ```
2. index.html（**注意，该文件是webpack下默认的页面加载入口，且会自动导入main.js**）
    
    ```
    <body>
      <!-- 这是一个容器，将来 使用 react 渲染的虚拟DOM，都会放到这个容器中 -->
      <div id="app"></div>
    </body>
    ```
    
## JSX

### 认识JSX语法
1. 如果创建很多虚拟DOM使用React.createElement，那么会很麻烦，是否可以向直接写HTML标签的样式来快速创建虚拟DOM呢？---JSX
2. React 官方，就提出了一套 JSX 语法规范，能够让我们在 JS 文件中，书写类似于 HTML 那样的代码，快速定义虚拟DOM结构；
3. JSX是一种JavaScript的语法扩展(eXtension)，也在很多地方称之为JavaScript XML，因为看起就是一段XML语法。
4. 它用于描述我们的UI界面，并且其完成可以和JavaScript融合在一起使用
5. 本质：哪怕写了 JSX 这样的标签，也并不是直接渲染到页面上，而是先转换成React.createElement 这样的JS代码，再渲染到页面中；（JSX是一个对程序员友好的语法糖）

### JSX的书写规范
1. 在JSX创建DOM的时候，所有的节点，必须有唯一的根元素进行包裹（下面案例div包裹了h1,p,label）；
2. 注释必须放到 {} 内部
3. 如果要在 JSX 语法内部，书写 JS 代码了，那么，所有的JS代码，必须写到 {} 内部；
4. 当编译引擎，在编译JSX代码的时候，如果遇到了<那么就把它当作 HTML代码去编译，如果遇到了 {} 就把 花括号内部的代码当作 普通JS代码去编译；
5. JSX嵌入**变量**作为子元素
    1. 当变量是Number、String、Array类型时，可以直接显示
    2. 当变量是null、undefined、Boolean类型时，内容为空;
        1. 如果希望可以显示null、undefined、Boolean，那么需要转成字符串，
    3. **Object对象类型不能作为子元素(not valid as a React child)**
6. JSX嵌入**表达式**
    1. 运算表达式
    2. 三元运算符
    3. 执行一个函数
7. 在JSX中，如果要为元素添加class属性了，那么，必须写成className，因为 class在ES6中是一个关键字；和class类似，label标签的 for 属性需要替换为 htmlFor.
8. 如果要直接使用 JSX 语法，需要先安装相关的 语法转换工具，
    
    ```
    运行 cnpm i babel-preset-react -D
    ```
5. 举例
    
    ```
    //js代码
    var mytitle = '这是使用变量定义的 tilte 值'
    
    //创建10个p标签
    var arr = []
    for (var i = 0; i < 10; i++) {
      //虚拟DOM
      var p = <p className="myp" key={i}>但是，你知道它的本质吗？？？</p>
      arr.push(p)
    }
    var a = true;
    var b = {
            name = "zh"
            }
    var c = "123";
    var isActive = true;
    //左上角单引号
    const className=`abc cba ${isActive ?'active':''}`
    
    //1. JSX创建虚拟DOM
    var mydiv = <div>
        这是使用 jsx 语法创建的div元素
        {//mytitle 是js语法，因此要用{} }
        <h1 title={mytitle + 'aaaaa'}>哈哈哈，JSX真好用啊</h1>
        {//不会显示 }
        <h1 title={a}>哈哈哈，JSX真好用啊</h1>
        {//会报错，对象类型不能作为子元素 }
        <h1 title={b}>哈哈哈，JSX真好用啊</h1>
        {//创建10个p标签}
        {arr}
        {//运算表达式}
        <h2>{firstName + "" + lastName}</h2>
        {//三元运算符}
        <h2>{age >=18 ?"成年人":"未成年人"}</h2>
        {//执行一个函数}
        <ul>{this.getMovieEls()}</u1>
        {//必须写成className}
        <p className="myp">但是，你知道它的本质吗？？？</p>
        <label htmlFor=""></label>
        {//属性绑定变量}
        <label title={c}></label>
        {//属性动态绑定}
        <label className={className}></label>
        {//绑定style属性}
        <h2 style={{color:"red",fontsize:"30px"}}>呵呵呵呵</h2>
    </div>
    
    getMovieEls(){
        const liEls =this.state.movies.map(movie =><li>{movie}</li>)
        return liEls
    )
    //2. 渲染
    ReactDOM.render(mydiv，document.getElementById('app'))
    ```

### JSX的基本使用
### JSX的事件绑定
### JSX的条件渲染
### JSX的列表渲染
### JSX的原理和本质



## React 组件

### 函数组件
1. 在React中，构造函数，就是一个最基本的组件
2. 如果想要把组件放到页面中，可以把 构造函数的名称，当作 组件的名称，以 HTML标签形式引入页面中即可
3. **注意：** React在解析所有的标签的时候，是以标签的首字母来区分的，如果标签的首字母是小写，那么就按照 普通的 HTML 标签来解析，如果 首字母是大写，则按照 组件的形式去解析渲染，即**组件的首字母必须是大写**
    
```
//1. 定义组件Hello,首字母必须大写
function Hello() {
    return <div>
        <h1>这是在Hello组件中定义的元素</h1>
    </div>
}
    
//2. 渲染组件
ReactDOM.render(<div>
    <Hello></Hello>
</div>，document.getElementById('app'))
```

#### 组件传值
    
 ```
//1. 定义组件Hello,首字母必须大写
function Hello(props) {
    // 在组件中，如果想要使用外部传递过来的数据，必须，显示的在 构造函数参数列表中，定义 props 属性来接收；
    // 通过 props 得到的任何数据都是只读的，不能从新赋值
    // props.name = '000'
    return <div>
        <h1>这是在Hello组件中定义的元素---{props.name}</h1>
    </div>
}
    
// var name = 'zs'
// var age = 20
var person = {
  name: 'ls',
  age: 22,
  gender: '男',
  address: '北京'
}
//2. 渲染组件
ReactDOM.render(<div>
    {//<Hello name={person.name} age={person.age} gender={person.gender} address={person.address}></Hello>}
    {//简要写法}
    <Hello {...person}></Hello>
</div>，document.getElementById('app'))
// 注意：这里 ...Obj  语法，是 ES6中的属性扩散， 表示，把这个对象上的所有属性，展开了，放到这个位置
```

#### jsx文件
1. 将上面封装的Hello组件，单独放到一个Hello.jsx文件中
    
    ```
    import React from 'react'
    function Hello(props) {
      return <div>
        <h1>这是在Hello组件中定义的元素 --- {props.name}</h1>
        <p id="">哈哈哈哈</p>
      </div>
    }
    
    // 把创建的组件暴露出去
    export default Hello
    ```
2. main.js中引用
    
    ```
    import Hello from './components/Hello.jsx'
    ```
   
### class创建组件
1. 使用 class 创建的类，通过 extends 关键字，继承React.Component，这个类，就是一个组件的模板
2. 在 class 实现的组件内部，必须定义一个 render 函数
3. 在 render 函数中，返回的是JSX内容，如果没有什么需要被return 的，则需要 return null。
4. 如果想要引用这个组件，可以把 类的名称， 以标签形式，导入到 JSX 中使用
5. 创建一个Hello2组件
    
    ```
    import React from 'react'
    class Hello2 extends React.Component {
        // 必须定义render函数
        render() {
            // 在 render 函数中，还必须 return 一个东西，如果没有什么需要被return 的，则需要 return null
            return <div>
              <h1>这是 使用 class 类创建的组件</h1>
            </div>
        }
    }
    ```
#### 组件中的数据
1. 在组件中的数据，可以分成两类:
    1. 参与界面更新的数据:当数据变化时，需要更新组件染的内容，
    2. 不参与界面更新的数据:当数据变化时，不需要更新将组建渲染的内容;
2. 参与界面更新的数据我们也可以称之为是**参与数据流**，这个数据是**定义在当前对象的state中**
    1. 可以通过在构造函数中 this.state ={定义的数据}
    2. 当我们的数据发生变化时，可以调用 this.setState 来更新数据，并且通知React进行update操作;
    3. 在进行update操作时，就会重新调用render函数，并且使用最新的数据，来渲染界面
    
#### 组件数据传值  

```
class Hello2 extends React.Component {
    constructor(props) {
    // 注意： 如果使用 extends 实现了继承，那么在 constructor 的第一行，一定要显示调用一下 super()，super() 表示父类的构造函数
    super(props)
    // 在 constructor 中，如果想要访问 props 属性，不能直接使用 this.props， 而是需要在 constructor 的构造器参数列表中，显示的定义 props 参数来接收，才能正常使用；
    console.log(props)
    
        // 注意： 这是固定写法，this.state 表示 当前组件实例的私有数据对象
        // 如果想要使用 组件中 state 上的数据，直接通过 this.state.*** 来访问即可
        this.state = {
          msg: '这是 Hello2 组件的私有msg数据',
          info: '瓦塔西***'
        }
    }
    render() {
        // 虽然在 React dev tools 中，并没有显示说 class 组件中的 props 是只读的，但是，经过测试得知，其实 只要是 组件的 props，都是只读的；
        // this.props.address = '123'

        return <div>
          <h1>这是 使用 class 类创建的组件</h1>
          <h3>外界传递过来的数据是： {this.props.address} --- {this.props.info}</h3>
          <h5>{this.state.msg}</h5>
        </div>
    }
    
}

ReactDOM.render(<div>
  <Hello2 address="xxx" info="XXX程序员"></Hello2>
</div>, document.getElementById('app'))
```

#### 访问组件的私有数据

```
class Hello2 extends React.Component {
    constructor(props) {
        super(props)
        // 注意： 这是固定写法，this.state 表示 当前组件实例的私有数据对象
        // 如果想要使用 组件中 state 上的数据，直接通过 this.state.*** 来访问即可
        this.state = {
          msg: '这是 Hello2 组件的私有msg数据',
          info: '瓦塔西***'
        }
    }
    
    render() {
        return <div>
          <h1>这是 使用 class 类创建的组件</h1>
          <h3>外界传递过来的数据是： {this.props.address} --- {this.props.info}</h3>
          //访问私有数据
          <h5>{this.state.msg}</h5>
          
          //修改组件私有数据
          {/* 1.1 在React中，如果想要为元素绑定事件，不能使用 网页中 传统的 onclick 事件，而是需要 使用 React 提供的  onClick */}
          {/* 1.2 也就是说：React中，提供的事件绑定机制，使用的 都是驼峰命名，同时，基本上，传统的 JS 事件，都被 React 重新定义了一下，改成了 驼峰命名 onMouseMove  */}
          {/* 2.1 在 React 提供的事件绑定机制中，事件的处理函数，必须直接给定一个 function，而不是给定一个 function 的名称 */}
          {/* 2.2 在为 React 事件绑定 处理函数的时候，需要通过 this.函数名， 来把 函数的引用交给 事件 */}
          <input type="button" value="修改 msg" id="btnChangeMsg" onClick={this.changeMsg} />
          <br />

        </div>
    }
    
    changeMsg = () => {

    // 直接使用 this.state.msg = '123' 为 state 上的数据重新赋值，可以修改 state 中的数据值，但是，页面不会被更新；
    // 所以这种方式，React 不推荐，以后尽量少用；
    // this.state.msg = '123'

    // 如果要为 this.state 上的数据重新赋值，那么，React 推荐使用 this.setState({配置对象}) 来重新为 state 赋值,一旦数据发生改变页面会自动刷新！！！！！
    // 注意： this.setState 方法，只会重新覆盖那些 显示定义的属性值，如果没有提供最全的属性，则没有提供的属性值，不会被覆盖（info属性）；
    /* this.setState({
      msg: '123'
    }) */

    // this.setState 方法，也支持传递一个 function，如果传递的是 function，则在 function 内部，必须return 一个 对象；
    // 在 function 的参数中，支持传递两个参数，其中，第一个参数是 prevState，表示为修改之前的 老的 state 数据
    // 第二个参数，是 外界传递给当前组件的 props 数据
    this.setState(function (prevState, props) {
      // console.log(props)
      return {
        msg: '123'
      }
      
    }, function () {
        //callback：回调函数
      // 由于 this.setState 是异步执行的，所以，如果想要立即拿到最新的修改结果，最保险的方式， 在回调函数中去操作最新的数据
      console.log(this.state.msg)
    })
    // 经过测试发现， this.setState 在调用的时候，内部是异步执行的，所以，当立即调用完 this.setState 后，输出 state 值可能是旧的
    // console.log(this.state.msg)
  }
}
```

#### Hello2单独创建jsx组件
1. 将以上的Hello2组件单独封装到Hello2.jsx如下：
    
    ```
    import React from 'react'
    export default class Hello2 extends React.Component {
        //....不变
    }
    ```
2. main.js导入
    
    ```
    // 在使用 Hello 组件之前，先导入 组件
    import Hello2 from './components/Hello2.jsx'
    ```

### 两种创建组件方式比较
1. 使用 function 构造函数创建的组件，内部没有 state 私有数据，只有 一个 props 来接收外界传递过来的数据；
2. 使用 class 关键字 创建的组件，内部，除了有 this.props 这个只读属性之外，还有一个 专门用于 存放自己私有数据的 this.state 属性，这个 state 是可读可写的！
3. 使用 function 创建的组件，叫做**无状态组件**；使用 class 创建的组件，叫做**有状态组件**
4. 有状态组件和无状态组件，最本质的区别，就是有无 state 属性；同时， class 创建的组件，有自己的生命周期函数，但是，function 创建的 组件，没有自己的生命周期函数；
5. 什么时候使用 有状态组件，什么时候使用无状态组件呢？
    1. 如果一个组件需要存放自己的私有数据，或者需要在组件的不同阶段执行不同的业务逻辑，此时，非常适合用 class 创建出来的有状态组件；
    2. 如果一个组件，只需要根据外界传递过来的 props，渲染固定的 页面结构就完事儿了，此时，非常适合使用 function 创建出来的 无状态组件；（使用无状态组件的小小好处： 由于剔除了组件的生命周期，所以，运行速度会相对快一些）
    
### props&state
1. props属性只读，不能修改
2. state为组件私有数据属性，一旦通过`this.setState({配置对象})`设置，自动刷新页面.

## 组件的CSS样式导入
1. 实现场景：实现一个评论列表，数据源如下：
    
    ```
    CommentList = [
        { user: '张三', content: '哈哈，沙发' },
        { user: '张三2', content: '哈哈，板凳' },
        { user: '张三3', content: '哈哈，凉席' },
        { user: '张三4', content: '哈哈，砖头' },
        { user: '张三5', content: '哈哈，楼下山炮' }
    ]
    ```
2. 创建CommentList.jsx
    
    ```
    import React from 'react'
    // 导入当前组件需要的子组件
    import CommentItem from './CommentItem.jsx'
    // 评论列表组件
    export default class CommentList extends React.Component {
      constructor(props) {
        super(props)
    
        // 定义当前评论列表组件的 私有数据
        this.state = {
          cmts: [
            { user: '张三', content: '哈哈，沙发' },
            { user: '张三2', content: '哈哈，板凳' },
            { user: '张三3', content: '哈哈，凉席' },
            { user: '张三4', content: '哈哈，砖头' },
            { user: '张三5', content: '哈哈，楼下山炮' }
          ]
        }
      }
    
      // 在 有状态组件中， render 函数是必须的，表示，渲染哪些 虚拟DOM元素并展示出来
      render() {
        //返回每一行item
        return <div>
          {/* 我们可以直接在 JSX 语法内部，使用 数组的 map 函数，来遍历数组的每一项，并使用 map 返回操作后的最新的数组 */}
          {this.state.cmts.map((item, i)  => {
            return <div key={i}>
                <h1>评论人：{item.user}</h1>
                <h1>评论内容：{item.content}</h1>
            </div>
          })}
        </div>
      }
    }
    ```
3. main.js
    
    ```
    // JS打包入口文件
    // 1. 导入 React包
    import React from 'react'
    import ReactDOM from 'react-dom'
    // 导入评论列表组件
    import CommentList from './components/comment1/CommentList.jsx'
    ReactDOM.render(<div>
      <CommentList></CommentList>
    </div>, document.getElementById('app'))
    ```
4. 封装评论项：CommentItem
    1. 把列表的每一行封装成一个item
    2. 新建CommentItem.jsx
    
    
    ```
    import React from 'react'
    // 封装一个 评论项 组件，此组件由于不需要自己的 私有数据，所以直接定义为 无状态组件
    export default function CommentItem(props) {
        return <div>
            <h1>评论人：{props.user}</h1>
            <h1>评论内容：{props.content}</h1>
        </div>
    }
    ```
5. CommentList.jsx中返回每一行item修改
    
    ```
    
    return <div>
      <h1 className="title">评论列表案例</h1>
      {/* 我们可以直接在 JSX 语法内部，使用 数组的 map 函数，来遍历数组的每一项，并使用 map 返回操作后的最新的数组 */}
      {this.state.cmts.map((item, i) => {
        // return <CommentItem user={item.user} content={item.content} key={i}></CommentItem>
        return <CommentItem {...item} key={i}></CommentItem>
      })}
    </div>
    ```

### style内联样式:给CommentItem添加样式
1. 如何添加样式？CommentItem.js文件
    
    ```
    // 注意： 如果要使用 style 属性，为 JSX 语法创建的DOM元素，设置样式，不能像网页中那么写样式；而是要使用JS语法来写样式
    // 在 写 style 样式的时候，外层的 { } 表示 要写JS代码了，内层的 { } 表示 用一个JS对象表示样式
    // 注意： 在 style 的样式规则中，如果 属性值的单位是 px, 则 px 可以省略，直接写一个 数值 即可
    export default function CommentItem(props) {
        return <div style={{border:'1px solid #ccc',margin:'10px 0',paddingLeft:15}}>
            <h1 style={{fontSize:16,color:'purple'}}>评论人：{props.user}</h1>
            <h1 style={{fontSize:14,color:'red'}}>评论内容：{props.content}</h1>
        </div>
    }
    ```
2. 优化
    
     ```
    export default function CommentItem(props) {
        //单独封装成对象
        const boxStyle = { border: '1px solid #ccc', margin: '10px 0', paddingLeft: 15 }
       const titleStyle = { fontSize: 16, color: "purple" }
       const bodyStyle = { fontSize: 14, color: "red" } 
       //直接使用对象
        return <div style={boxStyle}>
            <h1 style={titleStyle}>评论人：{props.user}</h1>
            <h1 style={bodyStyle}>评论内容：{props.content}</h1>
        </div>
    }
    ```
3. 优化2
    
    ```
    //把 样式对象，封装到唯一的一个对象中
    const inlineStyles = {
        boxStyle: { border: '1px solid #ccc', margin: '10px 0', paddingLeft: 15 },
        titleStyle: { fontSize: 16, color: "purple" },
        bodyStyle: { fontSize: 14, color: "red" }
      }
    return <div style={inlineStyles.boxStyle}>
        <h1 style={inlineStyles.titleStyle}>评论人：{props.user}</h1>
        <h3 style={inlineStyles.bodyStyle}>评论内容：{props.content}</h3>
    </div>
    ```
4. 优化3：
    1. 将样式独立封装到cmtItemStyle.js文件中去
    
        ```
        // 导入一个 样式的对象
        export default {
          boxStyle: { border: '1px solid #ccc', margin: '10px 0', paddingLeft: 15 },
          titleStyle: { fontSize: 16, color: "purple" },
          bodyStyle: { fontSize: 14, color: "red" }
        }
        ```
    2. CommentItem.js文件导入cmtItemStyle.js
        
        ```
        import inlineStyles from './cmtItemStyles.js'
        ```

### CSS外联样式导入使用
>优化4：CommentItem.js中不采用行内样式style方式

1. 新建CommentItem.css
    
    ```
    /* 注意：当启用 CSS 模块化之后，这里所有的类名，都是私有的，如果想要把类名设置成全局的一个类，可以把这个类名，用 :global() 给包裹起来 */
    /* 当使用 :global() 设置了全局的 类样式之后，这个类不会被重命名 */
    //私有
    .box{
      border: 1px solid #ccc;
      padding-left: 15px;
      box-shadow: 0 0 6px #ccc;
      margin: 10px 0;
    }
    //公有，通过普通方式导入当前CSS文件的都可以使用，比如CommentList.jsx通过import CommentItem from './CommentItem.jsx'，导入，只能使用:global配置的css属性
    /* 只有私有的类才会被重命名 */
    :global(.title){
      color:red;
      text-align: center;
    }
    //私有：只有通过模块化导入当前CSS文件的才能被使用
    .title{
      color: green;
      font-size: 16px;
    }
    //私有
    .body{
      font-size: 14px;
      color:red;
    }
    ```
2. **模块化CSS**：导入CSS时能够限制导入的CSS只能用于当前文件，避免css串用
    1. 在CommentItem.js导入CommentItem.css
    
    ```
    // 导入评论项的样式文件【这种直接 import '../路径标识符' 的 CSS 导入形式，并不是模块化的CSS】
    // import '../../css/commentItem.css'
    // 默认情况下，如果没有为 CSS 启用模块化，则接收到的 itemStyles 是个空对象，因为 .css 样式表中，不能直接通过 JS 的 export defualt 导出对象
    // 当启用 CSS 模块化之后（在webpack.config.js中配置启用CSS模块化），导入 样式表得到的 itemStyles 就变成了一个 样式对象，其中，属性名是 在样式表中定义的类名，属性值，是自动生成的一个复杂的类名（防止类名冲突）
    import itemStyles from '../../css/commentItem.css'
    console.log(itemStyles)
    
    ...

    return <div className={itemStyles.box}>
        <h1 className={itemStyles.title}>评论人：{props.user}</h1>
        <h3 className={itemStyles.body}>评论内容：{props.content}</h3>
    </div>
    ...
    ```
        