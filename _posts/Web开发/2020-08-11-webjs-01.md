---
layout: post
title: JS进阶(三)-ES6新增语法
category: Web开发
tags: Web开发
description: Web开发
--- 

## ES6 的新增语法

### let
1. ES6中新增的用于声明变量的关键字。
2. let声明的变量只在所处于的块级有效
    1. ES6之前没有块级作用域，只有局部作用域、全局作用域
    2. 注意：使用let关键字声明的变量才具有块级作用域，使用var声明的变量不具备块级作用域特性。
    
    ```
    if (true) { 
        let a = 10; 
    } 
    console.log(a) // a is not defined
    ```
3. 不存在变量提升
    
    ```
    console.log(a); // a is not defined 
    let a = 20;
    ```
4. 暂时性死区
    1. 块级作用域内部一旦用let定义，则外面同名的变量在块级作用域内部无效，成了暂时性死区
    
        ```
        var tmp = 123; 
        if (true) {
            // 一旦块级作用域内用let，就会锁定块级内，外部变量无效
            // 报错，变量未声明
            tmp = 'abc';
            let tmp; 
        }
    ```
5. let经典面试题
    1. var变量
        
        ```
        var arr = [];
        for(var i = 0; i<2;i++){
            arr[i] = function(){
                console.log(i);
            }
        }
        // 此题的关键点在于变量i是全局的，函数执行时输出的都是全局作用域下的i值。
        // 都输出2
        arr[0]();
        arr[1]();
        ```
    2. let变量
        
        ```
        let arr = [];
        for(let i = 0; i<2;i++){
            arr[i] = function(){
                console.log(i);
            }
        }
        // 此题的关键点在于每次循环都会产生一个块级作用域，每个块级作用域中的变量都是不同的，
        // 函数执行时输出的是自己上一级（循环产生的块级作用域）作用域下的i值.
        // 都输出0
        arr[0]();
        // 都输出0
        arr[1]();
        ```

### const
1. 作用：声明常量，常量就是值（内存地址）不能变化的量。
2. 具有块级作用域
    
    ```
    if (true) { 
        const a = 10; 
    } 
    console.log(a) // a is not defined
    ```
3. 声明常量时必须赋值
    
    ```
    const PI; // Missing initializer in const declaration
    ```
4. 常量赋值后，值不能修改。
    
    ```
    const PI = 3.14;
    PI = 100; // Assignment to constant variable.
    const ary = [100, 200];
    //可以赋值
    ary[0] = 'a';
    ary[1] = 'b';
    console.log(ary); // ['a', 'b'];
    //不可以更改
    ary = ['a', 'b']; // Assignment to constant variable.
    ```

#### let、const、var 的区别
1. 使用 var 声明的变量，其作用域为该语句所在的**函数内，且存在变量提升现象。**
2. 使用 let 声明的变量，其作用域为该语句所在的**代码块内，不存在变量提升。**
3. 使用 const 声明的是常量，其作用域为该语句所在的**代码块内**，在后面出现的代码中**不能再修改该常量的值。**

![pic](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/webjs-06.png)

### 解构赋值
1. ES6中允许从**数组**中提取值，按照对应位置，对变量赋值。**对象**也可以实现解构。
2. 数组解构
    1. 允许我们按照一一对应的关系从数组中提取值，然后将值赋值给变量
    2. 注意："="左边的`[]`不是数组，是解构的意思
    
    ```
    // 注意："="左边的[]不是数组，是解构的意思
    let [a, b, c] = [1, 2, 3];
    console.log(a,b,c);
    //如果解构不成功，变量的值为undefined。
    let [foo] = [];
    let [bar, foo] = [1];
    ```
3. 对象解构
    1. 按照一定模式，从数组中或对象中提取值，将提取出来的值赋值给另外的变量。
    2. 注意: "="左边的`{}`不是对象，而是解构
    
    ```
    let person = { name: 'zhangsan', age: 20 };
    let { name, age } = person;
    console.log(name); // 'zhangsan'
    console.log(age); // 20
    
    let {name: myName, age: myAge} = person; // myName myAge 属于别名
    console.log(myName); // 'zhangsan'
    console.log(myAge); // 20
    ```


## ES6 的内置对象扩展



