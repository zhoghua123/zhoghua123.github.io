---
layout: post
title: WebAPI(二)-事件高级
category: Web开发
tags: Web开发
description: Web开发
--- 

## 事件高级

### 注册事件（绑定事件）
1. 注册事件概述
    1. 给元素添加事件，称为注册事件或者绑定事件。
    2. 注册事件有两种方式：**传统方式和方法监听注册方式**
        1. 传统注册方式
            1. 利用 on 开头的事件 onclick
                
                ```
                <button onclick=“alert('hi~')”></button>
                btn.onclick = function() {}
                ```
            2. 特点： 注册事件的唯一性
            3. 同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数
        2. 方法监听注册方式
            1. w3c 标准 推荐方式
            2. `addEventListener()`它是一个方法
            3. IE9 之前的 IE 不支持此方法，可使用 `attachEvent()`代替
            4. 特点：同一个元素同一个事件可以注册多个监听器
            5. 按注册顺序依次执行
2. `addEventListener` 事件监听方式
    
    ```
    eventTarget.addEventListener(type, listener[, useCapture])
    ```
    
    1. eventTarget.addEventListener()方法将指定的监听器注册到 eventTarget（目标对象）上，当该对 象触发指定的事件时，就会执行事件处理函数。
    2. 该方法接收三个参数：
        1. type：事件类型字符串，比如 click 、mouseover ，**注意这里不要带on**
        2. listener：事件处理函数，事件发生时，会调用该监听函数
        3. useCapture：可选参数，是一个布尔值，默认是 false。学完 DOM 事件流后，我们再进一步学习
3. attachEvent 事件监听方式
    
    ```
    eventTarget.attachEvent(eventNameWithOn, callback)
    ```
    
    1. eventTarget.attachEvent()方法将指定的监听器注册到 eventTarget（目标对象） 上，当该对象触发指定的事件时，指定的回调函数就会被执行。
    2. 该方法接收两个参数：
        1. eventNameWithOn：事件类型字符串，比如 onclick 、onmouseover ，**这里要带on**
        2. callback： 事件处理函数，当目标触发事件时回调函数被调用
    3. **注意：**
        1. 这个方法是IE独有的，只有IE支持
        2. 这个方法只支持IE9之前，不包含IE9.IE9之后不再支持
4. 注册事件兼容性解决方案
    1. 兼容性处理的原则： 首先照顾大多数浏览器，再处理特殊浏览器
    
    ```
    function addEventListener(element, eventName, fn) {
        // 判断当前浏览器是否支持 addEventListener 方法 
        if (element.addEventListener) {
            element.addEventListener(eventName, fn); // 第三个参数 默认是false 
        } else if (element.attachEvent) {
            element.attachEvent('on' + eventName, fn); 
        } else {
            // 相当于 element.onclick = fn;
            element['on' + eventName] = fn;
        }
    }
    ```
            
### 删除事件（解绑事件）
1. 删除事件的方式
    1. 传统注册方式
        
        ```
        eventTarget.onclick = null;
        ```
    2. 方法监听注册方式
        
        ```
        eventTarget.removeEventListener(type, listener[, useCapture]);
        eventTarget.detachEvent(eventNameWithOn, callback);
        ```
2. 删除事件兼容性解决方案
    
    ```
    function addEventListener(element, eventName, fn) {
        // 判断当前浏览器是否支持 addEventListener 方法 
        if (element.removeEventListener) {
            element.removeEventListener(eventName, fn); // 第三个参数 默认是false 
        } else if (element.detachEvent) {
            element.detachEvent('on' + eventName, fn); 
        } else {
            // 相当于 element.onclick = null;
            element['on' + eventName] = null;
        }
    }
    ```

#### 代码举例

```
<body>
    <button class="btn1">监听事件</button>
    <button class="btn2">attach监听</button>
    <button class="btn3">事件删除</button>
    <script>
        // 1. addEventListener事件监听
        var btn = document.querySelector('.btn1');
        // 事件类型是字符串，不带on
        btn.addEventListener('click',function(){
            alert(22);
        });

        // 同一个对象可以添加多个事件
        btn.addEventListener('click',function(){
            alert(33);
        });
        // 2. attachEvent,只支持IE浏览器，且IE<9
        var btn2 = document.querySelector('.btn2');
        // btn2.attachEvent('onclick',function(){
        //     alert('attachEvent');
        // });

        // 3. 事件删除
        var btn3 = document.querySelector('.btn3');
        btn3.addEventListener('click',fn);
        function fn() {
            alert(666);
            // 事件删除
            // btn3.removeEventListener('click',fn);
            this.removeEventListener('click',fn);
        }
    </script>
</body>
```

### DOM事件流
1. 事件流描述的是从页面中接收事件的顺序。
2. 事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即 **DOM 事件流**。
3. 比如我们给一个div 注册了点击事件：
4. DOM 事件流分为3个阶段：
    1. 捕获阶段
    2. 当前目标阶段
    3. 冒泡阶段
5. **事件冒泡：** IE 最早提出，事件开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点的过程。
6. **事件捕获：** 网景最早提出，由 DOM最顶层节点开始，然后逐级向下传播到到最具体的元素接收的过程。
7. 我们向水里面扔一块石头，首先它会有一个下降的过程，这个过程就可以理解为从最顶层向事件发生的最具 体元素（目标点）的捕获过程；之后会产生泡泡，会在最低点（ 最具体元素）之后漂浮到水面上，这个过 程相当于事件冒泡。
    ![pic](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/webjs-08.png)
8. 注意:
    1. JS 代码中只能执行捕获或者冒泡其中的一个阶段。
    2. onclick 和 attachEvent 只能得到冒泡阶段。
    3. addEventListener(type, listener[, useCapture])第三个参数如果是 true，表示在事件捕 获阶段调用事件处理程序；如果是 false（不写默认就是false），表示在事件冒泡阶段调用事件处理 程序。
    4. 实际开发中我们很少使用事件捕获，我们更关注事件冒泡。
    5. 有些事件是没有冒泡的，比如 onblur、onfocus、onmouseenter、onmouseleave
    6. 事件冒泡有时候会带来麻烦，有时候又会帮助很巧妙的做某些事件，我们后面讲解。
9. 代码举例：
    
    ```
    .father {
        width: 100px;
        height: 100px;
        background-color: #f00;
        padding-top: 30px;
    }
    .son {
        width: 50px;
        height: 50px;
        background-color: #0f0;
        margin: 0 auto;
    }
    
    <div class="father">
        <div class="son">son盒子</div>
    </div>
    <script>
    
        /*1. 监听事件的捕获阶段，document->html->body->father->son*/
        // addEventListener第三个参数为true
        // var son = document.querySelector('.son');
        // true,监听捕获阶段
        // son.addEventListener('click',function(){
        //     alert('son');
        // },true);
        // var father = document.querySelector('.father');
        // true,监听捕获阶段
        // father.addEventListener('click',function(){
        //     alert('father');
        // },true);
        // 效果，点击son之后，father先执行函数，之后son再执行函数

        /*2. 监听事件的冒泡阶段，son->father->body->html->document*/
        // addEventListener第三个参数为false或者省略
        var son = document.querySelector('.son');
        // true,监听捕获阶段
        son.addEventListener('click',function(){
            alert('son');
        });
        var father = document.querySelector('.father');
        // true,监听捕获阶段
        father.addEventListener('click',function(){
            alert('father');
        });
        // 效果，点击son之后，son先执行函数，之后father再执行函数
    </script>
    ```

### 事件对象
1. 什么是事件对象
    
    ```
    eventTarget.onclick = function(event) {}
    eventTarget.addEventListener('click',  function(event) {}） 
    // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt
    ```
    
    1. 官方解释：event 对象代表事件的状态，比如键盘按键的状态、鼠标的位置、鼠标按钮的状态。 简单理解：事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象 event，它有很多属性和方法。
    2. 比如：
        1. 谁绑定了这个事件。
        2. 鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置。
        3. 键盘触发事件的话，会得到键盘的相关信息，如按了哪个键。
2. 事件对象的使用语法
    
    ```
    eventTarget.onclick = function(event) { 
        // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt
    } 
    eventTarget.addEventListener('click', function(event) { 
        // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt
    }）
    ```
    
    1. 这个 event 是个形参，系统帮我们设定为事件对象，不需要传递实参过去。
    2. 当我们注册事件时， event 对象就会被系统自动创建，并依次传递给事件监听器（事件处理函数）。
3. 事件对象的兼容性方案
    1. 事件对象本身的获取存在兼容问题：
    2. 标准浏览器中是浏览器给方法传递的参数，只需要定义形参 e 就可以获取到。
    3. 在 IE6~8 中，浏览器不会给方法传递参数，如果需要的话，需要到 window.event 中获取查找。
    4. 解决:`e = e || window.event;`
4. 事件对象的常见属性和方法
    1. e.target 和 this 的区别：
        1. this 是事件绑定的元素， 这个函数的调用者（绑定这个事件的元素）
        2. e.target 是事件触发的元素。
    2. 事件对象的常见属性和方法
        
        ```
        e.target            /返回触发事件的对象 标准
        e.srcElement        //返回触发事件的对象 非标准，IE6-8使用
        e.type              //返回事件的类型，比如click、mouseover不带on
        e.cancelBubble      //该属性阻止冒泡 非标准，IE6-8使用
        e.returnValue       //该属性阻止默认事件（默认行为）非标准IE6-8使用，比如不让连接跳转
        e.parentDefault()   //该方法阻止默认事件（默认行为）标准，比如不让连接跳转
        e.stopPropagation()  //阻止冒泡 标准
        ```

### 阻止事件冒泡

### 事件委托（代理、委派）

### 常用的鼠标事件

### 常用的键盘事件



