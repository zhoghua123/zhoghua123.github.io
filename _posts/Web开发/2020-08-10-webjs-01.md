---
layout: post
title: JS进阶-JS中的面向对象（二）
category: Web开发
tags: Web开发
description: Web开发
--- 

## 继承
1. ES6之前并没有给我们提供 extends 继承。我们可以通过构造函数+原型对象模拟实现继承，被称为**组合继承**。
2. call()
    1. 调用这个函数, 并且**修改函数运行时的 this 指向**
        
        ```
        fun.call(thisArg, arg1, arg2, ...)
        ```
        
        1. thisArg ：当前调用函数 this 的指向对象
        2. arg1，arg2：传递的其他参数
    2. 举例：
        
        ```
        function fn(){
            console.log('hello world !');
            // 默认this指向window
            console.log(this);
        }
        var o = {};
        // 函数调用
        fn();
        // 函数调用
        fn.call();
        // 改变this指向，指向o对象
        fn.call(o);
        ```
3. 借用构造函数继承父类型**属性**
    1. 核心原理： 通过 call() 把父类型的 this 指向子类型的 this ，这样就可以实现子类型继承父类型的属性。
    2. 代码举例：
        
        ```
        // 父构造函数
        function Person (name, age, sex){
            this.name = name;
            this.age = age;
            this.sex = sex;
        }
        // 子构造函数
        function Student (name, age, sex, score){
            // 此时父类的 this 指向子类的 this，同时调用这个函数
            Person.call(this,name,age,sex);
            this.score = score;
        }
        var s1 = new Student('zs', 18, '男', 100);
        console.dir(s1);
        ```
4. 借用构造函数继承父类型**方法**
    1. 一般情况下，对象的方法都在构造函数的原型对象中设置，通过构造函数无法继承父类方法。
    2. 实现步骤：
        1. 将子类所共享的方法提取出来，让子类的 `prototype 原型对象 = new 父类()`
            1. 本质：子类原型对象等于是实例化父类，因为父类实例化之后另外开辟空间，就不会影响原来父类原型对象
        2. 将子类的 constructor 从新指向子类的构造函数
    3. 注意：不能让子原型对象直接等于父原型对象
        
        ```
        Student.prototype = Person.prototype;
        ```
        
        1. 这样的话，父子指向同一个对象，子类新增一个独有方法，则父类也会有
    4. 代码举例：
        
        ```
        // 父构造函数
        function Person (name, age, sex){
            this.name = name;
            this.age = age;
            this.sex = sex;
        }
        // 方法
        Person.prototype.eat = function(){
            console.log('吃饭');
        }
        // 子构造函数
        function Student (name, age, sex, score){
            // 此时父类的 this 指向子类的 this，同时调用这个函数
            Person.call(this,name,age,sex);
            this.score = score;
        }
        // 修改问题这么一修改，子构造函数的原型对象跟父构造函数的原型对象指向同一个对象
        // 那么如果子构造函数原型对象添加了一个方法，父构造函数原型对象也会有子的方法
        // Student.prototype = Person.prototype;

        // 1. 让子类的 prototype 原型对象 = new 父类()
        // 子构造函数原型对象指向父类构造函数实例对象
        // 如果子类构造函数新增了一个独有方法，那这个方法是添加在了父类构造函数的示例对象中，而不会影响父类的原型对象
        Student.prototype = new Person();

        // 2. 将子类的 constructor 从新指向子类的构造函数
        // 利用对象的形式修改了原型对象，别忘了利用constructor指回原来的原型对象
        Student.prototype.constructor = Student;

        // 子构造函数独有方法
        Student.prototype.study = function(){
            console.log('学习');
        }
        
        var s1 = new Student('zs', 18, '男', 100);
        console.log(s1);
        console.log(Person.prototype);
        ```

## ES5 中的新增方法
1. ES5 中给我们新增了一些方法，可以很方便的操作数组或者字符串，这些方法主要包括：
    1. 数组方法
    2. 字符串方法
    3. 对象方法

### 数组方法
1. 迭代(遍历)方法：`forEach()、map()、filter()、some()、every()；`
  
#### forEach
1. 方法
  
    ```
    array.forEach(function(currentValue, index, arr))
    ```
        
    1. currentValue：数组当前项的值
    2. index：数组当前项的索引
    3. arr：数组对象本身
2. 举例
    
    ```
    var arr = [1,3,5];
    arr.forEach(function(currentValue, index, arr){
        console.log('每个元素值=' + currentValue+'索引=' + index )
        // 数组本身
        console.log(arr);
    })
    ```

#### filter
1. 方法
    
    ```
    array.filter(function(currentValue, index, arr))
    ```
    
    1. filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素,主要用于筛选数组
    2. **注意它直接返回一个新数组**
    3. currentValue: 数组当前项的值
    4. index：数组当前项的索引
    5. arr：数组对象本身
2. 举例
    
    ```
    var arr = [12,33,5,54];
    var newarr = arr.filter(function(currentValue, index, arr){
        //筛选出大于20的值
        return currentValue >= 20;
    })
    console.log(newarr)
    ```

#### some
1. 方法
    
    ```
    array.some(function(currentValue, index, arr))
    ```
    
    1. some() 方法用于检测数组中的元素是否满足指定条件. 通俗点 查找数组中是否有满足条件的元素
    2. 注意它返回值是布尔值, 如果查找到这个元素, 就返回true , 如果查找不到就返回false.
    3. 如果找到第一个满足条件的元素,则终止循环. 不在继续查找.
2. 代码举例：
    
    ```
    var arr = [10,30,4];
    var flag = arr.some(function(currentValue, index, arr){
        return currentValue>= 20;
    })
    console.log(flag)
    ```
    
### 字符串方法
1. trim() 方法会从一个字符串的两端删除空白字符。
2. trim() 方法并不影响原字符串本身，它返回的是一个新的字符串。
    
    ```
    var str = '    hh    ';
    // 提出字符串2端的空格
    var newstr = str.trim();
    console.log(str);
    console.log(newstr);
    ```
### 对象方法

#### Object.keys()
1. Object.keys() 用于获取对象自身所有的属性
    1. 效果类似 for…in
    2. 返回一个由属性名组成的数组
2. 举例
    
    ```
    var obj = {
        id:1,
        name: '小米',
        price: 1999,
        num: 2000
    };
    // 获取对象的所有属性名
    console.log(Object.keys(obj));
    ```

#### Object.defineProperty()
1. Object.defineProperty() 定义新属性或修改原有的属性。
    
    ```
    Object.defineProperty(obj, prop, descriptor)
    ```
    
    1. obj：必需。目标对象
    2. prop：必需。需定义或修改的属性的名字
    3. descriptor：必需。目标属性所拥有的特性
2. 第三个参数 descriptor 说明
    1. value: 设置属性的值
    2. writable: 值是否可以重写。true | false
    3. enumerable: 目标属性是否可以被枚举。true | false
    4. configurable: 目标属性是否可以被删除或是否可以再次修改特性 true | false
3. 代码举例：
    
    ```
    var obj = {
        id:1,
        name: '小米',
        price: 1999
    };
    // 以前方式
    // // 新增属性
    // obj.num = 2000;
    // // 修改
    // obj.price = 1800;
    // 新方式
    // 新增
    Object.defineProperty(obj,'num',{
        value:1000
    });
    // 修改
    Object.defineProperty(obj,'price',{
        value:1880
    });
    // 修改
    Object.defineProperty(obj,'id',{
        // 不允许修改属性值
        writable: false
    });
    // enumerable
    Object.defineProperty(obj,'address',{
        value:'中国河南郑州',
        // 不允许修改属性值
        writable: false,
        // 不允许被遍历查看
        enumerable:false,
        // 不允许被删除
        configurable:false
    });


    // 尽管不报错，但是还是修改不了原来的id值
    obj.id = 2;
    // 遍历中看不到address属性，也遍历不到num属性，因为enumerable默认为false
    console.log(Object.keys(obj))
    // 删除address属性
    delete obj.address;
    // 仍然可以看到address属性，不允许被删除
    console.log(obj)

    // 不允许再次被修改,否则报错
    Object.defineProperty(obj,'address',{
        value:'中国河南郑州',
        // 不允许修改属性值
        writable: false,
        // 不允许被遍历查看
        enumerable:false,
        // 允许被删除
        configurable:true
    });
    ```

#### 经典案例
1. 商品查询案例，视频观看


## 函数进阶

### 函数的定义和调用

#### 函数的定义方式
1. 函数声明方式 function 关键字 (命名函数)
2. 函数表达式 (匿名函数)
3. new Function()
    
    ```
    var fn = new Function('参数1','参数2'..., '函数体')
    ```
    
    1. Function 里面参数都必须是字符串格式
    2. 第三种方式执行效率低，也不方便书写，因此较少使用
    3. 所有函数都是 Function 的实例(对象)
        1. 所有函数都是通过Function这个类创建出来的
    4. 函数也属于对象
    5. 注意：Function必须首字母大写

    ```
    // 1. 自定义函数（命名函数）
    function fn(){

    }
    // 2. 函数的表达式（匿名函数）
    var fun = function() {

    }
    // 3. 利用new Function()
    var f = new Function('console.log(123)');
    f();

    var f2 = new Function('a','b','console.log(a+b)');
    f2(2,3);
    // f属不属于Object ，用于判断是否属于对象，true
    console.log(f instanceof Object);
    ```
    
![pic](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/webjs-05.png)

#### 函数的调用方式

```
// 1. 普通函数
function fn(){}
fn();
fn.call();
// 2. 对象的方法
var o = {
    func: function(){ }
}
o.func();
// 3. 构造函数
function Star(){}
new Star();
// 4. 绑定事件函数
btn.onclick = function(){}
// 点击按钮调用
// 5. 定时器函数
// 每隔1s调用一次
setInterval(function(){},1000);
// 6. 立即执行函数
// 创建即调用
(function(){})()
```

### this
1. 这些 this 的指向，是当我们调用函数的时候确定的。 调用方式的不同决定了this 的指向不同 一般指向我们的调用者.
    
    ```
    调用方式            this指向
    
    普通函数            window
    对象的方法          该方法所属对象
    构造函数            实例对象，原型对象里面的方法也指向实例对象
    绑定事件函数         绑定事件对象
    时器函数            window
    立即执行函数         window
    ```
2. 改变函数内部 this 指向
    1. JavaScript 为我们专门提供了一些函数方法来帮我们更优雅的处理函数内部 this 的指向问题，常用的有 `bind()、 call()、apply()` 三种方法。
3. call方法，前面讲过（略）

#### apply 方法
1. apply() 方法调用一个函数。简单理解为调用函数的方式，但是它可以改变函数的 this 指向。
2. `fun.apply(thisArg, [argsArray])`
    1. thisArg：在fun函数运行时指定的 this 值
    2. argsArray：传递的值，必须包含在数组里面
    3. 返回值就是函数的返回值，因为它就是调用函数
    4. 因此 apply 主要跟数组有关系，比如使用 Math.max() 求数组的最大值
3. 代码举例：
    
    ```
    var o = {
        name : 'rose'
    }
    function fn(a,b){
        console.log(this);
        console.log(a+b);

    }
    //    修改fn函数的this指向，以及传参
    fn.apply(o,[1,3]);
    //    apply应用，求数组中的最大值
    var arr = [23,45,6,55,33,66];
    // Math.max只能求数字中的最大值不能求数组中的最大值，但是可以通过apply来实现求数组中的最大值
    var maxvalue =  Math.max.apply(Math,arr);
    var minvalue = Math.min.apply(Math,arr);
    // 66
    console.log(maxvalue,minvalue)
    ```
    
#### bind 方法
1. bind() 方法不会调用函数。但是能改变函数内部this 指向
2. `fun.bind(thisArg, arg1, arg2, ...)`
    1. thisArg：在 fun 函数运行时指定的 this 值
    2. arg1，arg2：传递的其他参数
    3. 返回由指定的 this 值和初始化参数改造的原函数拷贝
    4. 因此当我们只是想改变 this 指向，并且不想调用这个函数的时候，可以使用 bind
    5. 注意：bind方法会产生一个改变this指向的新函数，并**不会修改原函数的this指向**
3. 代码举例：
    
    ```
    var o = {
        name : 'rose'
    }
    function fn(){
        console.log(this);
    }
    // 只绑定，不调用,生成一个新的函数
    // 返回的是一个改变this之后的新函数,不会影响原函数
    var f = fn.bind(o);
    // 改变了this，为o
    f();
    // this没有改变，仍然为window
    fn();
    ```
4. 使用场景：如果有的函数我们不想立即调用，但是又想改变这个函数内部的this指向，此时用bind
    1. 一个按钮，当点击之后就禁用这个按钮，3s中之后恢复
    
    ```
    <button>按钮</button>
    <script>
    var btn = document.querySelector('button');
    btn.onclick = function() {
        this.disabled = true;
        setTimeout(function(){
            // 默认this是window，但是如果使用了bind，this就改变指向了
            this.disabled = false
        }.bind(this),3000);// 注意bind（）中的this指向的是btn对象
    }
    </script>
    ```
    
#### call apply bind 总结
1. 相同点:
    1. 都可以改变函数内部的this指向.
2. 区别点:
    1. call 和 apply 会调用函数, 并且改变函数内部this指向.
    2. call 和 apply 传递的参数不一样, call 传递参数 aru1, aru2..形式 apply 必须数组形式`[arg]`
    3. bind 不会调用函数, 可以改变函数内部this指向.
3. 主要应用场景:
    1. call 经常做继承.
    2. apply 经常跟数组有关系. 比如借助于数学对象实现数组最大值最小值
    3. bind 不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向.

### 严格模式

### 高阶函数

### 闭包

### 递归


