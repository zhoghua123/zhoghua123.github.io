---
layout: post
title: ReactJS语法-组件生命周期
category: Web开发
tags: Web开发
description: Web开发
--- 

## 概念
1. 在组件创建、到加载到页面上运行、以及组件被销毁的过程中，总是伴随着各种各样的事件，这些在组件特定时期，触发的事件，统称为 组件的生命周期；

![pic](https://gitee.com/zhonghua123/blogimgs/raw/master/img/webzh_58.png/)

### 组件创建阶段
> 组件创建阶段的生命周期函数，有一个显著的特点：创建阶段的生命周期函数，在组件的一辈子中，只执行一次；

1. componentWillMount: 组件将要被挂载，此时还没有开始渲染虚拟DOM
2. render：第一次开始渲染真正的虚拟DOM，当render执行完，内存中就有了完整的虚拟DOM了
3. componentDidMount: 组件完成了挂载，此时，组件已经显示到了页面上，当这个方法执行完，组件就进入都了 运行中 的状态

### 组件运行阶段
> 也有一个显著的特点，根据组件的state和props的改变，有选择性的触发0次或多次；

1. componentWillReceiveProps: 组件将要接收新属性，此时，只要这个方法被触发，就证明父组件为当前子组件传递了新的属性值；
2. shouldComponentUpdate: 组件是否需要被更新，此时，组件尚未被更新，但是，state 和 props 肯定是最新的
3. componentWillUpdate: 组件将要被更新，此时，尚未开始更新，内存中的虚拟DOM树还是旧的
4. render: 此时，又要重新根据最新的 state 和 props 重新渲染一棵内存中的 虚拟DOM树，当 render 调用完毕，内存中的旧DOM树，已经被新DOM树替换了！此时页面还是旧的
5. componentDidUpdate: 此时，页面又被重新渲染了，state 和 虚拟DOM 和 页面已经完全保持同步

### 组件销毁阶段
> 也有一个显著的特点，一辈子只执行一次；

1. componentWillUnmount: 组件将要被卸载，此时组件还可以正常使用；

## 组件生命周期函数
1. React生命周期的回调函数总结成表格如下：
    ![pic](https://gitee.com/zhonghua123/blogimgs/raw/master/img/webzh_59.png/)
    
2. 组件生命周期的执行顺序：
+ Mounting：
 - constructor()
 - componentWillMount()
 - render()
 - componentDidMount()
+ Updating：
 - componentWillReceiveProps(nextProps)
 - shouldComponentUpdate(nextProps, nextState)
 - componentWillUpdate(nextProps, nextState)
 - render()
 - componentDidUpdate(prevProps, prevState)
+ Unmounting：
 - componentWillUnmount()
    
### defaultProps
1. 在组件创建之前，会先初始化默认的props属性，这是全局调用一次，严格地来说，这不是组件的生命周期的一部分。在组件被创建并加载候，首先调用 constructor 构造器中的 this.state = {}，来初始化组件的状态。


## Counter计数器案例

### defaultProps设置组件默认值
1. 在组件创建之前，会先初始化默认的props属性，这是全局调用一次，严格地来说，这不是组件的生命周期的一部分。在组件被创建并加载候，首先调用 constructor 构造器中的 this.state = {}，来初始化组件的状态。
2. 创建Counter.jsx

    ```
    import React from 'react'
    
    export default class Counter extends React.Component {
    
      constructor(props) {
        super(props)
        // 初始化组件的私有状态，保存的是组件的私有数据
        this.state = {
        msg: 'ok'
        }
      }
      
        // 在封装一个组件的时候，组件内部，肯定有一些数据是必须的，哪怕用户没有传递一些相关的启动参数，这时候，组件内部 ，尽量 给自己提供一个默认值；
      // 在 React 中，使用静态的 defaultProps 属性，来设置 组件的 默认属性值；
      static defaultProps = {
        initcount: 0 // 如果外界没有传递 initcount，那么，自己初始化一个 数值，为0
      }
      
      render() {
        return <div>
          <h1>这是 Counter 计数器组件</h1>
          <input type="button" value="+1"/>
          <hr />
          <h3 id="myh3">当前的数量是：{this.props.initcount}</h3>
        </div>
      }
    }
    ```
3. main.js导入
    
    ```
    import React from 'react'
    import ReactDOM from 'react-dom'
    import Counter from './components/Counter.jsx'
    // 使用 render 函数渲染 虚拟DOM
    ReactDOM.render(<div>
      <Counter></Counter>
      
      {/*胡乱传递数据，这就需要组件内部做数据类型校验 */}
      <Counter initcount="哈哈哈哈哈"></Counter> 
     
    </div>, document.getElementById('app'))
    ```
4. index.html
    
    ```
    <body>
      <!-- 容器，将来通过 React 渲染得到的 虚拟DOM，会呈现到这个位置 -->
      <div id="app"></div>
    </body>
    ```

### propTypes实现组件内部数据类型校验
1. 如果外部给Counter组价传递的是垃圾数据，那么组件内部就需要做类型校验
    
    ```
    //main.js
    ...
    {/*胡乱传递数据，这就需要组件内部做数据类型校验 */}
    <Counter initcount="哈哈哈哈哈"></Counter> 
    ...
    ```
2. Counter.jsx内部新增propTypes
    1. 添加第三方包，叫做 prop-types
    2. 导入
    
    ```
    // 注意： prop-types 包中职能跟单一，只提供了 一些常见的 数据类型，用于做类型校验
    import ReactTypes from 'prop-types'
    export default class Counter extends React.Component {
        ...
     // 这是创建一个 静态的 propTypes 对象，在这个对象中，可以把 外界传递过来的属性，做类型校验；
      // 注意： 如果要为 传递过来的属性做类型校验，必须安装 React 提供的 第三方包，叫做 prop-types ;
      // prop-types 大概在 v.15.* 之前，并没有单独抽离出来，那时候，还和 react 包 在一起；后来， 从 v.15.* 之后，官方把类型校验的 模块，单独抽离为 一个包，就叫做 prop-types
      static propTypes = {
        initcount: ReactTypes.number // 使用 prop-types 包，来定义 initcount 为 number 类型
      }
        ...
    }
    ```

### 生命周期函数componentWillMount
1. 在Counter.jsx的render方法前面，添加componentWillMount方法
    
    ```
    // 在组件即将挂载到页面上的时候执行，此时，组件尚未挂载到页面中
    // 虚拟DOM是否创建好了呢？此时，内存中的虚拟DOM也没开始创建呢
    componentWillMount() {
        // 此时，无法获取到 页面上的 任何元素，因为 虚拟DOM 和 页面 都还没有开始渲染呢！【在这个阶段中，不能去操作页面上的DOM元素】
        // console.log(document.getElementById('myh3'));
        //可以获取到
        // console.log(this.props.initcount);
        //可以获取到
        // console.log(this.state.msg);
        //可以获取到
        // this.myselfFunc()
    }
    //自定义方法
    myselfFunc() {
        console.log('这是我自己定义的函数，和生命周期函数无关');
    }
    ```
    
### 生命周期函数render

```
// 当执行到 这个 生命周期函数的时候，即将要开始渲染内存中的 虚拟DOM了，当这个函数执行完，内存中就有了一个 渲染好的虚拟DOM，但是，页面上尚未真正显示DOM元素呢；
render() {
    // 在 return 之前，虚拟DOM还没有开始创建，页面上也是空的，根本拿不到任何的 元素
    // console.log(document.getElementById('myh3'));
    return <div>
        <h1>这是 Counter 计数器组件</h1>
        <input type="button"  value="+1" id="btn"/>
        <hr />
        <h3 id="myh3">当前的数量是：{this.props.initcount}</h3>
    </div>
    // 当 return 执行完毕后， 虚拟DOM创建好了，但是，还没有挂载到真正的页面中
}
```

### 生命周期函数componentDidMount
1. 在render函数下面新增componentDidMount

```
 // 当组件挂载到页面上之后，会进入这个生命周期函数，只要进入这个生命周期函数了，必然说明，页面上，已经有可见的DOM元素了
// 当组件执行完 componentDidMount 函数后，就进入到了 运行中的状态，所以，componentDidMount 是创建阶段的最后一个函数
componentDidMount() {
    // 在这个函数中，我们可以放心的去 操作 页面上你需要使用的 DOM 元素了；
    // 如果我们想操作DOM元素，最早，只能在 componentDidMount 中进行；
    // componentDidMount 相当于 Vue 中的 mounted 函数
    // console.log(document.getElementById('myh3'));
}
```

### 生命周期函数shouldComponentUpdate

#### 设置触发条件
1. 给button添加点击事件，在componentDidMount中
    
    ```
    componentDidMount() {
        document.getElementById('btn').onclick = () => {
            // console.log('ok');
            // console.log(this);
            //initcount只读属性，不能改变,因此要使用state私有属性
            // this.props.initcount++
            //可以使用setState变更
            this.setState({
                count: this.state.count + 1
            })
        } 
    }
    ```
2. 设置私有属性state接收外部参数
    
    ```
    this.state = {
      msg: 'ok',
      count: props.initcount  // 基数, 把 外界传递过来的 initcount 赋值给 state 中的 count值，这样，就把 count 值改成了可读可写的 state 属性，今后，就能实现 点击 按钮 ，count 值 + 1 的需求了
    }
    ```
3. 将render中的h3标签的展示由props换成state
    
    ```
    <h3 id="myh3" ref="h3">当前的数量是：{this.state.count}</h3>
    ```
4. 也可以通过react方式给buttn添加时间，不通过componentDidMount内部添加
    
    ```
    //render中buttn添加点击事件
     <input type="button" value="+1" id="btn" onClick={this.increment} />
     
    //实现点击事件
    increment = () => {
        this.setState({
            count: this.state.count + 1
        })
    }
    ```
5. 以上当点击buttn时，就会改变私有属性state，就会触发组件页面更新，即shouldComponentUpdate

#### shouldComponentUpdate

```
 // 从这里开始，就进入到了组件的运行中状态
// 判断组件是否需要更新
shouldComponentUpdate(nextProps, nextState) {
    // 1. 在 shouldComponentUpdate 中要求必须返回一个布尔值
    // 2. 在 shouldComponentUpdate 中，如果返回的值是 false，则 不会继续执行后续的生命周期函数，而是直接退回到了 运行中 的状态，此时有序 后续的 render 函数并没有被调用，因此，页面不会被更新，但是， 组件的 state 状态，却被修改了；
    // return false
    
    // 需求： 如果 state 中的 count 值是偶数，则 更新页面，如果 count 值 是奇数，则不更新页面，我们想要的页面效果：4，6，8，10，12....
    // 经过打印测试发现，在 shouldComponentUpdate 中，通过 this.state.count 拿到的值，是上一次的旧数据，并不是当前最新的；
    // console.log(this.state.count + ' ---- ' + nextState.count);
    // return this.state.count % 2 === 0 ? true : false
    //使用nextState获取最新值
    // return nextState.count % 2 === 0 ? true : false
    return true
}
```

### 生命周期函数componentWillUpdate

```
// 组件将要更新，此时尚未更新，在进入这个 生命周期函数的时候，内存中的虚拟DOM是旧的，页面上的 DOM 元素 也是旧的
componentWillUpdate() {
    // 经过打印分析，得到，此时页面上的 DOM 节点，都是旧的，应该慎重操作，因为你可能操作的是旧DOM
    // console.log(document.getElementById('myh3').innerHTML)
    
     //1. 给h3标签绑定ref属性<h3 id="myh3" ref="h3">当前的数量是：{this.state.count}</h3>
    //2. 使用refs来获取
    // console.log(this.refs.h3.innerHTML);
    // console.log(this.refs.h3.innerHTML);
}
```

### 生命周期函数componentDidUpdate

```
// 组件完成了更新，此时，state 中的数据、虚拟DOM、页面上的DOM，都是最新的，此时，你可以放心大胆的去操作页面了
componentDidUpdate() {
    // console.log(this.refs.h3.innerHTML);
}
```
### 注意点
1. 不要在 render 中使用 this.setState,因为 会陷入死循环
    
    ```
    render() {
        //会陷入死循环
        /*  this.setState({
          count: this.state.count + 1
        }) */
        return <div>
          <h1>这是 Counter 计数器组件</h1>
          <input type="button" value="+1" id="btn" onClick={this.increment} />
          <hr />
          <h3 id="myh3" ref="h3">当前的数量是：{this.state.count}</h3>
        </div>
    }
    ```

### 生命周期函数componentWillReceiveProps
1. 理论上来说props属性是只读属性，那么如何设置props呗修改的场景呢？
2. props属性只是在组件内部不能修改，但是可以在外部被修改。
3. 场景：
    1. 设置一个父组件Parent和一个子组件Son
    2. 让父组件的state作为子组件Son的props传参。
    3. 点击父组件按钮变更state，那么子组件的props就变更了
4. 创建父子组件TestReceiveProps.jsx
    
    ```
    import React from 'react'

    // 父组件
    export default class Parent extends React.Component {
        constructor(props) {
            super(props)
            this.state = {
                msg: '这是父组件中的 msg 消息'
            }
        }
    
        render() {
            return <div>
                <h1>这是父组件</h1>
                <input type="button" value="点击修改父组件的 MSG" onClick={this.changeMsg} />
                <hr />
                <Son pmsg={this.state.msg}></Son>
            </div>
        }
    
        changeMsg = () => {
            this.setState({
                msg: '娃哈哈'
            })
        }
    }
    
    // 子组件
    class Son extends React.Component {
        constructor(props) {
            super(props)
            this.state = {}
        }
    
    render() {
        return <div>
            <h3>这是子组件 --- {this.props.pmsg}</h3>
            </div>
        }
    
        // 组件将要接收外界传递过来的新的 props 属性值
        // 当子组件第一次被渲染到页面上的时候，不会触发这个 函数；
        // 只有当 父组件中，通过 某些 事件，重新修改了 传递给 子组件的 props 数据之后，才会触发 componentWillReceiveProps
        componentWillReceiveProps(nextProps) {
            // console.log('被触发了！');
            // 注意： 在 componentWillReceiveProps 被触发的时候，如果我们使用 this.props 来获取属性值，这个属性值，不是最新的，是上一次的旧属性值
            // 如果想要获取最新的属性值，需要通过 componentWillReceiveProps 的参数列表来获取
            console.log(this.props.pmsg + ' ---- ' + nextProps.pmsg);
        }
    }
    ```
5. main.js导入
    
    ```
    import Test from './components/TestReceiveProps.jsx'
    
    //render中渲染
    ReactDOM.render(<div>
    <Test></Test> 
    </div>, document.getElementById('app'))
    ```

## 绑定this并传参的三种方式
1. 如果render中的标签点击事件绑定的是普通函数，那么普通函数中的this指向是undefind.
2. 解决方案：
    1. 使用bind
    2. 使用箭头函数：把当前函数变成箭头函数
    3. 使用call/apply

### 方式一：bind绑定传递
1. bind 的作用：修改函数内部的this指向，让函数内部的this，指向bind 参数列表中的 第一个参数
2. bind 和 call/apply 之间的区别：call/apply 修改完this指向后，会立即调用前面的函数，但是 bind 只是修改this指向，并不会调用。
3. **注意：** bind 中的第一个参数，是用来修改 this 指向的，第一个参数后面的所有参数，都会当作将来调用 前面函数 时候的参数传递进去
4. 创建BindThis.jsx组件
    
    ```
    import React from 'react'
    export default class BindThis extends React.Component {
      constructor(props) {
        super(props)
        this.state = {
          msg: '这是默认的msg'
        }
      }
      //render中的标签点击事件绑定的是普通函数
      render() {
        return <div>
          <h1>绑定This并传参的几种方式</h1>
          {/* 方式1：在 事件处理函数中，直接使用 bind 绑定 this 并传参 */}
          <input type="button" value="绑定this并传参的方式1" onClick={this.changeMsg1.bind(this, '🐷', '🍕')} />
          <hr />
          <h3>{this.state.msg}</h3>
        </div>
      }
    
      /**
      * 普通实例函数
      * 注意：这里的方式，是一个普通方法，因此，在触发的时候，这里的 this 是 undefined
       */
      changeMsg1(arg1, arg2,event) {
        //event,默认传递
        // console.log(this);
        this.setState({
          msg: '绑定this并传参的方式1' + arg1 + arg2
        })
      }
    }
    ```
2. main.js导入
    
    ```
    import BindThis from './components/BindThis.jsx'
    //render中渲染
    ReactDOM.render(<div>
    <BindThis></BindThis>
    </div>, document.getElementById('app'))
    ```

### 方式二：在构造函数中bind绑定并传参
1. **当一个函数，调用 bind 改变了this指向后，bind 函数调用的结果返回值，就是被改变this指向后的函数的引用；**
2. 实现普通函数changeMsg2
    
    ```
    changeMsg2(arg1, arg2) {
        // console.log(this);
        this.setState({
          msg: '绑定this并传参的方式2' + arg1 + arg2
        })
      }
    ```
3. render中点击第二个按钮
    
    ```
    <input type="button" value="绑定this并传参的方式2" onClick={this.changeMsg2} />
    ```
4. constructor绑定this并传参
    
    ```
    constructor(props) {
        super(props)
        this.state = {
          msg: '这是默认的msg'
        }
        
        // 绑定 this 并传参的方式2: 在构造函数中绑定并传参
        // 注意，当一个函数，调用 bind 改变了this指向后，bind 函数调用的结果返回值，就是被改变this指向后的函数的引用；
        // 注意： bind 不会修改 原函数的 this 指向
        this.changeMsg2 = this.changeMsg2.bind(this, '🚗', '👫')
    }
    ```

### 方式三：使用箭头函数绑定this并传参
1. 实现箭头函数changeMsg3
    
    ```
    changeMsg3 = (event,arg1, arg2) => {
        // console.log(this);
        this.setState({
          msg: '绑定this并传参的方式3' + arg1 + arg2
        })
    }
    ```
2. render中点击第三个按钮

    ```
    <input type="button" value="绑定this并传参的方式3" onClick={(event) => { this.changeMsg3(event,'😊', '😘') }} />
    ```

## 绑定文本框与state中的值
1. 效果？一个文本框输入之后，将输入内容传递给state并页面即时更新
2. 创建render中添加input
    
    ```
    {/* 在 Vue 中，有 v-model 指令来实现双向数据绑定，但是，在 React 中， 根本没有指令的概念，因此React 默认也不支持 双向数据绑定 */}
    {/* React 只支持，把数据从 state 上传输到 页面，但是，无法自动实现数据从 页面 传输到 state 中 进行保存，也就是，React 不支持数据的自动逆向传输， 只是实现了数据的单向绑定 */}
    {/* 注意：如果为 表单元素，提供了 value 属性绑定，那么，必须同时为 表单元素 绑定 readOnly, 或者提供要给 onChange 事件 */}
    {/* 如果提供了readOnly，表示这个元素只读的不能被修改  */}
    {/* 如果提供了onChange 表示，这个元素的值可以被修改，但是，要自己定义修改的逻辑  */}
    <input type="text" style={{ width: '100%' }} value={this.state.msg} onChange={this.txtChanged} ref="txt" />
    ```
3. 实现this.txtChanged
    
    ```
    // 为 文本框 绑定 txtChanged 事件
    txtChanged = (e) => {
        // console.log('ok');
        // 如果想让 文本框在触发 onChange 的时候，同时把文本框最新的值，保存到 state 中，那么，我们需要手动调用 this.setState
        // 获取文本框中 最新文本的3种方式：
        //  1. 使用 document.getElementById 来拿
        //  2. 使用 ref 来拿
        // console.log(this.refs.txt.value);
        //  3. 使用 事件对象的 参数 e 来拿   e.target 就表示触发 这个事件的 事件源对象，得到的是一个原生的JS DOM 对象
        // console.log(e.target.value);
        this.setState({
            msg: e.target.value
        })
    }
    ```
    


## 评论列表案例
![pic](https://gitee.com/zhonghua123/blogimgs/raw/master/img/webzh_60.png/)
    
1. 创建评论列表组件CmtList.jsx
    
    ```
    import React from 'react'
    import CMTItem from './CmtItem.jsx'
    import CMTBox from './CmtBox.jsx'
    
    // 评论列表组件
    export default class CMTList extends React.Component {
      constructor(props) {
        super(props)
        this.state = {
          list: [
            { user: 'zs', content: '123' },
            { user: 'ls', content: 'qqq' },
            { user: 'xiaohong', content: 'www' }
          ]
        }
      }
    
      // 在组件尚未渲染的时候，就立即 获取数据
      componentWillMount() {
        this.loadCmts()
      }
    
      render() {
        return <div>
          <h1>这是评论列表组件</h1>
    
          {/* 发表评论的组件 */}
          {/* react 中，只要是传递给 子组件的数据，不管是 普通的类型，还是方法，都可以使用 this.props 来调用 */}
          <CMTBox reload={this.loadCmts}></CMTBox>
    
          <hr />
    
    
          {/* 循环渲染一些评论内容组件 */}
          {this.state.list.map((item, i) => {
            return <CMTItem key={i} {...item}></CMTItem>
          })}
        </div>
      }
    
      // 从本地存储中加载 评论列表
      loadCmts = () => {
        var list = JSON.parse(localStorage.getItem('cmts') || '[]')
        this.setState({
          list
        })
      }
    }
    ```
2. 创建评论item组件CmtItem.jsx
    
    ```
    import React from 'react'
    // 评论列表项组件
    export default class CMTItem extends React.Component {
    
      render() {
        return <div style={{ border: '1px solid #ccc', margin: '10px 0' }}>
          <h3>评论人：{this.props.user}</h3>
          <h5>评论内容：{this.props.content}</h5>
        </div>
      }
    }
    ```
3. 创建评论组件CmtBox.jsx
    
    ```
    import React from 'react'

    // 评论列表框组件
    export default class CMTBox extends React.Component {
    
      render() {
        return <div>
          <label>评论人：</label><br />
          <input type="text" ref="user" /><br />
          <label>评论内容：</label><br />
          <textarea cols="30" rows="4" ref="content"></textarea><br />
    
          <input type="button" value="发表评论" onClick={this.postComment} />
        </div>
      }
    
      postComment = () => {
        // 1. 获取到评论人和评论内容
        // 2. 从 本地存储中，先获取之前的评论数组
        // 3. 把 最新的这条评论，unshift 进去
        // 4. 在把最新的评论数组，保存到 本地存储中
        var cmtInfo = { user: this.refs.user.value, content: this.refs.content.value }
        var list = JSON.parse(localStorage.getItem('cmts') || '[]')
        list.unshift(cmtInfo)
        localStorage.setItem('cmts', JSON.stringify(list))
    
        this.refs.user.value = this.refs.content.value = ''
    
        this.props.reload()
      }
    }
    ```
4. main.js中引用
    
    ```
    import React from 'react'
    import ReactDOM from 'react-dom'
    import CmtList from './components/Comment/CmtList.jsx'
    // 使用 render 函数渲染 虚拟DOM
    ReactDOM.render(<div>
      <BindThis></BindThis>
    </div>, document.getElementById('app'))
    ```
        
## context特性
1. 如果一个组件1嵌套组件2嵌套组件3，组件1为父组件，2为子组件，3为孙组件。
2. 如果组件1要给组件3传递数据，通常的方法是通过props属性层层传递
    
    ```
    export default class Com1 extends React.Component {
  constructor(props) {
        super(props)
    
        this.state = {
          color: 'red'
        }
      }
    
      render() {
        return <div>
          <h1>这是 父组件 </h1>
          <Com2 color={this.state.color}></Com2>
        </div>
      }
    }
    // 中间的子组件
    class Com2 extends React.Component {
      render() {
        return <div>
          <h3>这是 子组件 </h3>
          <Com3 color={this.props.color}></Com3>
        </div>
      }
    }
    
    // 内部的孙子组件
    class Com3 extends React.Component {
      render() {
        return <div>
          <h5 style={{ color: this.props.color }}>这是 孙子组件 </h5>
        </div>
      }
    } 
    ```
3. 通过context直接传递
    
    ```
    // 最外层的父组件
    export default class Com1 extends React.Component {
      constructor(props) {
        super(props)
        this.state = {
          color: 'red'
        }
      }
    
      //   getChildContextTypes
      // 1. 在 父组件中，定义一个 function，这个function 有个固定的名称，叫做 getChildContext ，内部，必须 返回一个 对象，这个对象，就是要共享给 所有子孙自建的  数据
      getChildContext() {
        return {
          color: this.state.color
        }
      }
    
      // 2. 使用 属性校验，规定一下传递给子组件的 数据类型， 需要定义 一个 静态的（static） childContextTypes（固定名称，不要改）
      static childContextTypes = {
        color: ReactTypes.string // 规定了 传递给子组件的 数据类型
      }
      render() {
        return <div>
          <h1>这是 父组件 </h1>
          <Com2></Com2>
        </div>
      }
    }
    // 中间的子组件
    class Com2 extends React.Component {
      render() {
        return <div>
          <h3>这是 子组件 </h3>
          <Com3></Com3>
        </div>
      }
    }

    // 内部的孙子组件
    class Com3 extends React.Component {
    
      // 3. 上来之后，先来个属性校验，去校验一下父组件传递过来的 参数类型
      static contextTypes = {
        color: ReactTypes.string // 这里，如果子组件，想要使用 父组件通过 context 共享的数据，那么在使用之前，一定要先 做一下数据类型校验
      }
    
      render() {
        return <div>
          <h5 style={{ color: this.context.color }}>这是 孙子组件  ---  {this.context.color} </h5>
        </div>
      }
    }
    ```

