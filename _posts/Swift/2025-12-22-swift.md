---
layout: post
title: Swift第九章 访问控制、内存管理
category: Swift
tags: Swift
description: Swift
---


## 访问控制（Access Control）
1. 在访问权限控制这块，Swift提供了5个不同的访问级别（以下是从高到低排列， 实体指被访问级别修饰的内容）
    1. open：允许在定义实体的**模块**、其他模块中访问，允许其他模块进行继承、重写（open只能用在类、类成员上）
    2. public：允许在定义实体的模块、其他模块中访问，不允许其他模块进行继承、重写
    3. internal：只允许在定义实体的模块中访问，不允许在其他模块中访问
    4. fileprivate：只允许在定义实体的源文件中访问
    5. private：只允许在定义实体的封闭声明中访问
2. 绝大部分实体默认都是 internal 级别

### 访问级别的使用准则
1. 一个实体不可以被更低访问级别的实体定义，比如
    1. 变量\常量类型 ≥ 变量\常量：定义一个类型的访问级别肯定要大于变量，因为这样，变量才可以到处定义。比如： 新建一个Person类型，其他地方可以创建这个实例变量p，说明这个Person类型访问基本要≥p访问级别。
    2. 参数类型、返回值类型 ≥ 函数：其他地方要调用这个函数，必然要设置参数、获取返回值
    3. 父类 ≥ 子类： 子类要继承父类，其他地方可以访问父类。
    4. 父协议 ≥ 子协议
    5. 原类型 ≥ typealias
    6. 原始值类型、关联值类型 ≥ 枚举类型
    7. 定义类型A时用到的其他类型 ≥ 类型A

### 元组类型
1. 元组类型的访问级别是所有成员类型最低的那个
    
    ```
    internal struct Dog {}
    fileprivate class Person {}
    
    // (Dog, Person)的访问级别是fileprivate，成员中取最小
    //变量data1访问级别fileprivate = fileprivate
    fileprivate var data1: (Dog, Person)
    //变量data2访问级别private <fileprivate
    private var data2: (Dog, Person)
    ```

### 泛型类型
1. 泛型类型的访问级别是 类型的访问级别 以及 所有泛型类型参数的访问级别 中最低的那个
    
    ```
    internal class Car {}
    fileprivate class Dog {}
    
    
    public class Person<T1, T2> {}
    
    // Person<Car, Dog>的访问级别是fileprivate，类型、参数类型(Car、Dog)取最小为fileprivate
    //变量p的访问级别为fileprivate = 泛型类型访问级别fileprivate
    fileprivate var p = Person<Car, Dog>()
    ```

### 成员、嵌套类型
1. 类型的访问级别会影响成员（属性、方法、初始化器、下标）、嵌套类型的默认访问级别
2. 一般情况下，类型为private或fileprivate，那么成员\嵌套类型默认也是private或fileprivate
3. 一般情况下，类型为internal或public，那么成员\嵌套类型默认是internal
    
    ```
    public class PublicClass {
        public var p1 = 0 // public
        var p2 = 0 // internal
        fileprivate func f1() {} // fileprivate
        private func f2() {} // private
    }
    
    class InternalClass { // internal
        var p = 0 // internal
        fileprivate func f1() {} // fileprivate
        private func f2() {} // private
    }
    
    fileprivate class FilePrivateClass { // fileprivate
        func f1() {} // fileprivate
        private func f2() {} // private
    }
    
    private class PrivateClass { // private
        func f() {} // private
    }
    ```

### 成员的重写
1. 子类重写成员的访问级别必须 ≥ 子类的访问级别，或者 ≥ 父类被重写成员的访问级别
2. 父类的成员不能被成员作用域外定义的子类重写
    
    ```
    public class Person {
        private var age: Int = 0
        public class Student : Person {
            override var age: Int {
                set {}
                get {10}
            }
        }
    }
    ```

### 经典案例： 下面代码能否编译通过？
1. **直接在全局作用域下定义的private等价于fileprivate**
    
    ```
    //例1：可以编译通过，因为Person类在当前文件全局作用域，fileprivate是当前文件，因此二者的实际作用域是相等的。
    private class Person {}
    fileprivate class Student : Person {}
    
    //例2； 尽管这里是用private修饰，但是由于是在文件全局的结构体，所以本质等价于fileprivate，因此他的成员默认不是private，而是fileprivate
    private struct Dog {
        //注意：这里默认的是fileprivate
        var age: Int = 0
        func run() {}
    }
    fileprivate struct Person {
        var dog: Dog = Dog()
        mutating func walk() {
            //这里可以访问Dog的run，因为默认的是fileprivate
            dog.run()
            dog.age = 1
        }
    }
    
    //例3：
    private struct Dog {
        private var age: Int = 0
        private func run() {}
    }
    
    fileprivate struct Person {
        var dog: Dog = Dog()
        mutating func walk() {
            //Dog成员是private，因此下面报错！！！
            dog.run()
            dog.age = 1
        }
    }
    ```

### getter、setter
1. getter、setter默认自动接收它们所属环境的访问级别
2. 可以给setter单独设置一个比getter**更低**的访问级别，用以限制写的权限
    
    ```
    //当前文件的全局变量设置，fileprivate(set)说明只有当前文件可以修改，其他文件只能读取。
    fileprivate(set) public var num = 10
    
    //类的成员设置
    class Person {
        //存储属性：给这个成员的set设置为private，这样外界可以访问get，但是不能访问set
        private(set) var age = 0
        
        //计算属性，给set设置了一个fileprivate访问权限
        fileprivate(set) public var weight: Int {
            set {}
            get { 10 }
        }
        //下标：给set设置了一个internal访问权限
        internal(set) public subscript(index: Int) -> Int {
            set {}
            get { index }
        }
    }
    ```
    
### 初始化器
1. 如果一个public类想在另一个**模块**调用编译生成的默认无参初始化器init()，必须显式提供public的无参初始化器,因为public类的默认初始化器是internal级别
    
    ```
    //模块A
    public class Person {
        //必须显式提供public的无参初始化器,因为public类的默认初始化器是internal级别
        public init () {
        }
    }
    
    //模块B
    var p = Person()
    ``` 
1. required初始化器 ≥ 它的默认访问级别
2. 如果结构体有private\fileprivate的存储实例属性，那么它的成员初始化器也是private\fileprivate,否则默认就是internal
    
    ```
    struct Point {
       //一旦结构体有private\fileprivate的存储实例属性，那么编译器自动生成的成员初始化器也是private\fileprivate
       private var x = 0;
        var y = 0;
    }
    
    //下面报错，因为成员初始化器默认是private
    var p = Point(x: 10, y: 10)
    var p2 = Point(x: 10)
    ```

### 枚举类型的case
1. 不能给enum的每个case单独设置访问级别
2. 每个case自动接收enum的访问级别
3. public enum定义的case也是public

### 协议
1. 协议中定义的**要求**(实例、类方法等)自动接收协议的访问级别，不能单独设置访问级别，类似枚举
    1. public协议定义的**要求**也是public
2. **协议实现**的访问级别必须 ≥ 类型的访问级别，或者 ≥ 协议的访问级别 
    
    ```
    internal protocol Runnable {
        //不能单独设置访问级别，默认为internal
        func run()
    }
    fileprivate class Person : Runnable {
        //报错，协议实现 的访问级别必须 ≥ 类型的访问级别
        private func run(){
        }
    }
    ```
3. 下面代码能编译通过么？ 
    
    ```
    public protocol Runnable {
        func run()
    }
    public class Person : Runnable {
        //报错，因为默认是internal < 协议Runnable的访问级别了
        func run() {}
    }
    ```

### 扩展
1. 如果有显式设置扩展的访问级别，扩展添加的成员自动接收扩展的访问级别

    ```
    //A文件：表示这个扩展的run1访问级别也是fileprivate
    fileprivate extension Person {
        func run1() {}
    }
    
    //B文件：编译报错
    var p = Person();
    p.run1();
    ``` 
1. 如果没有显式设置扩展的访问级别，扩展添加的成员的默认访问级别，跟直接在类型中定义的成员一样
2. 可以单独给扩展添加的成员设置访问级别
3. 不能给用于遵守协议的扩展显式设置扩展的访问级别
    
    ```
    protocol Runnable {}
    //编译报错
    fileprivate extension Person: Runnable {
    ```
4. 在同一文件中的多个扩展，可以写成类似多个部分的类型声明
    1. 在原本的声明中声明一个私有成员，可以在同一文件的扩展中访问它
    2. 在扩展中声明一个私有成员，可以在同一文件的其他扩展中、原本声明中访问它

```
//a文件
public class Person {
    private func run0() {}
    private func eat0() {
        run1()
    }
}

//a文件
extension Person {
    private func run1() {}
    private func eat1() {
        //尽管run0在原来的类中是private，但是这也可以访问。
        run0()
    }
}

//a文件
extension Person {
    private func eat2() {
        //尽管run1在其他扩展中是private，但是这也可以访问。
        run1()
    }
}
```

### 将方法赋值给var\let
1. 方法也可以像函数那样，赋值给一个let或者var
    
    ```
    struct Person {
        var age: Int
        func run(_ v: Int) { print("func run", age, v) }
        static func run(_ v: Int) { print("static func run", v) }
    }
    
    //fn1的类型: (Person)->((Int)->())
    let fn1 = Person.run
    //本质调用的是实例方法
    fn1(10) // static func run 10
    
    // fn1的类型: (Int) -> ()
    let fn2: (Int) -> () = Person.run
    //本质调用的是类型方法
    fn2(20) // static func run 20
    
    //等价于fn1
    let fn3: (Person) -> ((Int) -> ()) = Person.run
    fn3(Person(age: 18))(30) // func run 18 30
    ``` 

## 内存管理
1. 跟OC一样，Swift也是采取基于引用计数的ARC内存管理方案（针对堆空间）
2. Swift的ARC中有3种引用
    1. 强引用（strong reference）：默认情况下，引用都是强引用
    2. 弱引用（weak reference）：通过weak定义弱引用
        1. 必须是**可选类型**的**var**，因为实例销毁后，ARC会自动将弱引用设置为nil
        2. ARC自动给弱引用设置nil时，不会触发属性观察器
3. 无主引用（unowned reference）：通过unowned定义无主引用
    1. 不会产生强引用，实例销毁后仍然存储着实例的内存地址（类似于OC中的unsafe_unretained）
    2. 试图在实例销毁后访问无主引用，会产生运行时错误（野指针）
        
        ```
        Fatal error: Attempted to read an unowned reference but object 0x0 was already deallocated
        ```
    
### weak、unowned的使用限制
1. weak、unowned只能用在类实例上面
    
    ```
    protocol Livable : AnyObject {}
    class Person {}
    weak var p0: Person?
    weak var p1: AnyObject?
    weak var p2: Livable?
    unowned var p10: Person?
    unowned var p11: AnyObject?
    unowned var p12: Livable?
    ```

### Autoreleasepool

```
public func autoreleasepool<Result>(invoking body: () throws -> Result) rethrows -> Result

autoreleasepool {
    let p = MJPerson(age: 20, name: "Jack")
    p.run()
}
```

### 循环引用（Reference Cycle）
1. weak、unowned 都能解决循环引用的问题，unowned 要比 weak 少一些性能消耗
    1. 在生命周期中可能会变为 nil 的使用 weak
    2. 初始化赋值后再也不会变为 nil 的使用 unowned
    
![1.png](https://gitee.com/zhonghua123/blogimgs/raw/master/img/swift7.png/)

### 闭包的循环引用
1. 闭包表达式默认会对用到的外层对象产生额外的强引用（对外层对象进行了retain操作）
2. 下面代码会产生循环引用，导致Person对象无法释放（看不到Person的deinit被调用）
    
    ```
    class Person {
        var fn: (() -> ())?
        func run() { print("run") }
        deinit { print("deinit") }
    }
    func test() {
        let p = Person()
        //fn是一个强引用属性，传值是一个闭包，闭包内部又使用了实例P，形成循环引用
        p.fn = { p.run() }
    }
    test()
    ```
3. 在闭包表达式的捕获列表声明weak或unowned引用，解决循环引用问题
    
    ```
    p.fn = {
        //weak是可选类型
        //如果有参数 [weak p](3) in
        [weak p] in
        p?.run()
    }
    p.fn = {
        //unowned是非可选类型
        [unowned p] in
        p.run()
    }
    p.fn = {
        //设置别名
        [weak wp = p, unowned up = p, a = 10 + 20] in
        wp?.run()
    }
    ```
4. 如果想在定义闭包属性的同时引用self，这个闭包**必须是lazy**的（因为在实例初始化完毕之后才能引用self）
    1. 左边的闭包fn内部如果用到了实例成员（属性、方法）,编译器会强制要求明确写出self。防止开发者忽略循环引用的问题。
    
    ```
    class Person {
        //由于是lazy，因此只有在使用到这属性时，才会形成循环引用
        lazy var fn: (() -> ()) = {
            [weak self] in
            //编译器强制要写self，直接这么写报错run()，为了避免忽略循环引用的问题
            self?.run()
        }
        func run() { print("run") }
        deinit { print("deinit") }
    }
    ``` 
5. 如果lazy属性是**闭包调用的结果**，那么不用考虑循环引用的问题（因为闭包调用后，闭包的生命周期就结束了）
    
    ```
    class Person {
        var age: Int = 0
        //getAge:闭包调用的结果
        lazy var getAge: Int = {
            self.age
        }()
        deinit { print("deinit") }
    }
    ``` 

### @escaping
1. 非逃逸闭包、逃逸闭包，一般都是当做参数传递给函数
2. 非逃逸闭包：闭包调用发生在函数结束前，闭包调用在函数作用域内
3. 逃逸闭包：闭包有可能在函数结束后调用，闭包调用逃离了函数的作用域，需要通过@escaping声明
    
    ```
    //非逃逸闭包
    func test(_fn:()->()) {
        //闭包调用发生在函数结束前，闭包调用在函数作用域内
        fn()
    }
    test {
        print(1)
    }
    
    import Dispatch
    typealias Fn = () -> ()
    
    // fn是非逃逸闭包
    func test1(_ fn: Fn) { fn() }
    
    // fn是逃逸闭包
    var gFn: Fn?
    func test2(_ fn: @escaping Fn) { gFn = fn }
    
    // fn是逃逸闭包
    func test3(_ fn: @escaping Fn) {
        //开线程在函数外部执行
        DispatchQueue.global().async {
            fn()
        }
    }
    
    class Person {
        var fn: Fn
        // fn是逃逸闭包
        init(fn: @escaping Fn) {
            self.fn = fn
        }
        func run() {
            // DispatchQueue.global().async也是一个逃逸闭包
            // 它用到了实例成员（属性、方法），编译器会强制要求明确写出self
            //这里不会产生循环引用，因为当前实例并没有强引用这个闭包
            DispatchQueue.global().async {
                self.fn()
            }
        }
    }
    ```
    
#### 逃逸闭包的注意点
1. 逃逸闭包不可以捕获inout参数
    
    ```
    typealias Fn = () -> ()
    func other1(_ fn: Fn) { fn() }
    func other2(_ fn: @escaping Fn) { fn() }
    func test(value: inout Int) -> Fn {
        other1 { value += 1 }
        // error: 逃逸闭包不能捕获inout参数
        other2 { value += 1 }
        func plus() { value += 1 }
        // error: 逃逸闭包不能捕获inout参数
        return plus
    }
    ```

### 内存访问冲突（Conflicting Access to Memory）
1. 内存访问冲突会在两个访问满足下列条件时发生：
    1. 至少一个是写入操作
    2. 它们访问的是同一块内存
    3. 它们的访问时间重叠（比如在同一个函数内）
    
    ```
    // 不存在内存访问冲突
    func plus(_ num: inout Int) -> Int { num + 1 }
    var number = 1
    number = plus(&number)
    // 存在内存访问冲突
    // Simultaneous accesses to 0x0, but modification requires exclusive access
    var step = 1
    func increment(_ num: inout Int) { num += step }
    increment(&step)
    // 解决内存访问冲突
    var copyOfStep = step
    increment(&copyOfStep)
    step = copyOfStep
    ```