---
layout: post
title: Swift第九章 访问控制、内存管理
category: Swift
tags: Swift
description: Swift
---


## 访问控制（Access Control）
1. 在访问权限控制这块，Swift提供了5个不同的访问级别（以下是从高到低排列， 实体指被访问级别修饰的内容）
    1. open：允许在定义实体的**模块**、其他模块中访问，允许其他模块进行继承、重写（open只能用在类、类成员上）
    2. public：允许在定义实体的模块、其他模块中访问，不允许其他模块进行继承、重写
    3. internal：只允许在定义实体的模块中访问，不允许在其他模块中访问
    4. fileprivate：只允许在定义实体的源文件中访问
    5. private：只允许在定义实体的封闭声明中访问
2. 绝大部分实体默认都是 internal 级别

### 访问级别的使用准则
1. 一个实体不可以被更低访问级别的实体定义，比如
    1. 变量\常量类型 ≥ 变量\常量：定义一个类型的访问级别肯定要大于变量，因为这样，变量才可以到处定义。比如： 新建一个Person类型，其他地方可以创建这个实例变量p，说明这个Person类型访问基本要≥p访问级别。
    2. 参数类型、返回值类型 ≥ 函数：其他地方要调用这个函数，必然要设置参数、获取返回值
    3. 父类 ≥ 子类： 子类要继承父类，其他地方可以访问父类。
    4. 父协议 ≥ 子协议
    5. 原类型 ≥ typealias
    6. 原始值类型、关联值类型 ≥ 枚举类型
    7. 定义类型A时用到的其他类型 ≥ 类型A

### 元组类型
1. 元组类型的访问级别是所有成员类型最低的那个
    
    ```
    internal struct Dog {}
    fileprivate class Person {}
    
    // (Dog, Person)的访问级别是fileprivate，成员中取最小
    //变量data1访问级别fileprivate = fileprivate
    fileprivate var data1: (Dog, Person)
    //变量data2访问级别private <fileprivate
    private var data2: (Dog, Person)
    ```

### 泛型类型
1. 泛型类型的访问级别是 类型的访问级别 以及 所有泛型类型参数的访问级别 中最低的那个
    
    ```
    internal class Car {}
    fileprivate class Dog {}
    
    
    public class Person<T1, T2> {}
    
    // Person<Car, Dog>的访问级别是fileprivate，类型、参数类型(Car、Dog)取最小为fileprivate
    //变量p的访问级别为fileprivate = 泛型类型访问级别fileprivate
    fileprivate var p = Person<Car, Dog>()
    ```

### 成员、嵌套类型
1. 类型的访问级别会影响成员（属性、方法、初始化器、下标）、嵌套类型的默认访问级别
2. 一般情况下，类型为private或fileprivate，那么成员\嵌套类型默认也是private或fileprivate
3. 一般情况下，类型为internal或public，那么成员\嵌套类型默认是internal
    
    ```
    public class PublicClass {
        public var p1 = 0 // public
        var p2 = 0 // internal
        fileprivate func f1() {} // fileprivate
        private func f2() {} // private
    }
    
    class InternalClass { // internal
        var p = 0 // internal
        fileprivate func f1() {} // fileprivate
        private func f2() {} // private
    }
    
    fileprivate class FilePrivateClass { // fileprivate
        func f1() {} // fileprivate
        private func f2() {} // private
    }
    
    private class PrivateClass { // private
        func f() {} // private
    }
    ```

### 成员的重写
1. 子类重写成员的访问级别必须 ≥ 子类的访问级别，**或者** ≥ 父类被重写成员的访问级别
2. 父类的成员不能被成员作用域外定义的子类重写
    
    ```
    public class Person {
        //成员的作用域private在当前{},因此如果子类要重写这个成员，就必须定义成内部类
        private var age: Int = 0
        public class Student : Person {
            override var age: Int {
                set {}
                get {10}
            }
        }
    }
    ```

### 经典案例： 下面代码能否编译通过？
1. **直接在全局作用域下定义的private等价于fileprivate**
    
    ```
    //例1：可以编译通过，因为Person类在当前文件全局作用域，fileprivate是当前文件，因此二者的实际作用域是相等的。
    private class Person {}
    fileprivate class Student : Person {}
    
    //例2； 尽管这里是用private修饰，但是由于是在文件全局的结构体，所以本质等价于fileprivate，因此他的成员默认不是private，而是fileprivate
    private struct Dog {
        //注意：这里默认的是fileprivate
        var age: Int = 0
        func run() {}
    }
    fileprivate struct Person {
        var dog: Dog = Dog()
        mutating func walk() {
            //这里可以访问Dog的run，因为默认的是fileprivate
            dog.run()
            dog.age = 1
        }
    }
    
    //例3：
    private struct Dog {
        private var age: Int = 0
        private func run() {}
    }
    
    fileprivate struct Person {
        var dog: Dog = Dog()
        mutating func walk() {
            //Dog成员是private，因此下面报错！！！
            dog.run()
            dog.age = 1
        }
    }
    ```

### getter、setter
1. getter、setter默认自动接收它们所属环境的访问级别
2. 可以给setter单独设置一个比getter**更低**的访问级别，用以限制写的权限
    
    ```
    //当前文件的全局变量设置，fileprivate(set)说明只有当前文件可以修改，其他文件只能读取。
    fileprivate(set) public var num = 10
    
    //类的成员设置
    class Person {
        //存储属性：给这个成员的set设置为private，这样外界可以访问get，但是不能访问set
        private(set) var age = 0
        
        //计算属性，给set设置了一个fileprivate访问权限
        fileprivate(set) public var weight: Int {
            set {}
            get { 10 }
        }
        //下标：给set设置了一个internal访问权限
        internal(set) public subscript(index: Int) -> Int {
            set {}
            get { index }
        }
    }
    ```
    
### 初始化器
1. 如果一个public类想在另一个**模块**调用编译生成的默认无参初始化器init()，必须显式提供public的无参初始化器,因为public类的默认初始化器是internal级别
    
    ```
    //模块A
    public class Person {
        //必须显式提供public的无参初始化器,因为public类的默认初始化器是internal级别
        public init () {
        }
    }
    
    //模块B
    var p = Person()
    ``` 
2. required初始化器 ≥ 它的默认访问级别
3. 如果结构体有private\fileprivate的存储实例属性，那么它的成员初始化器也是private\fileprivate,否则默认就是internal
    
    ```
    struct Point {
       //一旦结构体有private\fileprivate的存储实例属性，那么编译器自动生成的成员初始化器也是private\fileprivate
       private var x = 0;
        var y = 0;
    }
    
    //下面报错，因为成员初始化器默认是private
    var p = Point(x: 10, y: 10)
    var p2 = Point(x: 10)
    ```

### 枚举类型的case
1. 不能给enum的每个case单独设置访问级别
2. 每个case自动接收enum的访问级别
3. public enum定义的case也是public

### 协议
1. 协议中定义的**要求**(实例、类方法等)自动接收协议的访问级别，不能单独设置访问级别，类似枚举
    1. public协议定义的**要求**也是public
2. **协议实现**的访问级别必须 ≥ 类型的访问级别，或者 ≥ 协议的访问级别 
    
    ```
    internal protocol Runnable {
        //不能单独设置访问级别，默认为internal
        func run()
    }
    fileprivate class Person : Runnable {
        //报错，协议实现 的访问级别必须 ≥ 类型的访问级别
        private func run(){
        }
    }
    ```
3. 下面代码能编译通过么？ 
    
    ```
    public protocol Runnable {
        func run()
    }
    public class Person : Runnable {
        //报错，因为默认是internal < 协议Runnable的访问级别了
        func run() {}
    }
    ```

### 扩展
1. 如果有显式设置扩展的访问级别，扩展添加的成员自动接收扩展的访问级别

    ```
    //A文件：表示这个扩展的run1访问级别也是fileprivate
    fileprivate extension Person {
        func run1() {}
    }
    
    //B文件：编译报错
    var p = Person();
    p.run1();
    ``` 
1. 如果没有显式设置扩展的访问级别，扩展添加的成员的默认访问级别，跟直接在类型中定义的成员一样
2. 可以单独给扩展添加的成员设置访问级别
3. 不能给用于遵守协议的扩展显式设置扩展的访问级别
    
    ```
    protocol Runnable {}
    //编译报错
    fileprivate extension Person: Runnable {
    ```
4. 在同一文件中的多个扩展，可以写成类似多个部分的类型声明
    1. 在原本的声明中声明一个私有成员，可以在同一文件的扩展中访问它
    2. 在扩展中声明一个私有成员，可以在同一文件的其他扩展中、原本声明中访问它

```
//a文件
public class Person {
    private func run0() {}
    private func eat0() {
        run1()
    }
}

//a文件
extension Person {
    private func run1() {}
    private func eat1() {
        //尽管run0在原来的类中是private，但是这也可以访问。
        run0()
    }
}

//a文件
extension Person {
    private func eat2() {
        //尽管run1在其他扩展中是private，但是这也可以访问。
        run1()
    }
}
```

### 将方法赋值给var\let
1. 方法也可以像函数那样，赋值给一个let或者var
    
    ```
    struct Person {
        var age: Int
        func run(_ v: Int) { print("func run", age, v) }
        static func run(_ v: Int) { print("static func run", v) }
    }
    
    //fn1的类型: (Person)->((Int)->())
    let fn1 = Person.run
    //本质调用的是实例方法
    fn1(10) // static func run 10
    
    // fn1的类型: (Int) -> ()
    let fn2: (Int) -> () = Person.run
    //本质调用的是类型方法
    fn2(20) // static func run 20
    
    //等价于fn1
    let fn3: (Person) -> ((Int) -> ()) = Person.run
    fn3(Person(age: 18))(30) // func run 18 30
    ``` 

## 内存管理
1. 跟OC一样，Swift也是采取基于引用计数的ARC内存管理方案（针对堆空间）
2. Swift的ARC中有3种引用
    1. 强引用（strong reference）：默认情况下，引用都是强引用
    2. 弱引用（weak reference）：通过weak定义弱引用
        1. 必须是**可选类型**的**var**，因为实例销毁后，ARC会自动将弱引用设置为nil
        2. ARC自动给弱引用设置nil时，不会触发属性观察器
3. 无主引用（unowned reference）：通过unowned定义无主引用
    1. 不会产生强引用，实例销毁后仍然存储着实例的内存地址（类似于OC中的unsafe_unretained）
    2. 试图在实例销毁后访问无主引用，会产生运行时错误（野指针）
        
        ```
        Fatal error: Attempted to read an unowned reference but object 0x0 was already deallocated
        ```
    
### weak、unowned的使用限制
1. weak、unowned只能用在类实例上面
    
    ```
    protocol Livable : AnyObject {}
    class Person {}
    weak var p0: Person?
    weak var p1: AnyObject?
    weak var p2: Livable?
    unowned var p10: Person?
    unowned var p11: AnyObject?
    unowned var p12: Livable?
    ```

### Autoreleasepool

```
public func autoreleasepool<Result>(invoking body: () throws -> Result) rethrows -> Result

autoreleasepool {
    let p = MJPerson(age: 20, name: "Jack")
    p.run()
}
```

### 循环引用（Reference Cycle）
1. weak、unowned 都能解决循环引用的问题，unowned 要比 weak 少一些性能消耗
    1. 在生命周期中可能会变为 nil 的使用 weak
    2. 初始化赋值后再也不会变为 nil 的使用 unowned
    
![1.png](https://gitee.com/zhonghua123/blogimgs/raw/master/img/swift7.png/)

### 闭包的循环引用
1. 闭包表达式默认会对用到的外层对象产生额外的强引用（对外层对象进行了retain操作）
2. 下面代码会产生循环引用，导致Person对象无法释放（看不到Person的deinit被调用）
    
    ```
    class Person {
        var fn: (() -> ())?
        func run() { print("run") }
        deinit { print("deinit") }
    }
    func test() {
        let p = Person()
        //fn是一个强引用属性，传值是一个闭包，闭包内部又使用了实例P，形成循环引用
        p.fn = { p.run() }
    }
    test()
    ```
3. 在闭包表达式的捕获列表声明weak或unowned引用，解决循环引用问题
    
    ```
    p.fn = {
        //weak是可选类型
        //如果有参数 [weak p](3) in
        [weak p] in
        p?.run()
    }
    p.fn = {
        //unowned是非可选类型
        [unowned p] in
        p.run()
    }
    p.fn = {
        //设置别名
        [weak wp = p, unowned up = p, a = 10 + 20] in
        wp?.run()
    }
    ```
4. 如果想在定义闭包属性的同时引用self，这个闭包**必须是lazy**的（因为在实例初始化完毕之后才能引用self）
    1. 左边的闭包fn内部如果用到了实例成员（属性、方法）,编译器会强制要求明确写出self。防止开发者忽略循环引用的问题。
    
    ```
    class Person {
        //由于是lazy，因此只有在使用到这属性时，才会形成循环引用
        lazy var fn: (() -> ()) = {
            [weak self] in
            //编译器强制要写self，直接这么写报错run()，为了避免忽略循环引用的问题
            self?.run()
        }
        func run() { print("run") }
        deinit { print("deinit") }
    }
    ``` 
5. 如果lazy属性是**闭包调用的结果**，那么不用考虑循环引用的问题（因为闭包调用后，闭包的生命周期就结束了）
    
    ```
    class Person {
        var age: Int = 0
        //getAge:闭包调用的结果
        lazy var getAge: Int = {
            self.age
        }()
        deinit { print("deinit") }
    }
    ``` 

### @escaping
1. 非逃逸闭包、逃逸闭包，一般都是当做参数传递给函数
2. 非逃逸闭包：闭包调用发生在函数结束前，闭包调用在函数作用域内
3. 逃逸闭包：闭包有可能在函数结束后调用，闭包调用逃离了函数的作用域，需要通过@escaping声明
    
    ```
    //非逃逸闭包
    func test(_fn:()->()) {
        //闭包调用发生在函数结束前，闭包调用在函数作用域内
        fn()
    }
    test {
        print(1)
    }
    
    import Dispatch
    typealias Fn = () -> ()
    
    // fn是非逃逸闭包
    func test1(_ fn: Fn) { fn() }
    
    // fn是逃逸闭包
    var gFn: Fn?
    func test2(_ fn: @escaping Fn) { gFn = fn }
    
    // fn是逃逸闭包
    func test3(_ fn: @escaping Fn) {
        //开线程在函数外部执行
        DispatchQueue.global().async {
            fn()
        }
    }
    
    class Person {
        var fn: Fn
        // fn是逃逸闭包
        init(fn: @escaping Fn) {
            self.fn = fn
        }
        func run() {
            // DispatchQueue.global().async也是一个逃逸闭包
            // 它用到了实例成员（属性、方法），编译器会强制要求明确写出self
            //这里不会产生循环引用，因为当前实例并没有强引用这个闭包
            DispatchQueue.global().async {
                self.fn()
            }
        }
    }
    ```
    
#### 逃逸闭包的注意点
1. 逃逸闭包不可以捕获inout参数
    
    ```
    typealias Fn = () -> ()
    //非逃逸闭包
    func other1(_ fn: Fn) { fn() }
    //可以将一个非逃逸闭包，声明为一个逃逸闭包
    func other2(_ fn: @escaping Fn) { fn() }
    
    //当前函数的参数为inout类型
    func test(value: inout Int) -> Fn {
        other1 { value += 1 }
        // error: 逃逸闭包不能捕获inout参数
        other2 { value += 1 }
        //创建一个函数，这个函数用到了inout参数，由于这个函数可以在当前函数执行结束后执行，因此等价于逃逸闭包
        func plus() { value += 1 }
        // error: 逃逸闭包不能捕获inout参数
        return plus
    }
    ```
2. 原因分析： 如果逃逸闭包捕获了当前函数的inout参数，如果外部的参数是具备变量，早已销毁，就会造成空指针调用
    
    ```
    func abc() { 
        var num = 10
        test(&num)
    }
    abc()
    //如果逃逸闭包在这里才开始调用，那么此时的num已经被释放了，&num是空指针
    ...
    ```

### 内存访问冲突（Conflicting Access to Memory）
1. 内存访问冲突会在两个访问满足下列条件时发生：
    1. 至少一个是写入操作
    2. 它们访问的是同一块内存
    3. 它们的访问时间重叠（比如在同一个函数内）
    
    ```
    // 不存在内存访问冲突
    func plus(_ num: inout Int) -> Int { num + 1 }
    var number = 1
    number = plus(&number)
    
    // 存在内存访问冲突
    // Simultaneous accesses to 0x0, but modification requires exclusive access
    var step = 1
    func increment(_ num: inout Int) { 
        //本质是纪要读取step的内存，又要写入step的内存
        num += step 
    }
    increment(&step)
    
    // 解决内存访问冲突
    var copyOfStep = step
    increment(&copyOfStep)
    step = copyOfStep
    ```
2. 举例
    
    ```
    func balance(_ x: inout Int, _ y: inout Int) {
        let sum = x + y
        x = sum / 2
        y = sum - x
    }
    var num1 = 42
    var num2 = 30
    balance(&num1, &num2) // OK
    balance(&num1, &num1) // Error
    
    struct Player {
        var name: String
        var health: Int
        var energy: Int
        mutating func shareHealth(with teammate: inout Player) {
            balance(&teammate.health, &health)
        }
    }
    var oscar = Player(name: "Oscar", health: 10, energy: 10)
    var maria = Player(name: "Maria", health: 5, energy: 10)
    oscar.shareHealth(with: &maria) // OK
    oscar.shareHealth(with: &oscar) // Error
    
    var tulpe = (health: 10, energy: 20)
    // Error
    balance(&tulpe.health, &tulpe.energy)
    
    var holly = Player(name: "Holly", health: 10, energy: 10)
    // Error
    balance(&holly.health, &holly.energy)
    ```
3. 如果下面的条件可以满足，就说明重叠访问结构体的属性是安全的
    1. 你只访问实例存储属性，不是计算属性或者类属性
    2. 结构体是局部变量而非全局变量
    2. 结构体要么没有被闭包捕获要么只被非
    
    ```
    //Ok
    func test() {
        var tulpe = (health: 10, energy: 20)
        balance(&tulpe.health, &tulpe.energy)
        var holly = Player(name: "Holly", health: 10, energy: 10)
        balance(&holly.health, &holly.energy)
    }
    test()
    ```

## 指针
1. Swift中也有专门的指针类型，这些都被定性为“Unsafe”（不安全的），常见的有以下4种类型
    1. `UnsafePointer<Pointee> `类似于C语言 const Pointee *
    2. `UnsafeMutablePointer<Pointee> `类似于C语言 Pointee *
    3. `UnsafeRawPointer` 类似于C语言 const void *
    4. `UnsafeMutableRawPointer` 类似于C语言 void *
    
    ```
    var age = 10
    //可修改指针
    func test1(_ ptr: UnsafeMutablePointer<Int>) {
        ptr.pointee += 10
    }
    //只读指针
    func test2(_ ptr: UnsafePointer<Int>) {
        print(ptr.pointee)
    }
    test1(&age)
    test2(&age) // 20
    print(age) // 20
    
    var age = 10
    func test3(_ ptr: UnsafeMutableRawPointer) {//const void *
        //由于不知道指针的类型，因此使用storeBytes
        ptr.storeBytes(of: 20, as: Int.self)
    }
    func test4(_ ptr: UnsafeRawPointer) { //void *
        //由于不知道指针的类型，因此使用load
        print(ptr.load(as: Int.self))
    }
    test3(&age)
    test4(&age) // 20
    print(age) // 20
    ```
    
### 指针的应用示例
    
    ```
    var arr = NSArray(objects: 11, 22, 33, 44)
    //stop类型就是UnsafeMutablePointer<ObjcBool>
    arr.enumerateObjects { (obj, idx, stop) in
        print(idx, obj)
        if idx == 2 { // 下标为2就停止遍历
            stop.pointee = true
        }
    }
    
    //数组遍历方式2，常用arr.enumerated()
    var arr = NSArray(objects: 11, 22, 33, 44)
    for (idx, obj) in arr.enumerated() {
        print(idx, obj)
        if idx == 2 {
            break
        }
    }
    ```
    
### 获得指向某个变量的指针
    
    ```
    var age = 11
    //获取指向age的指针
    //ptr1类型为UnsafeMutablePointer<Int>
    var ptr1 = withUnsafeMutablePointer(to: &age) { $0 }
    //ptr2类型为UnsafePointer<Int>
    var ptr2 = withUnsafePointer(to: &age) { $0 }
    ptr1.pointee = 22 //泛型指针的修改值
    print(ptr2.pointee) // 22,泛型指针的取值
    print(age) // 22
    
    //ptr3类型为UnsafeMutablePointer
    var ptr3 = withUnsafeMutablePointer(to: &age) { UnsafeMutableRawPointer($0) }
    //ptr2类型为UnsafePointer
    var ptr4 = withUnsafePointer(to: &age) { UnsafeRawPointer($0) }
    ptr3.storeBytes(of: 33, as: Int.self) //非泛型取值设置值
    print(ptr4.load(as: Int.self)) // 33，非泛型取值
    print(age) // 33
    ```

### 获得指向堆空间实例的指针
    
    ```
    class Person {}
    var person = Person()
    //存储的是person变量的地址值
    var ptr = withUnsafePointer(to: &person) { UnsafeRawPointer($0) }
    
    //存储的是person实例的地址值
    var heapPtr = UnsafeRawPointer(bitPattern: ptr.load(as: UInt.self))
    print(heapPtr!)
    ```
    
### 创建指针
    
    ```
    var ptr = UnsafeRawPointer(bitPattern: 0x100001234)
    
    // 创建
    var ptr = malloc(16)
    // 存
    ptr?.storeBytes(of: 11, as: Int.self)
    ptr?.storeBytes(of: 22, toByteOffset: 8, as: Int.self)
    // 取
    print((ptr?.load(as: Int.self))!) // 11
    print((ptr?.load(fromByteOffset: 8, as: Int.self))!) // 22
    // 销毁
    free(ptr)
    
    var ptr = UnsafeMutableRawPointer.allocate(byteCount: 16, alignment: 1)
    // 存
    ptr.storeBytes(of: 11, as: Int.self)
    //存：指针偏移8个字节，然后存储指尾22
    ptr.advanced(by: 8).storeBytes(of: 22, as: Int.self)
    // 取
    print(ptr.load(as: Int.self)) // 11
    print(ptr.advanced(by: 8).load(as: Int.self)) // 22
    // 销毁
    ptr.deallocate()
    
    //创建泛型指针，capacity容量，3代表24个字节
    var ptr = UnsafeMutablePointer<Int>.allocate(capacity: 3)
    //初始化内存为11
    ptr.initialize(to: 11)
    //初始化下一个类型（Int）字节的内存，然后初始化为22
    ptr.successor().initialize(to: 22)
    //初始化下2个类型（Int）字节的内存，然后初始化为33
    ptr.successor().successor().initialize(to: 33)
    // 取
    print(ptr.pointee) // 11
    print((ptr + 1).pointee) // 22
    print((ptr + 2).pointee) // 33
    print(ptr[0]) // 11
    print(ptr[1]) // 22
    print(ptr[2]) // 33
    // 销毁
    ptr.deinitialize(count: 3) //反初始化销毁
    ptr.deallocate()
    
    //创建指向堆内存中的指针
    class Person {
        var age: Int
        var name: String
        init(age: Int, name: String) {
            self.age = age
            self.name = name
        }
        deinit { print(name, "deinit") }
    }
    
    
    var ptr = UnsafeMutablePointer<Person>.allocate(capacity: 3)
    ptr.initialize(to: Person(age: 10, name: "Jack"))
    (ptr + 1).initialize(to: Person(age: 11, name: "Rose"))
    (ptr + 2).initialize(to: Person(age: 12, name: "Kate"))
    // Jack deinit
    // Rose deinit
    // Kate deinit
    ptr.deinitialize(count: 3)
    ptr.deallocate()
    ```

### 指针之间的转换
    
    ```
    var ptr = UnsafeMutableRawPointer.allocate(byteCount: 16, alignment: 1)
    //assumingMemoryBound将非泛型指针转为泛型指针
    ptr.assumingMemoryBound(to: Int.self).pointee = 11
    (ptr + 8).assumingMemoryBound(to: Double.self).pointee = 22.0
    //unsafeBitCast将ptr类型强制转换为UnsafePointer<Int>
    print(unsafeBitCast(ptr, to: UnsafePointer<Int>.self).pointee) // 11
    print(unsafeBitCast(ptr + 8, to: UnsafePointer<Double>.self).pointee) // 22.0
    ptr.deallocate()
    ```
1. unsafeBitCast是忽略数据类型的强制转换，不会因为数据类型的变化而改变原来的内存数据，类似于C++中的reinterpret_cast
2. 比如Int类型的10，强制转换为Double，那么结果不是10.0，因为unsafeBitCast会直接将10的二进制放到Double的存储空间中去。因为Double的存储空间存储方式跟Int存储不同，所以结果不是10。
3. 但是如果指针之间的转换就没有问题，以为任何类型指针之间存储的方式是相同的。
    
    ```
    class Person {}
    var person = Person()
    //ptr存储的地址就是堆空间的地址。unsafeBitCast本质是将person变量内存放的数据，直接赋值给ptr
    var ptr = unsafeBitCast(person, to: UnsafeRawPointer.self)
    print(ptr)
    ```