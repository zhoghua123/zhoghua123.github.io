---
layout: post
title: Swift第十一章 从OC到Swift
category: Swift
tags: Swift
description: Swift
---

## MARK、TODO、FIXME
1. `// MARK: `类似于OC中的 #pragma mark
2. `// MARK: -` 类似于OC中的 #pragma mark -
3. `// TODO: `用于标记未完成的任务
4. `// FIXME:` 用于标记待修复的问题
5. `#warning("xxx")` 警告

## 条件编译
1. 系统自带条件编译
    
    ```
    // 操作系统：macOS\iOS\tvOS\watchOS\Linux\Android\Windows\FreeBSD
    #if os(macOS) || os(iOS)
    // CPU架构：i386\x86_64\arm\arm64
    #elseif arch(x86_64) || arch(arm64)
    // swift版本
    #elseif swift(<5) && swift(>=3)
    // 模拟器环境
    #elseif targetEnvironment(simulator)
    // 可以导入某模块
    #elseif canImport(Foundation)
    #else
    #endif
    ```
2. 自定义条件编译
    
    ![1.png](https://gitee.com/zhonghua123/blogimgs/raw/master/img/swift8.png/)
    
    ```
    // debug模式
    #if DEBUG
    // release模式
    #else
    #endif
    
    //在Active compliation Conditions ->Debug  自定义内容：DEBUG TEST
    #if TEST
    print("test")
    #endif
    
    //Other Swift Flags ->Debug 自定义内容：-D OTHER
    #if OTHER
    print("other")
    #endif
    ```

## 打印
1. 由于Swift中没有宏定义，那如果需要实现dubug打印、release不打印怎么办？
2. 新建一个Log.swift文件
    
    ```
    func log<T>(_ msg: T,
    //#file当前执行所在环境的文件，作为参数的目的就是确保文件的路径是当前方法调用者的文件路径
    file: NSString = #file,
    //#line当前执行所在的行
    line: Int = #line,
    // #function当前执行所在的方法
    fn: String = #function) {
        //debug模式下打印
        #if DEBUG
        let prefix = "\(file.lastPathComponent)_\(line)_\(fn):"
        print(prefix, msg)
        //release不打印
        #endif
    }
    ```

## 系统版本检测
    
    ```
    if #available(iOS 10, macOS 10.12, *) {
        // 对于iOS平台，只在iOS10及以上版本执行
        // 对于macOS平台，只在macOS 10.12及以上版本执行
        // 最后的*表示在其他所有平台都执行
    }
    ```

## API可用性说明
1. 示例
    
    ```
    //当前类只支持iOS10
    @available(iOS 10, macOS 10.15, *)
    class Person {}
    
    struct Student {
        @available(*, unavailable, renamed: "study")
        func study_() {}
        func study() {}
        //表示该方法iOS11已经过期
        @available(iOS, deprecated: 11)
        @available(macOS, deprecated: 10.12)
        func run() {}
    }
    ```
2. 更多用法参考：https://docs.swift.org/swift-book/ReferenceManual/Attributes.html

## iOS程序的入口
1. 在AppDelegate上面默认有个`@UIApplicationMain`标记，这表示:编译器自动生成入口代码（main函数代码），自动设置AppDelegate为APP的代理
2. 也可以删掉@UIApplicationMain，自定义入口代码，这样可以实现自定义Application：新建一个main.swift文件(名字必须叫main)
    
    ```
    
    //创建一个自定义的ZHApplication.Swift
    class ZHApplication :UApplication {}
    
    main.swift
    //因为swift中不需要定义main函数，直接写main函数要执行的内容即可
    import UIKit
    import ZHApplication
    //main函数中调用UIApplicationMain方法，指定代理。前两个参数固定.第三个参数地表那个类作为application，第四个参数代表那个类作为代理
    UIApplicationMain(CommandLine.argc,CommandLine.unsafeArgv,
NSStringFromClass(ZHApplication.self),NSStringFromClass(AppDelegate.self))
    ```

## Swift调用OC
1. 场景:很多常用的第三方框架没有Swift版本，有些老项目Swift+OC混合开发

### 创建桥接文件
1. 手动创建： 
    1. 新建1个桥接头文件，文件名格式默认为：{targetName}-Bridging-Header.h，targetName一般就是项目名称
    2. 在BuildSetting->搜索bridging->Swift Compiler - General -> Objective -C Bridging Header 右侧设置交接文件的路径
    
        ![1.png](https://gitee.com/zhonghua123/blogimgs/raw/master/img/swift9.png/)
2. 自动创建
    1. 在Swift项目下，直接创建一个OC的类,编译其会提醒是否创建一个桥接文件,点击是,会自动创建上面的桥接文件,以及设置引用路径
3. 在 {targetName}-Bridging-Header.h 文件中 `#import OC`需要暴露给Swift的内容
    
    ```
    #import "ZHPerson.h"
    ```

### Swift调用OC
1. ZHPerson.h
    
    ```
    #import<Foundation/Foundation.h>
    //定义一个C语言函数
    int sum(int a, int b);
    
    @interface ZHPerson : NSObject
    @property (nonatomic, assign) NSInteger age;
    @property (nonatomic, copy) NSString *name;
    - (instancetype)initWithAge:(NSInteger)age name:(NSString *)name;
    + (instancetype)personWithAge:(NSInteger)age name:(NSString *)name;
    - (void)run;
    + (void)run;
    - (void)eat:(NSString *)food other:(NSString *)other;
    + (void)eat:(NSString *)food other:(NSString *)other;
    @end
    ```
2. ZHPerson.m
    
    ```
    @implementation ZHPerson
    - (instancetype)initWithAge:(NSInteger)age name:(NSString *)name {
        if (self = [super init]) {
            self.age = age;
            self.name = name;
        }
        return self;
    }
    + (instancetype)personWithAge:(NSInteger)age name:(NSString *)name {
        return [[self alloc] initWithAge:age name:name];
    }
    + (void)run { NSLog(@"Person +run"); }
    - (void)run { NSLog(@"%zd %@ -run", _age, _name); }
    + (void)eat:(NSString *)food other:(NSString *)other { NSLog(@"Person +eat %@ %@", food, other); }
    - (void)eat:(NSString *)food other:(NSString *)other { NSLog(@"%zd %@ -eat %@ %@", _age, _name, food, other); }
    @end
    //C语言函数实现
    int sum(int a, int b) { return a + b; }
    ```
3. Swift代码
    
    ```
    //这里不需要导入任何头文件，桥接文件代表全局导入
    
    //对应OC中initWithAge: name:
    var p = ZHPerson(age: 10, name: "Jack")
    p.age = 18
    p.name = "Rose"
    p.run() // 18 Rose -run
    p.eat("Apple", other: "Water") // 18 Rose -eat Apple Water
    ZHPerson.run() // Person +run
    ZHPerson.eat("Pizza", other: "Banana") // Person +eat Pizza Banana
    print(sum(10, 20)) // 30
    ```

### `@_silgen_name`
1. 如果C语言暴露给Swift的函数名跟Swift中的其他函数名冲突了,可以在Swift中使用 `@_silgen_name` 修改C函数名
2. 如果不修改，会默认使用Swift中的函数
    
    ```
    // C语言
    int sum(int a, int b) {
        return a + b;
    }
    
    // Swift
    //将C语言中的sum函数修改为swift_sum
    @_silgen_name("sum") func swift_sum(_ v1: Int32, _ v2: Int32) -> Int32
    print(swift_sum(10, 20)) // 30 调用C语言中的sum
    print(sum(10, 20)) // 30 调用Swift中的sum
    ```

## OC调用Swift
1. Xcode已经默认生成一个用于OC调用Swift的头文件，文件名格式是： {targetName}-Swift.h，在以下路径可以查看。在项目目录下没有，可以使用command+enter查看源文件。

    ![1.png](https://gitee.com/zhonghua123/blogimgs/raw/master/img/swift10.png/)
2. 使用条件
    1. Swift暴露给OC的类最终继承自NSObject
    2. 使用`@objc`修饰需要暴露给OC的成员---指定某个成员（变量、方法）暴露
    3. 使用`@objcMembers`修饰类---所有成员都暴露
        1. 代表默认所有成员都会暴露给OC（包括扩展中定义的成员）
        2. 最终是否成功暴露，还需要考虑成员自身的访问级别
3. 举例：
    
    ```
    import Foundation
    @objcMembers class Car: NSObject {
        var price: Double
        var band: String
        init(price: Double, band: String) {
            self.price = price
            self.band = band
        }
        func run() { print(price, band, "run") }
        static func run() { print("Car run") }
    }
    extension Car {
        func test() { print(price, band, "test") }
    }
    ```
4. Xcode会根据Swift代码生成对应的OC声明，写入 `{targetName}-Swift.h `文件
    
    ```
    @interface Car : NSObject
        @property (nonatomic) double price;
        @property (nonatomic, copy) NSString * _Nonnull band;
        - (nonnull instancetype)initWithPrice:(double)price band:(NSString * _Nonnull)band OBJC_DESIGNATED_INITIALIZER;
        - (void)run;
        + (void)run;
        - (nonnull instancetype)init SWIFT_UNAVAILABLE;
        + (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
    @end
    
    @interface Car (SWIFT_EXTENSION(备课_Swift))
        - (void)test;
    @end
    ```
5. OC调用Swift代码
    
    ```
    #import "备课_Swift-Swift.h"
    int sum(int a, int b) {
        Car *c = [[Car alloc] initWithPrice:10.5 band:@"BMW"];
        c.band = @"Bently";
        c.price = 108.5;
        [c run]; // 108.5 Bently run
        [c test]; // 108.5 Bently test
        [Car run]; // Car run
        return a + b;
    }
    ```

### @objc
1. 可以通过 `@objc` 重命名Swift暴露给OC的符号名（类名、属性名、函数名等）
    
    ```
    //Swift源码
    @objc(ZHCar)
    @objcMembers class Car: NSObject {
        var price: Double
        @objc(name)
        var band: String
        init(price: Double, band: String) {
            self.price = price
            self.band = band
        }
        @objc(drive)
        func run() { print(price, band, "run") }
        static func run() { print("Car run") }
    }
    
    extension Car {
        @objc(exec:v2:)
        func test() { print(price, band, "test") }
    }
    
    //OC调用Swift代码
    ZHCar *c = [[ZHCar alloc] initWithPrice:10.5 band:@"BMW"];
    c.name = @"Bently";
    c.price = 108.5;
    [c drive]; // 108.5 Bently run
    [c exec:10 v2:20]; // 108.5 Bently test
    [ZHCar run]; // Car run
    ```

### 选择器（Selector）
1. Swift中依然可以使用选择器，使用`#selector(name)`定义一个选择器
2. 必须是被`@objcMembers`或`@objc`修饰的方法才可以定义选择器
    
    ```
    //Swift源码
    @objcMembers class Person: NSObject {
        func test1(v1: Int) { print("test1") }
        func test2(v1: Int, v2: Int) { print("test2(v1:v2:)") }
        func test2(_ v1: Double, _ v2: Double) { print("test2(_:_:)") }
        func run() {
            perform(#selector(test1))
            perform(#selector(test1(v1:)))
            perform(#selector(test2(v1:v2:)))
            perform(#selector(test2(_:_:)))
            perform(#selector(test2 as (Double, Double) -> Void))
        }
    }
    ```