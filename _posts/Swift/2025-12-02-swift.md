---
layout: post
title: Swift第三章 结构体和类
category: Swift
tags: Swift
description: Swift
---

## 结构体
1. 在 Swift 标准库中，绝大多数的公开类型都是结构体，而枚举和类只占很小一部分
    1. 比如Bool、Int、Double、 String、Array、Dictionary等常见类型都是结构体
    
    ```
    ① struct Date {
    ② var year: Int
    ③ var month: Int
    ④ var day: Int
    ⑤ }
    ⑥ var date = Date(year: 2019, month: 6, day: 23)
    ```
2. 所有的结构体都有一个**编译器**自动生成的初始化器（initializer，初始化方法、构造器、构造方法）
    1. 在第⑥行调用的，可以传入所有成员值，用以初始化所有成员（存储属性，Stored Property）

### 结构体的初始化器
1. 编译器会根据情况，可能会为结构体生成多个初始化器，宗旨是：保证所有成员都有初始值
    
    ```
    struct Point {
    var x: Int
    var y: Int
    }
    var p1 = Point(x: 10, y: 10)
    //以下都错误
    //var p2 = Point(y: 10)
    //var p3 = Point(x: 10)
    //var p4 = Point()
    
    struct Point {
    var x: Int = 0
    var y: Int
    }
    var p1 = Point(x: 10, y: 10)
    var p2 = Point(y: 10)
    //以下都错误
    //var p3 = Point(x: 10)
    //var p4 = Point()
    
    
    struct Point {
    var x: Int = 0
    var y: Int = 0
    }
    //以下都正确
    var p1 = Point(x: 10, y: 10)
    var p2 = Point(y: 10)
    var p3 = Point(x: 10)
    var p4 = Point()
    
    //可选项都有个默认值nil,因此可以编译通过
    struct Point {
    var x: Int?
    var y: Int?
    }
    //都正确
    var p1 = Point(x: 10, y: 10)
    var p2 = Point(y: 10)
    var p3 = Point(x: 10)
    var p4 = Point()
    ```

### 自定义初始化器
1. 一旦在定义结构体时自定义了初始化器，编译器就不会再帮它自动生成其他初始化器
    
    ```
    //可选项都有个默认值nil,因此可以编译通过
    struct Point {
        var x: Int = 0
        var y: Int = 0
        //自定义初始化器
        init(x : Int,y : Int){
            self.x = x
            self.y = y
        }
    }
    
    var p1 = Point(x: 10, y: 10)
    //以下都错误
    var p2 = Point(y: 10)
    var p3 = Point(x: 10)
    var p4 = Point()
    ```

### 结构体内存结构

```
struct Point {
    var x: Int = 0
    var y: Int = 0
    var origin: Bool = false
}
//Int占8个字节，Bool占1个字节
print(MemoryLayout<Point>.size) // 17
//内存对齐，8+8+8
print(MemoryLayout<Point>.stride) // 24
print(MemoryLayout<Point>.alignment) // 8
```

## 类

    
    

### 类的初始化器
1. 类的定义和结构体类似，但编译器并没有为类自动生成可以传入成员值的初始化器
2. 如果类的所有成员都在定义的时候指定了初始值，编译器会为类生成无参的初始化器

    ```
     class Point {
        var x: Int 
        var y: Int 
    }
    //报错
    //let p1 = Point()
    
    
    class Point {
        var x: Int = 0
        var y: Int = 0
    }
    let p1 = Point()
    //以下都报错
    //let p2 = Point(x: 10, y: 20)
    //let p3 = Point(x: 10)
    //let p4 = Point(y: 20)
    ```
    
### 结构体与类的本质区别
1. 示例
    
    ```
    class Size {
        var width = 1
        var height = 2
    }
    
    struct Point {
        var x = 3
        var y = 4
    }
    
    func test() {
    var size = Size()
    var point = Point()
    }
    ```
2. 内存分布如下
    
    ![1.png](https://gitee.com/zhonghua123/blogimgs/raw/master/img/swift4.png/)
    
    1. 结构体对象point、指着变量size都放在栈空间，类对象放在堆空间。

### 值类型
1. 值类型赋值给var、let或者给函数传参，是直接将所有内容拷贝一份
2. 类似于对文件进行copy、paste操作，产生了全新的文件副本。属于深拷贝（deep copy）
    
    ```
    struct Point {
        var x: Int
        var y: Int
    }
    
    func test() {
        var p1 = Point(x: 10, y: 20)
        //深拷贝
        var p2 = p1
        
        p2.x = 11
        p2.y = 22
        //p1.x为10，p1.y为20
    }
    ```

#### 值类型赋值操作
1. 举例
    
    ```
    //String是结构体
    var s1 = "Jack"
    var s2 = s1
    s2.append("_Rose")
    print(s1) // Jack
    print(s2) // Jack_Rose
    
    //数组是结构体
    var a1 = [1, 2, 3]
    var a2 = a1
    a2.append(4)
    a1[0] = 2
    print(a1) // [2, 2, 3]
    print(a2) // [1, 2, 3, 4]
    
    //字典值结构体
    var d1 = ["max" : 10, "min" : 2]
    var d2 = d1
    d1["other"] = 7
    d2["max"] = 12
    print(d1) // ["other": 7, "max": 10, "min": 2]
    print(d2) // ["max": 12, "min": 2]
    ```
2. 在Swift**标准库**中，为了提升性能，String、Array、Dictionary、Set采取了Copy On Write的技术
    1. 必须是标准库定义的结构体，自定义的不会有
    2. 即只有s1或者s2真正改变的时候，才会进行深拷贝，即比如仅当有“写”操作时，才会真正执行拷贝操作
    3. 对于标准库值类型的赋值操作，Swift 能确保最佳性能，所有没必要为了保证最佳性能来避免赋值
3. 建议：不需要修改的，尽量定义成let
4. 举例
    
    ```
    struct Point {
        var x: Int
        var y: Int
    }
    var p1 = Point(x: 10, y: 20)
    //注意：此时并没有重新分配内存，是直接修改原来p1内存中的值
    p1 = Point(x: 11, y: 22)
    ```

### 引用类型
1. 引用赋值给var、let或者给**函数传参**，是将内存地址拷贝一份
2. 类似于制作一个文件的替身（快捷方式、链接），指向的是同一个文件。属于浅拷贝（shallow copy）
    
    ```
    class Size {
        var width: Int
        var height: Int
        init(width: Int, height: Int) {
            self.width = width
            self.height = height
        }
    }

    func test() {
    var s1 = Size(width: 10, height: 20)
    var s2 = s1
    }

    s2.width = 11
    s2.height = 22
    // 请问s1.width和s1.height是11,22
    ```

#### 引用类型的赋值操作

```
class Size {
    var width: Int
    var height: Int
    init(width: Int, height: Int) {
        self.width = width
        self.height = height
    }
}
var s1 = Size(width: 10, height: 20)
//堆中重新分配了一个对象内存，然后把这个对象的地址覆盖栈中的s1中，同时因为旧对象没有被引用，会被释放。
s1 = Size(width: 11, height: 22)
```

### 值类型、引用类型的let
1. 示例
    
    ```
    struct Point {
        var x: Int
        var y: Int
    }
    class Size {
        var width: Int
        var height: Int
        init(width: Int, height: Int) {
            self.width = width
            self.height = height
        }
    }
    
    //p是结构体本身，放在了栈空间，let代表的是栈空间存储的结构体内存不能修改，因此结构体、里面的成员都不能修改。
    let p = Point(x:10,y:20)
    //以下都报错，常量不允许修改
    //p = Point(x:11,y:21)
    //p.x = 44
    //p.y = 55
    
    //s是对象指针，放在了栈空间，let代表的是栈空间存储的对象指针内存不能修改，但是实际对象放在了堆区，因此堆区存储的内容可以修改。
    let s = Size(width:10,height:20)
    //报错，修改了栈区对象指针的地址
    //s = Size(width:11,height:22)
    //不报错
    s.width = 33
    s.height = 44
    
    //String为结构体类型
    let str = "Jack"
    //以下都报错
    //str.append("_Rose")
    
    let arr = [1,2,3]
    //以下都报错
    //arr[0] = 11
    //arr.append(4)
    ```
    
### 嵌套类型

```
struct Poker {
    enum Suit : Character {
        case spades = "♠"
        , hearts = "♥"
        , diamonds = "♦"
        , clubs = "♣"
    }
    enum Rank : Int {
        case two = 2, three, four, five, six, seven, eight, nine, ten
        case jack, queen, king, ace
    }
}


print(Poker.Suit.hearts.rawValue)
var suit = Poker.Suit.spades
suit = .diamonds
var rank = Poker.Rank.five
rank = .king
```

### 枚举、结构体、类都可以定义方法
1. 一般把定义在枚举、结构体、类内部的函数，叫做方法
2. 方法占用对象的内存么？不占用,方法的本质就是函数,方法、函数都存放在代码段

```
class Size {
    var width = 10
    var height = 10
    func show() {
        print("width=\(width), height=\(height)")
    }
}
let s = Size()
s.show() // width=10, height=10

struct Point {
    var x = 10
    var y = 10
    func show() {
        print("x=\(x), y=\(y)")
    }
}
let p = Point()
p.show() // x=10, y=10

enum PokerFace : Character {
    case spades = "♠", hearts = "♥", diamonds = "♦", clubs = "♣"
    func show() {
        print("face is \(rawValue)")
    }
}
let pf = PokerFace.hearts
pf.show() // face is ♥
```


