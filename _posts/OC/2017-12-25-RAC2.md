---
layout: post
title: RAC系列2之 基础篇
category: iOS开发
tags: RAC
description: 链式/函数式/响应式编程
---
> **注:** RAC这一些列文章主要参考了小码哥[袁峥](http://www.jianshu.com/p/87ef6720a096)和[雷纯峰](http://blog.leichunfeng.com/blog/2016/02/27/mvvm-with-reactivecocoa/)这两位大佬的博客

## RAC简介
1. ReactiveCocoa（简称为RAC）,是由Github开源的一个应用于iOS和OS开发的新框架,Cocoa是苹果整套框架的简称，因此很多苹果框架喜欢以Cocoa结尾。
2. ReactiveCocoa作用
    1. ReactiveCocoa为事件提供了很多处理方法，而且利用RAC处理事件很方便，可以把要处理的事情，和监听的事情的代码放在一起，这样非常方便我们管理，就不需要跳到对应的方法里。非常符合我们开发中高聚合，低耦合的思想。
    
## ReactiveCocoa编程思想
1. ReactiveCocoa结合了几种编程风格：
    1. 函数式编程（Functional Programming）
    2. 响应式编程（Reactive Programming）
2. ReactiveCocoa被描述为函数响应式编程（FRP）框架。
3. 使用RAC解决问题，就不需要考虑调用顺序，直接考虑结果，把每一次操作都写成一系列嵌套的方法中，使代码高聚合，方便管理。

## 导入ReactiveCocoa框架
1. 之前GitHub上面的该框架是用ReactiveCocoa导入,但是现在该框架是swift版本的了,要想使用OC版本的就是ReactiveObjC了
2. 导入:
    1. `vim podfile`->`键盘输入i`,然后编辑: 

        ```
        source 'https://github.com/CocoaPods/Specs.git'
        platform :ios, '8.0'
        target 'RAC的学习'do
        use_frameworks!
        pod'ReactiveObjC'
        end
        ```
    2. esc->:wq->pod install
    
## RAC常见的类
1. RAC中:万物皆信号，任何事件通过信号传递
2. 信号源:信号源代表的是随着时间而改变的值流,订阅者可以通过订阅信号源来获取这些值;
3. 你可以把它想象成水龙头中的水，当你打开水龙头时，水源源不断地流出来；你也可以把它想象成电，当你插上插头时，电静静地充到你的手机上;这里的水、电就是我们所需要的值，而打开水龙头、插上插头就是订阅它们的过程。

### RACSiganl
1. 信号类,一般表示将来有数据传递，只要有数据改变，信号内部接收到数据，就会马上发出数据。
2. 信号类(RACSiganl)，只是表示当数据改变时，信号内部会发出数据，它本身不具备发送信号的能力，而是交给内部一个订阅者去发出。
3. 默认一个信号都是冷信号，也就是值改变了，也不会触发，只有订阅了这个信号，这个信号才会变为热信号，值改变了才会触发。
4. 如何订阅信号：调用信号RACSignal的subscribeNext就能订阅。
5. 简单使用
    
    ```javascript
     //1.创建信号
    RACSignal *signal  = [RACSignal createSignal:^RACDisposable * _Nullable(id<RACSubscriber>  _Nonnull subscriber) {
        //didSubscribe:当前block
        // block调用时刻：每当有订阅者订阅信号，就会调用block。
        // didSubscribe作用: 发送数据
        // 3.发送信号
        [subscriber sendNext:@1];
        // 如果不在发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。
        [subscriber sendCompleted];
        
        return [RACDisposable disposableWithBlock:^{
            //block调用时刻：当信号发送完成或者发送错误，就会自动执行这个block,取消订阅信号
            // 执行完Block后，当前信号就不在被订阅了。
            
            NSLog(@"信号被销毁");
        }];
    }];
    //2. 订阅信号,才会激活信号(相当于响应式编程中的监听)
    [signal subscribeNext:^(id  _Nullable x) {
        //nextBlock:当前block
        // block调用时刻：每当有信号发出数据，就会调用block.
        //nextBlock作用: 处理数据展示到UI上面
        //x:信号发送内容
        NSLog(@"接收到数据:%@",x);
    } error:^(NSError * _Nullable error) {
         NSLog(@"订阅信号发生错误");
    } completed:^{
        NSLog(@"订阅完成");
    }];
    ```
6. RACSignal底层实现：
    1. 创建信号(`RACSignal`的子类`RACDynamicSignal`对象)，首先把`didSubscribe`保存到信号(RACDynamicSignal对象)中，还不会触发。
    2. 当信号被订阅，也就是调用`signal的subscribeNext:nextBlock`内部做以下事情:
        1. 创建订阅者`subscriber`，并且把`nextBlock`保存到`subscriber`中。
        2. 调用`siganl`的`didSubscribe`block。
    3. `siganl`的`didSubscribe`中调用`[subscriber sendNext:@1];`
    4. `sendNext`底层其实就是执行`subscriber`的`nextBlock`

### RACSubscriber
1. 表示订阅者的意思，用于发送信号，这是一个协议，不是一个类，只要遵守这个协议，并且实现方法才能成为订阅者
2. 通过create创建的信号，都有一个订阅者，帮助他发送数据。

### RACDisposable
1. 用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。
2. 使用场景:不想监听某个信号时，可以通过它主动取消订阅信号。
3. 举例使用

    ```javascript
     #import "ViewController.h"
    #import <ReactiveObjC/ReactiveObjC.h>
    @interface ViewController ()
    
    @property (nonatomic, strong) id<RACSubscriber> subscriber;
    @end
    
    @implementation ViewController
    
    - (void)viewDidLoad {
        [super viewDidLoad];
        // 1.创建信号
        RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber ) {
            
            _subscriber = subscriber;
            
            // 3.发送信号
            [subscriber sendNext:@"123"];
            
            return [RACDisposable disposableWithBlock:^{
                // 只要信号取消订阅就会来这
                // 清空资源
                NSLog(@"信号被取消订阅了");
            }];
        }];
        
        // 2.订阅信号
        RACDisposable *disposable = [signal subscribeNext:^(id x) {
            
            NSLog(@"%@",x);
            
        }];
    
        // 默认一个信号发送数据完毕就会自动取消订阅.
        // 但是只要订阅者在,就不会自动取消信号订阅(用属性强引用着订阅者,就不会自动取消订阅了)
        // 那么我们就需要(主动取消)取消订阅信号
        [disposable dispose];
        }
    
    ```

### RACSubject与RACReplaySubject

#### RACSubject
1. 信号提供者，自己可以充当信号，又能发送信号。
    
        ```
        @interface RACSubject<ValueType> : RACSignal<ValueType> <RACSubscriber>

        /// Returns a new subject.
        + (instancetype)subject;
        
        // Redeclaration of the RACSubscriber method. Made in order to specify a generic type.
        - (void)sendNext:(nullable ValueType)value;
        
         @end
        ```
2. 使用场景:
    1. 通常用来代替代理，有了它，就不必要定义代理了。
3. 基本使用步骤:
    1. 创建信号` [RACSubject subject]`，跟`RACSiganl`不一样，创建信号时没有`block`。
    2. 订阅信号 `- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock`  
    3. 发送信号` sendNext:(id)value  `
4. 代码举例:

    ```
     //1.创建信号(此时代表信号)
    RACSubject *subject = [RACSubject subject];
    //2.订阅信号
    //RACSubject处理订阅:仅仅是保存订阅者
    [subject subscribeNext:^(id  _Nullable x) {
        NSLog(@"订阅者第一次接收到数据:%@",x);
    }];
    [subject subscribeNext:^(id  _Nullable x) {
        NSLog(@"订阅者第二次接收到数据:%@",x);
    }];
    //3. 发送数据(信号)(此时代表订阅者)
    //底层实现:遍历所有的订阅者,调用nextBlock
    [subject sendNext:@"1"];
    ```
5. 底层实现:(底层实现和RACSignal不一样)
    1. `[RACSubject subject]:`
        1. 内部会创建一个可变数组赋值给属性
    2. 调用`subscribeNext`订阅信号:
        1. 创建订阅者,把`nextblock`赋值给订阅者属性
        2. 将该订阅者保存到属性数组中
    3. 调用`sendNext`发送信号:
        1. 遍历数组属性,拿到所有的订阅者,一个一个调用订阅者的`nextBlock`。
    
    
#### RACReplaySubject
1. 重复提供信号类，`RACSubject`的子类。
2. `RACReplaySubject`使用场景
    1. 如果一个信号每被订阅一次，就需要把之前的值重复发送一遍，使用重复提供信号类
    2. 可以设置`capacity`数量来限制缓存的value的数量,即只缓充最新的几个值。 
3. `RACReplaySubject`与`RACSubject`区别:
    1. RACReplaySubject可以先发送信号，再订阅信号，RACSubject就不可以。


