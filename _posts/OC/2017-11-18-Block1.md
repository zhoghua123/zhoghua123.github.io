---
layout: post
title: 我理解的Block
category: Objective-C
tags: Block
description: Block的原理
---
## 块Block
>   这项语言特性是作为"扩展"(extension)而加入GCC编译器中的,在近期版本的Clang中都可以使用.10.4版及以后的Mac OX X系统,与4.0版及及其后的iOS系统中,都含有正常执行块所需要的组件.从技术上将,这是个位于C语言层面的特性,因此只要有支持此特性的编译器,以及能执行块的运行期组件,就可以在C/C++/Objective-C/Objective-C++代码中使用它.

  ---摘自<<编写高质量代码的52个有效方法>>
  
* GCC/clang 都是开发Mac OX X与iOS程序所用的编译器
* GCC:XCode4,Mac OX X 10.4之前,用的是gcc编译器 
* clang:XCode4开始用的是LLVM编译器(该编译器前端用的是clang编译器,编译器分前端跟后端,前端就是用来翻译的),Mac OX X 10.4之后

## OC中的Block定义

[LLVM Block_private.h](https://llvm.org/svn/llvm-project/compiler-rt/tags/Apple/Libcompiler_rt-10/BlocksRuntime/Block_private.h)可以找到苹果关于block的相关定义。
仅仅看一些关键代码如下:

```javascript
    /* Revised new layout. */
    struct Block_descriptor {
        unsigned long int reserved;
        unsigned long int size;
        void (*copy)(void *dst, void *src);
        void (*dispose)(void *);
    };  
    struct Block_layout {
        void *isa;
        int flags;
        int reserved;
        void (*invoke)(void *, ...);
        struct Block_descriptor *descriptor;
        /* Imported variables. */
    };
``` 

看到这里我们心里先有一个概念,Block一定跟结构体相关,这个结构体有函数指针 invoke 和copy,其他的成员变量,貌似都是一些标记而已,下面我们把结构体,转化成C++具体分析

## 如何通过clang编译器将OC代码转化成C++代码?
> 终端使用cd定位到main.m文件所在文件夹,然后利用clang -rewrite-objc main.m将OC转为C++,成功后在main.m同目录下会生成一个main.cpp文件

## OC代码如下:
```javascript
#import <Foundation/Foundation.h>

int global_i = 1;

static int static_global_j = 2;

int main(int argc, const char * argv[]) {
    
    static int static_k = 3;
    int val = 4;
    
    void (^myBlock)(void) = ^{
        global_i ++;
        static_global_j ++;
        static_k ++;
        //如果加了这一句,会报错:变量val应该加上__block,先不分析__block
        // val ++;
        NSLog(@"Block中 global_i = %d,static_global_j = %d,static_k = %d,val = %d",global_i,static_global_j,static_k,val);
    };
    
    global_i ++;
    static_global_j ++;
    static_k ++;
    val ++;
    NSLog(@"Block外 global_i = %d,static_global_j = %d,static_k = %d,val = %d",global_i,static_global_j,static_k,val);
    
    myBlock();
    
    return 0;
}
```
## 用编译器转化成C++如下:
> 这里只截取了主要的代码

```c
// 提前定义的类型

typedef long unsigned int __darwin_size_t;
typedef __darwin_size_t size_t;

//结构体类型:__block_impl
//可以看出，它包含了isa指针（包含isa指针的皆为对象），也就是说block也是一个对象(runtime里面，对象和类都是用结构体表示)。
struct __block_impl {
    //指向所属类的指针，也就是block的类型
    void *isa;
    //标志变量，在实现block的内部操作时会用到
    int Flags;
    //保留变量
    int Reserved;
    //block执行时调用的函数指针
    void *FuncPtr;
};

//全局变量
int global_i = 1;
//静态全局变量
static int static_global_j = 2;

//结构体__main_block_impl_0
struct __main_block_impl_0 {
    //结构体成员
    struct __block_impl impl;
    //结构体成员
    struct __main_block_desc_0* Desc;
    //静态局部变量
    int *static_k;
    //局部变量
    int val;
    //构造函数-下面有具体解释(分析1)
    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_static_k, int _val, int flags=0) : static_k(_static_k), val(_val) {
        //__main_block_impl_0的isa指针指向了_NSConcreteStackBlock,说明了这个block的类型
        impl.isa = &_NSConcreteStackBlock;
        //
        impl.Flags = flags;
        //从main函数中调用来看,FuncPtr指向了函数__main_block_func_0
        impl.FuncPtr = fp;
        //_Desc也指向了定义__main_block_desc_0时就创建的__main_block_desc_0_DATA，其中纪录了block结构体大小等信息。
        Desc = desc;
    }
};
//静态函数__main_block_func_0 static作用:只能被本文件调用
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
    
    //从结构体__main_block_impl_0中拿到成员变量static_k
    int *static_k = __cself->static_k; // bound by copy
    //从结构体中拿到成员变量val
    int val = __cself->val; // bound by copy
    //全局变量与静态全局变量
    global_i ++;
    static_global_j ++;
    //静态局部变量
    (*static_k) ++;
    //打印
    NSLog((NSString *)&__NSConstantStringImpl__var_folders_g__2b0bh4bx0p13dn6mxjdd8sq00000gn_T_main_816a59_mi_0,global_i,static_global_j,(*static_k),val);
}
//静态结构体__main_block_desc_0  static作用:只能被本文件调用
static struct __main_block_desc_0 {
    //size_t 长无符号整型
    //成员变量
    //reserved：保留字段
    size_t reserved;
    //block大小(sizeof(struct __main_block_impl_0))
    size_t Block_size;
    //直接初始化一个该类型的结构体变量 __main_block_desc_0_DATA
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};

//主函数
int main(int argc, const char * argv[]) {
    //初始化静态变量
    static int static_k = 3;
    //初始化局部变量
    int val = 4;
    //初始化一个函数指针(这是啥玩意,下面有分析2)变量(实质是一个结构体指针变量)
    void (*myBlock)(void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, &static_k, val));
    //操作
    global_i ++;
    static_global_j ++;
    static_k ++;
    val ++;
    //打印
    NSLog((NSString *)&__NSConstantStringImpl__var_folders_g__2b0bh4bx0p13dn6mxjdd8sq00000gn_T_main_816a59_mi_1,global_i,static_global_j,static_k,val);
    //函数的调用(下面分析3)
    // __main_block_func_0 (myBlock);
    ((void (*)(__block_impl *))((__block_impl *)myBlock)->FuncPtr)((__block_impl *)myBlock);
    
    return 0;
}
```

1. 分析1:
```c
     __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_static_k, int _val, int flags=0) : static_k(_static_k), val(_val);
     这是啥?->构造函数,显式的构造函数,swift中有
     作用:以函数的形式,快速的创建一个结构体变量,并初始化,可以初始化这个结构体的每个成员变量,甚至成员变量的每个值
     函数名通常与该结构体相同
     __main_block_impl_0(参数1,参数2,参数3,...){
     结构体成员变量1 = 参数1;
     结构体成员变量2 = 参数2;
     ....
     }
     ": static_k(_static_k), val(_val)"
     也可以省略不写,但是要在{}中加上
     static_k = _static_k;
     val = _val;
```
 
2. 分析2:

    ```c
    void (*myBlock)(void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, &static_k, val));
     
     1. OC中void (^myBlock)(void) <=> void (*myBlock)(void)
     void (*myBlock)(void)这可是一个函数指针:指向一个返回值为void,参数为void的函数
     2. 那么OC中的^{...};对应C++中的什么呢?
     ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, &static_k, val));
     对应这个,那他又是啥玩意呢?
     如何拿到一个函数的地址?--->函数名就是函数的地址
     2.1 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_static_k, int _val, int flags=0): static_k(_static_k), val(_val),是一个结构体构造函数,可用于快速创建一个__main_block_impl_0类型的结构体
     2.2 (void *)__main_block_func_0 =>函数地址,对应参数fp ,(void *)仅仅是一个类型转化的作用,直接写成__main_block_func_0就可以,函数名就是函数的地址,这个函数本来就是void类型的
     2.3 &__main_block_desc_0_DATA 对应desc,__main_block_desc_0类型的结构体地址,已经初始化过了
     2.4 &static_k 静态局部变量的指针
     2.5 val局部变量
     2.6 因此:
        __main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, &static_k, val)):就是创建了一个__main_block_impl_0类型的结构体
       &:取出这个结构体的地址
       ((void (*)()):是一个强制转换,将这个结构体地址(指针)用一个函数指针引用着
     3. 总结:由此可见,block实质上是一个机构体指针,只是用了一个函数指针引用着
     */
```
3. 分析3:

```c
     ((void (*)(__block_impl *))((__block_impl *)myBlock)->FuncPtr)((__block_impl *)myBlock);
     
     1. void (*)(__block_impl *):函数指针,指向一个函数返回值为void 参数为__block_impl *的类型
     化简后 =>((函数指针类型)((__block_impl *)myBlock)->FuncPtr)((__block_impl *)myBlock);
     2.((__block_impl *)myBlock)->FuncPtr
        2.1 (__block_impl *)myBlock : 拿到上面那个定义的函数指针(实质是__main_block_impl_0类型的结构体指针),再强制转化成__block_impl *指针类型
        2.2 ->FuncPtr: 根据这个结构体指针拿到这个结构体的成员变量
        2.3 由此也说明,强制转换成__block_impl *类型就是为了好拿到FuncPtr这个成员变量
        2.4 FuncPtr是一个函数指针指向了__main_block_func_0
         2.5 简化后=>((函数指针类型)__main_block_func_0)((__block_impl *)myBlock);
     3.(__block_impl *)myBlock前面说了实质就是一个__main_block_impl_0结构体指针,尽管把他强制转化成了__block_impl * 类型,也由此可以看到,实际上符合static void __main_block_func_0(struct __main_block_impl_0 *__cself);这个函数的参数类型
     4. 最终转化成=>:((函数指针类型)__main_block_func_0)(参数);
     5. 绕来绕去最终的结果就是:__main_block_func_0(myBlock);=>函数的调用
     6. 至于为何非要把__main_block_impl_0结构体指针转化成(__block_impl *)myBlock类型的结构体指针,那就不知道了
```
## 总结
 1. 结构体的声明:`(^myBlock)(void)` =>实质上是一个函数指针的声明:`void (*myBlock)(void)`,但注意这个函数指针实质上是指向了一个结构体指针
 2. 结构体的实现:`^{...};` =>实质上是创建一个结构体`__main_block_impl_0`,然后拿到他的指针,即取址
 3. 结构体的调用:`myBlock();` =>实质上是根据`&__main_block_impl_0`结构体指针拿到(->)他的成员变量`FuncPtr:__main_block_func_0`函数,然后调用这个函数
 4. 为什么要用结构体指针内嵌一个函数,而不直接使用函数指针呢?   
    我的猜想是这样的:
   * 函数的内存是临时分配,临时销毁,每掉一次都会重新分配,从新拿取实参的值
   * 结构体指针是,只要这个结构体没有被销毁(即一直被引用着),那么这个结构体中的内存一直是原来的,而且不必从新从外界获取实参,可以起到零时存储的作用
5. 综上所述:block实质上是一个机构体指针,只是用了一个函数指针引用着
  
  > 这也许是为什么要把一个函数放到一个结构体变量中存储,然后再通过结构体拿到这个函数调用的原理吧! 


