---
layout: post
title: RAC系列3之 常见的操作方法
category: iOS开发
tags: RAC
description: RAC
---

> **注:** RAC这一些列文章主要参考了小码哥[袁峥](http://www.jianshu.com/p/87ef6720a096)和[雷纯峰](http://blog.leichunfeng.com/blog/2016/02/27/mvvm-with-reactivecocoa/)这两位大佬的博客

## ReactiveCocoa常见操作方法

1. 操作方法:
    1. 所谓的操作方法:就是讲讲`RACStream.h`文件中声明的一些常用方法
    2. 因为所有信号(RACSignal)都最终继承自RACStream这个类,因此这个类中的方法,所有信号都有.
2. ReactiveCocoa操作思想
    1. 运用的是Hook（钩子）思想，Hook是一种用于改变API(应用程序编程接口：方法)执行结果的技术.
    2. Hook用处：截获API调用的技术。
    3. Hook原理：在每次调用一个API返回结果之前，先执行你自己的方法，改变结果的输出。即:在返回结果之前,拦截你的内容,然后返回新的结果
    4. 如图:
        ![hook思想](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hook.png)
3. 如何体现的hook思想呢?就在下面这些操作方法中体现

### ReactiveCocoa核心操作方法之`bind `     
1. ReactiveCocoa操作的核心方法是bind（**绑定**）,而且RAC中核心开发方式，也是绑定，之前的开发方式是**赋值**，而用RAC开发，应该把重心放在绑定，也就是可以在创建一个对象的时候，就绑定好以后想要做的事情，而不是等赋值之后在去做事情。
2. 列如：把数据展示到控件上，之前都是重写控件的setModel方法，用RAC就可以在一开始创建控件的时候，就绑定好数据。
3. bind(绑定),结合RAC中的信号进行绑定,只要信号已发送数据,就能监听到,从而把发送的数据改成字节想要的数据
4. 在开发中很少使用bind方法，bind属于RAC中的底层方法，RAC已经封装了很多好用的其他方法，底层都是调用bind，用法比bind简单.
5. bind方法分析:    
    `- (__kindof RACStream *)bind:(RACStreamBindBlock (^)(void))block;`
    1. 参数:`block`(参数`block`返回值也是一个`block`(`RACStreamBindBlock`))
        1. 参数: 无
        2. 返回值:RACStreamBindBlock
    2. 返回值:`RACSignal`(处理后的信号)
    3. RACStreamBindBlock:
        1. 定义:
            1. `typedef RACSequence * _Nullable (^RACSequenceBindBlock)(ValueType _Nullable value, BOOL *stop);`
        2. 参数:value,stop
            1. `value`:表示接收到信号的原始值，还没做处理
            2. `*stop`:用来控制绑定Block，如果`*stop = yes`,那么就会结束绑定。
        3. 返回值:`RACSignal`(信号)，做好处理，在通过这个信号返回出去，一般使用`RACReturnSignal`,需要手动导入头文件`RACReturnSignal.h`。
6. 注意:
    1. 不同订阅者，保存不同的nextBlock，看源码的时候，一定要看清楚订阅者是哪个。
    2. 这里需要手动导入`#import <ReactiveCocoa/RACReturnSignal.h>`，才能使用`RACReturnSignal`。
7. bind方法使用步骤:
    1. 传入一个返回值`RACStreamBindBlock`的`block`。
    2. 描述一个`RACStreamBindBlock`类型的`bindBlock`作为`block`的返回值。
    3. 描述一个返回结果的信号，作为`bindBlock`的返回值。
    4. 在`bindBlock`中做信号结果的处理。
8. 代码举例1        
    需求: 假设想监听文本框的内容，并且在每次输出结果的时候，都在文本框的内容拼接一段文字“输出：”
    
    ```javascript
    -(void)viewDidLoad{
    UITextField *textField = [[UITextField alloc] initWithFrame:CGRectMake(100, 100, 200, 30)];
    textField.backgroundColor = [UIColor redColor];
    [self.view addSubview:textField];
    UILabel *label = [[UILabel alloc] init];
    label.frame = CGRectMake(100, 300, 200, 30);
    [self.view addSubview: label];
    
    //方法1:
    [textField.rac_textSignal subscribeNext:^(NSString * _Nullable x) {
        NSLog(@"输出:%@",x);
    }];
    // 方式二:在返回结果前，拼接，使用RAC中bind方法做处理。
    //1.绑定信号
    RACSignal *bindSignal = [textField.rac_textSignal bind:^RACSignalBindBlock _Nonnull{
        //当前block的调用时刻:绑定的信号(textField.rac_textSignal)被订阅时调用
        // block作用:表示绑定了一个信号.
        return ^RACSignal *(id value, BOOL *stop){
            // 什么时候调用block:只要源信号(textField.rac_textSignal)发送数据，就会来到这个block。
            // block作用:处理源信号的内容
            //value:源信号发送的内容
            // 做好处理，通过信号返回出去.
            value = [NSString stringWithFormat:@"输出:%@",value];
            //返回信号不能传nil,可以返回空信号[RACSignal empty];
            // return nil;
            //包装信号返回出去
            return [RACReturnSignal return:value];
        };
    }];
    //2.订阅绑定信号
    [bindSignal subscribeNext:^(id  _Nullable x) {
        //block调用时刻:当处理完信号发送数据的时候,就回调用这个block
         NSLog(@"%@",x);
    }];
    }
    ```
9. 代码举例2:
    
    ```javascript
    - (void)test {
    //1.创建信号
    RACSubject *sourceSignal = [RACSubject subject];
    //2. 绑定信号
    RACSignal *bindSignal = [sourceSignal bind:^RACSignalBindBlock _Nonnull{
        
        return ^RACSignal *(id value, BOOL *stop){
            
            value = [NSString stringWithFormat:@"在这里处理源信号:%@",value];
            
            return [RACReturnSignal return:value];
        };
    }];
    //3.订阅绑定信号
    [bindSignal subscribeNext:^(id  _Nullable x) {
        NSLog(@"%@",x);
    }];
    //4. 发送数据
    [sourceSignal sendNext:@"123"];
    }
    ```
10. 这两个例子体现的hook思想:
    1. 任意一个信号,只要被绑定(bind),一旦发出数据信号,我们就能拿到这个信号进行处理,然后返回处理完的信号,当订阅拿到这个信号时,已经是改变后的信号
11. 底层实现
    1. `bind:`方法内部简析:
        
        ```
         方法简化如下:
         - (RACSignal *)bind:(RACSignalBindBlock (^)(void))block {
 
        //定义addSignal一个block
         void (^addSignal)(RACSignal *) = ^(RACSignal *signal) {
 
        //7. 订阅returnsignal
          //这个signal是RACReturnSignal,调用subscribeNext:
            //7.1. 内部会创建一个订阅者subscriber,保存nextblock
            //7.2. 调用RACReturnSignal类的 :[self subscribe:o]
            //7.3. 注意:是RACReturnSignal类的!!!,该方法内部会主动使用该订阅者发送信号,调用外部的nextblock
            /* - (RACDisposable *)subscribe:(id<RACSubscriber>)subscriber {
             return [RACScheduler.subscriptionScheduler schedule:^{
             [subscriber sendNext:self.value];
             [subscriber sendCompleted];
             }];
             }*/
 
        RACDisposable *disposable = [signal subscribeNext:^(id x) {
 
        //8. 发送信号bindsignal,将处理数据传出去
        //9. 调用外部bindsignal的nextblock
        //这个subscriber是bindsignal的订阅者
 
        [subscriber sendNext:x];
 
             } error:^(NSError *error) {
             } completed:^{
             }];
            };
 
           // 1.创建bindsignal
            return [[RACSignal createSignal:^(id<RACSubscriber> subscriber) {
 
            //2.调用外部传进的block,返回RACSignalBindBlock
            RACSignalBindBlock bindingBlock = block();
 
            //3.内部订阅源信号
            RACDisposable *bindingDisposable = [self subscribeNext:^(id x) {
 
                    //4. 外部源信号发送数据,来到这里
                    // 5. 调用外部的bindingBlock,获得(处理后的信号)returnsignal
                    BOOL stop = NO;
                    id signal = bindingBlock(x, &stop);
 
                    //6.调用自定义的addSignalblock
                    if (signal != nil) addSignal(signal);
 
                    } error:^(NSError *error) {
                    } completed:^{
                }];
            }
            return compoundDisposable;
            }]];
        }
        ```
    2. 结论
        1. 源信号调用`bind`,会返回重新创建(`create`)的一个绑定信号`RACSignal(bindsignal)`。
        2. 当绑定信号(`bindsigna`l)被订阅,就会调用绑定信号中的didSubscribe
            1. 调用`bind:`传入的`block`,返回一个`bindingBlock(RACSignalBindBlock)`。
            2. 内部订阅外部的源信号,`nextBlock`
        3. 当源信号有内容发出(发送信号)，调用`bind`内部的订阅`nextBlock`
            1. 调用`bindingBlock`,外部`block`实现中进行处理,并返回处理后的信号`(RACReturnSignal)signal`
            2. 调用内部定义的`addSignal`这个`block`,将`returnsignal`传入
                1. 订阅`returnsignal`,这个`returnsignal`是`RACReturnSignal`
                    1. 内部会创建一个订阅者`subscriber`,保存`nextblock`
                    2. 调用`RACReturnSignal`类的 :`[self subscribe:o]`
                    3. 注意:是`RACReturnSignal`类的!!!,该方法内部会主动使用该订阅者发送信号,调用外部的`nextblock`
                3. `nextblock`内部调用:`[subscriber sendNext:x];`
                4. 注意:这个subscriber是bindsignal的订阅者
        4. 调用外部订阅`bindSignal`的`nextblock`,拿到改变后的值
      


