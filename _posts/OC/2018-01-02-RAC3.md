---
layout: post
title: RAC系列2之 应用篇
category: iOS开发
tags: RAC
description: RAC
---
> **注:** RAC这一些列文章主要参考了小码哥[袁峥](http://www.jianshu.com/p/87ef6720a096)和[雷纯峰](http://blog.leichunfeng.com/blog/2016/02/27/mvvm-with-reactivecocoa/)这两位大佬的博客

## ReactiveCocoa开发中常见方法
1. `rac_signalForSelector`:
    1. 原理:把调用某个对象的方法转换成信号，只要调用这个方法，就会发送信号。只要提前订阅这个信号就可以监听这个对象的调用了.
    2. 作用: 监听对象的某个方法有没有调用
2. KVO(`rac_valuesForKeyPath`和`rac_valuesAndChangesForKeyPath`) :
    1. 原理: 把监听对象的属性改变转换成信号,只要只改变就发送信号
3. `rac_signalForControlEvents`:
    1. 作用:用于监听某个事件
    2. 原理: 把按钮的的点击事件转换为信号,点击按钮,就回发送信号
4. `rac_addObserverForName`:
    1. 作用:用于监听某个通知。
    2. OC用完观察者之后需要移除观察者,但是RAC不需要管理观察者,内部已经管理好了
5. `rac_textSignal`:
    1. 作用: 监听文本框文字改变
6. `rac_liftSelector:withSignalsFromArray:`:
    1. 作用: 处理当一个界面有多次请求时，需要都获取到数据时，才能展示界面
    1. 当传入的Signals(信号数组)，每一个signal都至少sendNext过一次，就会去触发第一个selector参数的方法。
    2. 使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。
7. 代码举例
    
    ```javascript
    //1. rac_signalForSelector
    //自定义RedView,实现touchBegan方法
    //viewController控制器
    -(void)viewDidLoad{
    RedView *redV = [[RedView alloc] init];
    redV.backgroundColor = [UIColor redColor];
    redV.frame = CGRectMake(50, 50, 100, 100);
    [self.view addSubview:redV];
    
    [[redV rac_signalForSelector:@selector(touchesBegan:withEvent:)] subscribeNext:^(id  _Nullable x) {
        NSLog(@"点击View");
    }];
    }
    
    
    //2. KVO
    -(void)viewDidLoad{
    //KVO
    RedView *redV = [[RedView alloc] init];
    redV.backgroundColor = [UIColor redColor];
    redV.frame = CGRectMake(50, 50, 100, 100);
    [self.view addSubview:redV];
    _redV = redV;

    //把监听redview的frame属性改变转换成信号,只要只改变就发送信号
    //方法1:
    //程序一启动,加载RedView就会改变frame,因此开始就会调用一次
    [[redV rac_valuesForKeyPath:@"frame" observer:self] subscribeNext:^(id  _Nullable x) {
        NSLog(@"--监听属性值---");
    }];
    
    //方法2:
    //程序启动加载redView时不会调用
    [[redV rac_valuesAndChangesForKeyPath:@"frame" options:NSKeyValueObservingOptionNew observer:self] subscribeNext:^(RACTwoTuple<id,NSDictionary *> * _Nullable x) {
        NSLog(@"--监听属性变化---");
    }];
    
    }
    -(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
        self.redV.frame = CGRectMake(100, 100, 200, 200);
    }
    
    //3. 监听事件
    UIButton *btn = [[UIButton alloc] initWithFrame:CGRectMake(100, 100, 50, 50)];
    btn.backgroundColor = [UIColor redColor];
    [self.view addSubview:btn];
    
    //监听事件
    //把按钮的的点击事件转换为信号,点击按钮,就回发送信号
    [[btn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(__kindof UIControl * _Nullable x) {
        NSLog(@"点击了按钮");
    }];
    
    //4. 监听通知
    -(void)viewDidLoad{
    UITextField *textField = [[UITextField alloc] initWithFrame:CGRectMake(100, 100, 200, 30)];
    textField.backgroundColor = [UIColor redColor];
    [self.view addSubview:textField];
    //监听键盘弹出的通知
    //RAC监听
    [[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIKeyboardWillShowNotification object:nil] subscribeNext:^(NSNotification * _Nullable x) {
        NSLog(@"键盘将要弹出了");
    }];
    //OC监听
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(sss:) name:UIKeyboardWillShowNotification object:nil];
    }
    -(void)sss:(id)d{
         NSLog(@"键盘将要sss弹出了");
    }
    
    //5.监听文本框的文字改变
    -(void)viewDidLoad{
    UITextField *textField = [[UITextField alloc] initWithFrame:CGRectMake(100, 100, 200, 30)];
    textField.backgroundColor = [UIColor redColor];
    [self.view addSubview:textField];
    //监听TextField内容改变
    [textField.rac_textSignal subscribeNext:^(NSString * _Nullable x) {
        NSLog(@"=====%@",x);
    }];
    }
    
    //6. 同时获取到数据,刷新UI
    -(void)viewDidLoad{
    //处理当一个界面有多次请求时，需要都获取到数据时，才能展示界面
    //网络请求1
    RACSignal *signal1 = [RACSignal createSignal:^RACDisposable * _Nullable(id<RACSubscriber>  _Nonnull subscriber) {
        NSLog(@"网络请求1") ;
        [subscriber sendNext:@"网络请求1获取到的数据"];
        [subscriber sendCompleted];
        return nil;
    }];
    //网络请求2
    RACSignal *signal2 = [RACSignal createSignal:^RACDisposable * _Nullable(id<RACSubscriber>  _Nonnull subscriber) {
        NSLog(@"网络请求2") ;
        [subscriber sendNext:@"网络请求2获取到的数据"];
        [subscriber sendCompleted];
        return nil;
    }];
    
    //保证两个请求都完成的情况下才能刷新UI
    /*
     数组用于存放信号
     selector:当数组中的信号都发送数据的时候,才会调用
     selector参数个数: 与数组中的信号个数一样
     selector参数类型: 与数组中对应的信号发出的数据一一对应
     */
    [self rac_liftSelector:@selector(obtainData1: andData2:) withSignalsFromArray:@[signal1,signal2]];
    }
    //同时获取到数据,刷新UI
    -(void)obtainData1:(NSString *)data1 andData2: (NSString *)data2{
        NSLog(@"数据1===%@===数据2===%@",data1,data2);
    }
    ```

## ReactiveCocoa常见宏
1. `RAC(TARGET, ...)`
    1. 作用: 用于给某个对象的某个属性绑定。
    2. 代码举例:
        
        ```
        -(void)viewDidLoad{
    UITextField *textField = [[UITextField alloc] initWithFrame:CGRectMake(100, 100, 200, 30)];
        textField.backgroundColor = [UIColor redColor];
        [self.view addSubview:textField];
        UILabel *label = [[UILabel alloc] init];
        label.frame = CGRectMake(100, 300, 200, 30);
        [self.view addSubview: label];
        //方法1:
        [textField.rac_textSignal subscribeNext:^(NSString * _Nullable x) {
            label.text = x;
        }];
        //方法2:
        RAC(label,text) = textField.rac_textSignal;
        
         }
        ```
2. `RACObserve(TARGET, KEYPATH)`:
    1. 作用: 监听某个对象的某个属性,返回的是信号。
    2. 代码举例:
        
        ```
         [RACObserve(self.view, center) subscribeNext:^(id  _Nullable x) {
        NSLog(@"属性改变%@",x);
        }];
        ```
3. `@weakify(Obj)`和`@strongify(Obj)`:
    1. 一般两个都是配套使用
    2. 解决block的循环引用问题
    3. 代码举例:
        
        ```javascript
        #import "TwoViewController.h"
        #import <ReactiveObjC/ReactiveObjC.h>
        @interface TwoViewController ()
        @property (nonatomic,strong)  RACSignal *signal ;
        @end
    
        @implementation TwoViewController
    
        - (void)viewDidLoad {
        [super viewDidLoad];
        self.view.backgroundColor = [UIColor whiteColor];
        @weakify(self);
        RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id<RACSubscriber>  _Nonnull subscriber) {
            @strongify(self);
            NSLog(@"%@",self);
            return nil;
        }];
        self.signal = signal;
        }

        -(void)dealloc{
            NSLog(@"%s",__func__);
        }
        @end
        ```
4. RACTuplePack
    1. 作用:把数据包装成RACTuple（元组类）
    2. 代码:
        
        ```
        // 把参数中的数据包装成元组
        RACTuple *tuple = RACTuplePack(@10,@20);
        ```
5. `RACTupleUnpack` 
    1. 作用: 把RACTuple（元组类）解包成对应的数据。
    2. 代码:
        
        ```
        // 把参数中的数据包装成元组
        RACTuple *tuple = RACTuplePack(@"xmg",@20);
        
        // 解包元组，会把元组的值，按顺序给参数里面的变量赋值
        // name = @"xmg" age = @20
        RACTupleUnpack(NSString *name,NSNumber *age) = tuple;

        ```   
            
## ReactiveCocoa常见操作方法

1. 操作方法:
    1. 所谓的操作方法:就是讲讲`RACStream.h`文件中声明的一些常用方法
    2. 因为所有信号(RACSignal)都最终继承自RACStream这个类,因此这个类中的方法,所有信号都有.
2. ReactiveCocoa操作思想
    1. 运用的是Hook（钩子）思想，Hook是一种用于改变API(应用程序编程接口：方法)执行结果的技术.
    2. Hook用处：截获API调用的技术。
    3. Hook原理：在每次调用一个API返回结果之前，先执行你自己的方法，改变结果的输出。即:在返回结果之前,拦截你的内容,然后返回新的结果
    4. 如图:
        ![hook思想](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/hook.png)
3. 如何体现的hook思想呢?就在下面这些操作方法中体现

### 常见操作方法

#### ReactiveCocoa核心操作方法之`bind `     
1. ReactiveCocoa操作的核心方法是bind（**绑定**）,而且RAC中核心开发方式，也是绑定，之前的开发方式是**赋值**，而用RAC开发，应该把重心放在绑定，也就是可以在创建一个对象的时候，就绑定好以后想要做的事情，而不是等赋值之后在去做事情。
2. 列如：把数据展示到控件上，之前都是重写控件的setModel方法，用RAC就可以在一开始创建控件的时候，就绑定好数据。
3. bind(绑定),结合RAC中的信号进行绑定,只要信号已发送数据,就能监听到,从而把发送的数据改成字节想要的数据
4. 在开发中很少使用bind方法，bind属于RAC中的底层方法，RAC已经封装了很多好用的其他方法，底层都是调用bind，用法比bind简单.
5. bind方法分析:    
    `- (__kindof RACStream *)bind:(RACStreamBindBlock (^)(void))block;`
    1. 参数:`block`(参数`block`返回值也是一个`block`(`RACStreamBindBlock`))
        1. 参数: 无
        2. 返回值:RACStreamBindBlock
    2. 返回值:`RACSignal`(处理后的信号)
    3. RACStreamBindBlock:
        1. 定义:
            1. `typedef RACSequence * _Nullable (^RACSequenceBindBlock)(ValueType _Nullable value, BOOL *stop);`
        2. 参数:value,stop
            1. `value`:表示接收到信号的原始值，还没做处理
            2. `*stop`:用来控制绑定Block，如果`*stop = yes`,那么就会结束绑定。
        3. 返回值:`RACSignal`(信号)，做好处理，在通过这个信号返回出去，一般使用`RACReturnSignal`,需要手动导入头文件`RACReturnSignal.h`。
6. 注意:
    1. 不同订阅者，保存不同的nextBlock，看源码的时候，一定要看清楚订阅者是哪个。
    2. 这里需要手动导入`#import <ReactiveCocoa/RACReturnSignal.h>`，才能使用`RACReturnSignal`。
7. bind方法使用步骤:
    1. 传入一个返回值`RACStreamBindBlock`的`block`。
    2. 描述一个`RACStreamBindBlock`类型的`bindBlock`作为`block`的返回值。
    3. 描述一个返回结果的信号，作为`bindBlock`的返回值。
    4. 在`bindBlock`中做信号结果的处理。
8. 代码举例1        
    需求: 假设想监听文本框的内容，并且在每次输出结果的时候，都在文本框的内容拼接一段文字“输出：”
    
    ```javascript
    -(void)viewDidLoad{
    UITextField *textField = [[UITextField alloc] initWithFrame:CGRectMake(100, 100, 200, 30)];
    textField.backgroundColor = [UIColor redColor];
    [self.view addSubview:textField];
    UILabel *label = [[UILabel alloc] init];
    label.frame = CGRectMake(100, 300, 200, 30);
    [self.view addSubview: label];
    
    //方法1:
    [textField.rac_textSignal subscribeNext:^(NSString * _Nullable x) {
        NSLog(@"输出:%@",x);
    }];
    // 方式二:在返回结果前，拼接，使用RAC中bind方法做处理。
    //1.绑定信号
    RACSignal *bindSignal = [textField.rac_textSignal bind:^RACSignalBindBlock _Nonnull{
        //当前block的调用时刻:绑定的信号(textField.rac_textSignal)被订阅时调用
        // block作用:表示绑定了一个信号.
        return ^RACSignal *(id value, BOOL *stop){
            // 什么时候调用block:只要源信号(textField.rac_textSignal)发送数据，就会来到这个block。
            // block作用:处理源信号的内容
            //value:源信号发送的内容
            // 做好处理，通过信号返回出去.
            value = [NSString stringWithFormat:@"输出:%@",value];
            //返回信号不能传nil,可以返回空信号[RACSignal empty];
            // return nil;
            //包装信号返回出去
            return [RACReturnSignal return:value];
        };
    }];
    //2.订阅绑定信号
    [bindSignal subscribeNext:^(id  _Nullable x) {
        //block调用时刻:当处理完信号发送数据的时候,就回调用这个block
         NSLog(@"%@",x);
    }];
    }
    ```
9. 代码举例2:
    
    ```javascript
    - (void)test {
    //1.创建信号
    RACSubject *sourceSignal = [RACSubject subject];
    //2. 绑定信号
    RACSignal *bindSignal = [sourceSignal bind:^RACSignalBindBlock _Nonnull{
        
        return ^RACSignal *(id value, BOOL *stop){
            
            value = [NSString stringWithFormat:@"在这里处理源信号:%@",value];
            
            return [RACReturnSignal return:value];
        };
    }];
    //3.订阅绑定信号
    [bindSignal subscribeNext:^(id  _Nullable x) {
        NSLog(@"%@",x);
    }];
    //4. 发送数据
    [sourceSignal sendNext:@"123"];
    }
    ```
10. 这两个例子体现的hook思想:
    1. 任意一个信号,只要被绑定(bind),一旦发出数据信号,我们就能拿到这个信号进行处理,然后返回处理完的信号,当订阅拿到这个信号时,已经是改变后的信号
11. 底层实现
    1. `bind:`方法内部简析:
        
        ```
         方法简化如下:
         - (RACSignal *)bind:(RACSignalBindBlock (^)(void))block {
 
        //定义addSignal一个block
         void (^addSignal)(RACSignal *) = ^(RACSignal *signal) {
 
        //7. 订阅returnsignal
        //注意:这个signal是RACReturnSignal,这个类只要订阅就回直接调用nextblock,不需要再通过发送信号触发nextblock(其实也是需要通过发送信号的,只是内部比较复杂,但结果可以这样理解,但是这样记住就行了)
 
        RACDisposable *disposable = [signal subscribeNext:^(id x) {
 
        //8. 发送信号bindsignal,将处理数据传出去
        //9. 调用外部bindsignal的nextblock
        //这个subscriber是bindsignal的订阅者
 
        [subscriber sendNext:x];
 
             } error:^(NSError *error) {
             } completed:^{
             }];
            };
 
           // 1.创建bindsignal
            return [[RACSignal createSignal:^(id<RACSubscriber> subscriber) {
 
            //2.调用外部传进的block,返回RACSignalBindBlock
            RACSignalBindBlock bindingBlock = block();
 
            //3.内部订阅源信号
            RACDisposable *bindingDisposable = [self subscribeNext:^(id x) {
 
                    //4. 外部源信号发送数据,来到这里
                    // 5. 调用外部的bindingBlock,获得(处理后的信号)returnsignal
                    BOOL stop = NO;
                    id signal = bindingBlock(x, &stop);
 
                    //6.调用自定义的addSignalblock
                    if (signal != nil) addSignal(signal);
 
                    } error:^(NSError *error) {
                    } completed:^{
                }];
            }
            return compoundDisposable;
            }]];
        }
        ```
    2. 结论
        1. 源信号调用`bind`,会返回重新创建(`create`)的一个绑定信号`RACSignal(bindsignal)`。
        2. 当绑定信号(`bindsigna`l)被订阅,就会调用绑定信号中的didSubscribe
            1. 调用`bind:`传入的`block`,返回一个`bindingBlock(RACSignalBindBlock)`。
            2. 内部订阅外部的源信号,`nextBlock`
        3. 当源信号有内容发出(发送信号)，调用`bind`内部的订阅`nextBlock`
            1. 调用`bindingBlock`,外部`block`实现中进行处理,并返回处理后的信号`(RACReturnSignal)signal`
            2. 调用内部定义的`addSignal`这个`block`,将`returnsignal`传入
                1. 订阅`returnsignal`
                2. 这个`returnsignal`是`RACReturnSignal`,这个类只要订阅就回直接调用`nextblock`,不需要再通过发送信号触发`nextblock`(其实也是需要通过发送信号的,只是内部比较复杂,但结果可以这样理解,但是这样记住就行了)
                3. `nextblock`内部调用:`[subscriber sendNext:x];`
                4. 注意:这个subscriber是bindsignal的订阅者
        4. 调用外部订阅`bindSignal`的`nextblock`,拿到改变后的值
      


