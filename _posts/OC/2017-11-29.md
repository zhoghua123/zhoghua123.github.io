---
layout: post
title: Runtime系列2之-类与对象的操作函数
category: iOS开发
tags: Runtime
description: Runtime
--- 
## 前言
根据runtime的两大作用,上一章我们讲的是他的封装作用,即类和对象的实质是什么,下面这几篇文章就要将他的翻译作用了.    
说到翻译,无非就是把OC的代码翻译成runtime对应的代码,OC的代码也就是创建/修改/使用----类/对象/实例/属性/方法/协议这些操作了.由此观之Runtime也必然提供了这些与之对应的方法.    
下面本章我们先分析,专门针对类与对象的操作函数.            
runtime提供了大量的函数来操作类与对象。类的操作方法大部分是以`class_`为前缀的，而对象的操作方法大部分是以`objc_`或`object_`为前缀。下面我们将根据这些方法的用途来分类讨论这些方法的使用。    
本章知识主线:
     
1. 如何通过runtime提供的函数创建一个类和对象
2. 通过runtime函数来操作这个类,比如:添加/获取方法等
3. 通过runtime函数类操作创建的对象,比如:copy/销毁/获取对象的成员/属性值等

## 创建类和对象操作函数

runtime的强大之处在于它能在运行时创建类和对象。
### 动态创建类   
动态创建类涉及到以下几个函数：    
 
```
// 创建一个新类和元类
Class objc_allocateClassPair ( Class superclass, const char *name, size_t extraBytes );
// 销毁一个类及其相关联的类
void objc_disposeClassPair ( Class cls );
// 在应用中注册由objc_allocateClassPair创建的类
void objc_registerClassPair ( Class cls );
```

1. objc_allocateClassPair函数:
    1. 如果我们要创建一个根类，则superclass指定为Nil。extraBytes通常指定为0，该参数是分配给类和元类对象尾部的索引ivars的字节数。
    2. 为了创建一个新类，我们需要调用objc_allocateClassPair。然后使用诸如class_addMethod，class_addIvar等函数来为新创建的类添加方法、实例变量和属性等。完成这些后，我们需要调用objc_registerClassPair函数来注册类，之后这个新类就可以在程序中使用了。
    3. 实例方法和实例变量应该添加到类自身上，而类方法应该添加到类的元类上。
2. objc_disposeClassPair函数:
    1. 用于销毁一个类，不过需要注意的是，如果程序运行中还存在类或其子类的实例，则不能调用针对类调用该方法。   

### 动态创建对象
动态创建对象的函数如下：    

```
// 创建类实例
id class_createInstance ( Class cls, size_t extraBytes );
// 在指定位置创建类实例
id objc_constructInstance ( Class cls, void *bytes );
// 销毁类实例
void * objc_destructInstance ( id obj );
```

1. class_createInstance函数：  
    1. 创建实例时，会在默认的内存区域为类分配内存。extraBytes参数表示分配的额外字节数。这些额外的字节可用于存储在类定义中所定义的实例变量之外的实例变量。
    2. 调用class_createInstance的效果与+alloc方法类似。不过在使用class_createInstance时，我们需要确切的知道我们要用它来做什么。
2. objc_constructInstance函数：
    1. 在指定的位置(bytes)创建类实例。
3. objc_destructInstance函数：
    1. 销毁一个类的实例，但不会释放并移除任何与其相关的引用。      
    
上面讲了如何创建类,然后如何创建对象,代码举例:                
动态创建一个TestClass类,继承自NSObject

```javascript
- (void)createNewClass{
    //1.创建一个TestClass类
    Class newClass = objc_allocateClassPair([NSObject class], "TestClass", 0);
    //3.注册这个类
    objc_registerClassPair(newClass);
    //4.通过这个类创建一个实例
    id theObject = class_createInstance(newClass, sizeof(unsigned));
    id instance = [theObject init];
    //打印
    NSLog(@"--对象为--%@--类为--%@--父类为--%@",instance,[instance class],[instance superclass]);
}
```
打印结果如下:     
` --对象为--<TestClass: 0x600000000a00>--类为--TestClass--父类为--NSObject
`
### 获取类定义
从上面的创建类我们可以知道,通过`objc_allocateClassPair`方法来创建一个类后,还需要通过`objc_registerClassPair`方法来注册这个类.这是通过runtime来动态创建这个类.
然而我们通过OC创建的一个类,Objective-C动态运行库会自动注册我们代码中定义的所有的类.   
runtime提供了一系列函数来获取类定义相关的信息，这些函数主要包括：    

```
// 获取已注册的类定义的列表
int objc_getClassList ( Class *buffer, int bufferCount );
// 创建并返回一个指向所有已注册类的指针列表
Class * objc_copyClassList ( unsigned int *outCount );
// 返回指定类的类定义
Class objc_lookUpClass ( const char *name );
Class objc_getClass ( const char *name );
Class objc_getRequiredClass ( const char *name );
// 返回指定类的元类
Class objc_getMetaClass ( const char *name );
```

1. objc_getClassList函数：
    1. 获取已注册的类定义的列表。我们不能假设从该函数中获取的类对象是继承自NSObject体系的，所以在这些类上调用方法是，都应该先检测一下这个方法是否在这个类中实现。
2. 获取类定义的方法有三个:
    1.`objc_lookUpClass`, `objc_getClass`和`objc_getRequiredClass`。如果类在运行时未注册，则`objc_lookUpClass`会返回nil，而`objc_getClass`会调用类处理回调，并再次确认类是否注册，如果确认未注册，再返回nil。而`objc_getRequiredClass`函数的操作与`objc_getClass`相同，只不过如果没有找到类，则会杀死进程。
3. objc_getMetaClass函数：
    1. 如果指定的类没有注册，则该函数会调用类处理回调，并再次确认类是否注册，如果确认未注册，再返回nil。不过，每个类定义都必须有一个有效的元类定义，所以这个函数总是会返回一个元类定义，不管它是否有效。
    
## 类相关操作函数


