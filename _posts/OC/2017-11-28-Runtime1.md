---
layout: post
title: Runtime系列之-类与对象的本质
category: iOS开发
tags: Runtime
description: Runtime
--- 

# 简介
1. Objective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。这种动态语言的优势在于：我们写代码时更具灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。    
2. 这种特性意味着Objective-C不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。对于Objective-C来说，这个运行时系统就像一个操作系统一样：它让所有的工作可以正常的运行。这个运行时系统即`Objc Runtime`。`Objc Runtime`其实是一个`Runtime`库，它基本上是用C和汇编写的，这个库使得C语言有了面向对象的能力。    
3. 对于C语言，函数的调用在编译的时候会决定调用哪个函数，如果调用未实现的函数就会报错。  
4. 对于OC语言，属于动态调用过程，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用.
5. 编译器最终都会将OC代码转化为运行时代码，通过终端命令编译.m 文件：clang -rewrite-objc xxx.m可以看到编译后的xxx.cpp（C++文件）。  
比如我们创建了一个对象 [[NSObject alloc]init]，最终被转换为几万行代码，截取最关键的一句可以看到底层是通过runtime创建的对象.   

  ```c
 ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass("NSObject"), sel_registerName("alloc")), sel_registerName("init"));
  ```
删除掉一些强制转换语句如下:
`objc_msgSend(objc_getClass("NSObject"),sel_registerName("alloc"), sel_registerName("init"));`
可以看出:调用方法本质就是发消息，[[NSObject alloc]init]语句发了两次消息，第一次发了alloc 消息，第二次发送init 消息。利用这个功能(把OC代码转为运行时代码)我们可以探究底层，比如block的实现原理。   
注意: 使用objc_msgSend() sel_registerName()方法需要导入头文件<objc/message.h>,若不使用直接导入<objc/runtime.h>就即可

6. Runtime的作用
    1. 封装:既然C语言中没有对象/类这些概念,那么Runtime中OC中的对象/类对应的是什么呢?
        1. 在这个库中，对象可以用C语言中的结构体表示，而方法可以用C函数来实现，另外再加上了一些额外的特性。这些结构体和函数被runtime函数封装后，我们就可以在程序运行时创建，检查，修改类、对象和它们的方法了。
    2. 翻译代码:将OC的代码翻译成runtime代码
    
# 类与对象
从上面Runtime的分析来看,我们首先看看,类与对象在runtime中到底是什么   

## 类
**注意:**这里所说的类,都是类对象     
在OC代码中我们表示一个类用`Class`这个关键字修饰,如下:    
`Class class = [NSObject class];`       
 Xcode中点击进入Class这个关键字查看,如下:    
`typedef struct objc_class *Class;`     
从这里(此时的文件是objc.h)可以看出,Class关键字,其实就是一个`struct objc_class`类型的结构体指针.那么objc_class结构体的定义是什么呢?  
那么我们就只能到runtime.h中查看了,如何找到runtime.h文件呢?
方式1:在Xcode中导入头文件`#import <objc/runtime.h>`然后点击进入查看  
方式2: Finder->应用程序->Xcode->显示包内容->Developer->paltforms->iPhone OS->Developer->SDKs->usr(system是苹果的所有框架)->include->objc这里面包含了很多最基层的头文件,objc/runtime/message/NSObject等     
我们打开runtime.h,找到objc_class这个结构体定义如下: 
   
```c
struct objc_class {

// 指向metaclass
    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;

#if !__OBJC2__
// 指向其父类
    Class _Nullable super_class                              OBJC2_UNAVAILABLE;
    //类名
    const char * _Nonnull name                               OBJC2_UNAVAILABLE;
    // 类的版本信息，初始化默认为0
    long version                                             OBJC2_UNAVAILABLE;
    // 一些标识信息,如CLS_CLASS (0x1L) 表示该类为普通 class ，其中包含对象方法和成员变量;CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法;
    long info                                                OBJC2_UNAVAILABLE;
     // 该类的实例变量大小(包括从父类继承下来的实例变量);
    long instance_size                                       OBJC2_UNAVAILABLE;
    // 用于存储每个成员变量的地址
    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;
     // 与 info 的一些标志位有关,如CLS_CLASS (0x1L),则存储对象方法，如CLS_META (0x2L)，则存储类方法;
    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;
     // 指向最近使用的方法的指针，用于提升效率；
    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;
    // 存储该类遵守的协议
    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;
#endif

} OBJC2_UNAVAILABLE;
/* Use `Class` instead of `struct objc_class *` */
```


