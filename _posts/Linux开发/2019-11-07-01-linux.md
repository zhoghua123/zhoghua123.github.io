---
layout: post
title: Linux系统编程-进程
category: Linux开发
tags: Linux开发
description: Linux开发
--- 

## 进程的概念
1. 程序和进程
    1. 程序，是指编译好的二进制文件，在磁盘上，不占用系统资源(cpu、内存、打开的文件、设备、锁....)
    2. 进程，是一个抽象的概念，与操作系统原理联系紧密。**进程是活跃的程序，占用系统资源。在内存中执行。(程序运行起来，产生一个进程)**
        1. 进程所有的数据都在内存
        2. 需要占用系统资源（cpu、物理内存、硬盘（虚拟地址空间，跟磁盘上占用的空间不一样））
    3. 举例：
        1. `程序 → 剧本(纸)		进程 → 戏(舞台、演员、灯光、道具...)`
        2. 同一个剧本可以在多个舞台同时上演。同样，**同一个程序也可以加载为不同的进程(彼此之间互不影响)**
        3. 如：同时开两个终端。各自都有一个bash但彼此ID不同。
2. 并发和并行
    1. 并发，在操作系统中，一个时间段中有多个进程都处于已启动运行到运行完毕之间的状态。但，任一个时刻点上仍只有一个进程在运行。
    2. 例如，当下，我们使用计算机时可以边听音乐边聊天边上网。 若笼统的将他们均看做一个进程的话，为什么可以同时运行呢，因为并发。
    3. 通俗举例：
        1. 并发：
            1. 不是一个时间点的概念，是一个时间段的概念
            2. 一个咖啡机，200个人用杯子接，1分钟之内都要喝上，那么就没人接一口，然后循环。
            3. 并发量指的就是一段时间内完成了多少任务。
        2. 并行：
            1. n个咖啡机，同时工作，200个人接。
    4. 单道程序设计
        1. 所有进程一个一个排对执行。若A阻塞，B只能等待，即使CPU处于空闲状态。而在人机交互时阻塞的出现时必然的。所有这种模型在系统资源利用上及其不合理，在计算机发展历史上存在不久，大部分便被淘汰了。
    5. 多道程序设计
        1. 在计算机内存中同时存放几道相互独立的程序，它们在管理程序控制之下，相互穿插的运行。多道程序设计必须有硬件基础作为保证。
        2. **时钟中断**即为多道程序设计模型的理论基础。 并发时，任意进程在执行期间都不希望放弃cpu。因此系统需要一种强制让进程让出cpu资源的手段。时钟中断有硬件基础作为保障，对进程而言不可抗拒。 操作系统中的中断处理函数，来负责调度程序执行。
        3. 在多道程序设计模型中，多个进程轮流使用CPU (分时复用CPU资源)。而当下常见CPU为纳秒级，1秒可以执行大约10亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。
        4. **实质上，并发是宏观并行，微观串行！**
3. CPU和MMU
    1. CPU运行原理：
        ![图4](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/linux-11.png)
        
        1. 先把磁盘数据缓存到硬盘中，内存相对于硬盘存储容量变小，但是速度变快了
        2. 然后把内存的数据放到缓冲区中（cache），然后在通过cache导入到寄存器中。
        3. 寄存器再交给cup进行运算
        4. 程序的运行过程
            1. 将a.out从网络下载到磁盘中
            2. 当运行a.out时，产生进程，然后程序加载到内存中
            3. 然后通过内存加载到缓冲区cache
            4. 然后通过cache进入到CPU
            5. 但是实际上进入到CPU的并不是程序的全部，而是一条将要执行的一条指令
            6. cup每次从缓冲区取一条指令，由CPU中的预取器来完成
            7. 然后预取器将这条指令交给译码器（add eax,ebx）
            8. 译码器分析这条指令作用，需要哪些寄存器，然后将相应的数据存入寄存器
            9. 然后译码器交给ALU算术单元进行运算（ALU只会加法与左移运算）
            10. 将运算结果在写入到寄存器中
            11. 然后由寄存器再返回给缓存cache
            12. 直到物理设备显示。
    2. MMU的基本工作原理
        ![图4](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/linux-12.png)
        
        1. MMU位于CPU内部的硬件，叫内存管理单元
        2. MMU的作用：完成虚拟内存与物理内存的映射
            1. 程序运行先加载到虚拟内存，这个虚拟内存地址是0-4g
            2. 也就是说你这个程序运行有0-4g的内存地址可以分配，这个地址是虚拟的，假设分配的，即预设的
            3. 由于这个程序的所有数据分配的是虚拟内存地址，但是最终还是要加载到实际的物理内存中
            4. 那么这就需要将虚拟内存地址转化为真实的物理内存地址。
            5. 这个转化功能就是MMU来完成的
            6. 我们程序员只需要关注数据的虚拟内存地址即可。
        3. MMU的作用：设置修改内存访问级别
            1. 对于虚拟内存来说，0-3g为用户区，3-4g为内核区，但是物理内存是没有做区分的
            2. 此时，MMU在将虚拟内存映射到物理内存的同时，设置改内存的访问级别，这个访问级别是给CPU设置的
            3. 正常情况下interl的CPU有4种访问级别（3、2、1、0，从小到大）
                1. 比如printf的调用，先访问用户区（3）
                2. 然后内部实际调用的是内核方法，然后访问的是内核区（0），调用硬件显示数据。
        4. 什么是内核？
            1. 操作系统的核心程序，简称内核
            2. 操纵计算机硬件工作，辅助所有的进程运行的。
            3. 由于同一个操作系统下内核是一样的，所以多个进程之间虚拟内存映射到物理内存中的内核是同一块内存。
        5. MMU什么时候被使用到呢？
            1. 预取器通过**虚拟内存地址**取数据时，通过MMU映射成**物理内存地址**，然后取出数据
            2. 同理计算结果从寄存器写入到内存时，写入的也是虚拟内存地址，然后通过MMU映射到物理内存


