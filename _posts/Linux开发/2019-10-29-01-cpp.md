---
layout: post
title: makefile、Linux系统IO函数
category: Linux开发
tags: Linux开发
description: Linux开发
--- 

## makefile
1. 什么是makefile？
    1. 项目代码管理工具，用于管理我们程序的源代码。
2. 为何需要makefile？
    1. 比如程序有100个文件，那么编译时：`gcc *c .....`,由于各个文件的目录还不同，那么gcc就很长，很复杂
    2. 因此makefile就是为了解决这个问题而生
    3. makefile可以把所有代码编译的命令都写到makefile中
    4. 只需要执行makefile命令就可以完成编译了
3. makefile这么复杂谁来编写？
    1. 通常不需要普通程序员编写，通常是项目管理人编写
    2. 普通程序员只需要编写自己的模块
4. makefile的本质
    1. 就是一个文件，内部写了编译程序的步骤
    
### 编写一个最简单的makefile
1. makefile的命名规则
    1. 方式1：`makefile`
    2. 方式2：`Makefile`
2. 创建makefaile文件:`vi makefile`
3. makefile编写规则
    1. 规则中的三要素
        1. 目标
        2. 依赖
        3. 命令
    2. 固定格式：
        ```
        目标:依赖条件
            (tab缩进)命令
        ```
    3. 代码举例：
        
        ```
        app:add.c main.c
            gcc add.c  main.c -o app    
        ```
    4. 编写完后，保存退出vi
4. 执行makefile
    1. 输入make，就能输出makefile中编写的编译命令,然后执行，并且生成可执行文件app
        
        ```
        gcc add.c  main.c -o app 
        ```
5. 上面的写法有个缺点，每次执行一次make都会吧所有的文件都编译一遍，如果我仅仅修改了其中的某一个文件，其他文件都会重新编译，比较浪费,因此需要优化makefile，修改如下
    
    ```
    app:add.o main.o
        gcc add.o main.o -o app
    main.o:main.c
        gcc -c main.c    
    add.o:add.c
        gcc -c add.c
    ```
    
    1. 上面一共有3条规则
        1. 第一条规则用于生成终极目标app
        2. 下面的几个叫做子目标，下面的子目标跟第一个目标的依赖有关系
        3. 当要生成终极目标app时，他就会查找依赖，发现依赖add.o没有，向下查找对应的规则，直到查找到有一条规则是生成这个依赖的，main.o也一样。
        4. 子目标就是用来生成第一个目标的依赖条件的。
        5. 当所有的依赖都找到了，才会执行第一个目标下面的命令
        6. 再次输入make命令时执行如下：
        
            ```
            gcc -c main.c
            gcc -c add.c
            gcc add.o -o app
            ```
        7. 如果修改了main.c,然后再执行make
            
            ```
            gcc -c main.c
            gcc add.o -o app
            ```
        8. 说明已经实现了目的
    2. makefile怎么知道哪些文件被修改了呢？
        1. 如果没有修改，那么终极目标文件app肯定是时间最晚的；一旦某个.c文件被修改，那么这个文件的时间就大于目标文件app
        2. 用终极目标的app时间与其他.c文件时间进行比较，来进行判断
        3. 如下图
            ![图4](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/linux-05.png)
            
### makefile中的变量
1. 看下面makefile中的内容
    
    ```
    app:add.o main.o
        gcc add.o main.o -o app
    main.o:main.c
        gcc -c main.c    
    add.o:add.c
        gcc -c add.c
    ```
    
    1. 可以看到第一条规则`add.o main.o`重复了，如果很多文件这里就要写更多重复了
    2. 第二条、第三条，也非常像似，只是文件的名字不一样
    3. 那么可不可以简化呢？----使用变量代替
2. makefile中的变量
    1. **makefil中的普通变量**
        1. makefile中的变量是不需要类型的，直接输入一个标识符即可。
        2. makefile中从变量取值：`$(变量名)`
    2. 多行替换命令：`:3,4s/app/$(target)`
        1. 将第3、4行的app替换成`$(target)`
    3. **makefile中的占位符%**
        
        ```
        app:add.o main.o
            gcc add.o main.o -o app
        %.o:%.c
            gcc -c $< -o $@
        ```
        
        1. `%.o:%.c`这个是什么意思呢？
            1. 当生成中级目标时，先查找第一个依赖add.o，发现没有，就下子目标中查找
            2. 此时找到`%.o:%.c`,就会将里面的`%`替换成这个依赖的名字`add`
            3. 替换之后就如下:`add.o:add.c`
            4. 其他依赖依次进行。
            5. 因此即使有n个.c文件，只需要写一个公式即可
                
                ```
                %.o:%.c
                gcc -c $< -o $@
                ```
        2. `gcc -c $< -o $@`是什么意思呢？
    4. **makefile中的自动变量**
        1. `$<`:自动变量,代表**当前规则**中的第一个依赖
        2. `$@`:自动变量，代表**当前规则**中的第一个目标
        3. `$^`:自动变量，代表**当前规则**中的所有依赖
        4. 这3个变量，只能在规则中的命令中使用
        5. 比如这个目标：`app:add.o main.o`,对应命令如下
            
            ```
            gcc -c $^ -o $@
            ```
    5. **makefile中自己维护的变量**
        1. 特点：都是大写
        2. 小写的变量都是用户自定义的，大写的变量是系统维护的。
        3. 系统维护的变量，有些事有默认值的，有些没有
        4. 比如：
            
            ```
            CC = gcc
            CPPFLAGS = -I
            cPPFLAGS:预处理器需要的选项，比如-I
            CFLAGS:编译的时候使用的参数 -Wall -g -c
            LDFLAGS:链接库使用的选项 -L -l
            ```
3. makefile文件简化后如下：
    
    ```
    obj=add.o main.o //变量obj
    target=app //变量target
    CC=gcc //makefile自己维护的变量
    $(target):$(obj)
            $(CC) $(obj) -o $(target)
    %.o:%.c
            $(CC) -c $< -o $@
    ```
    
### makefile中的函数
1. makefile中提供了很多函数
2. 在makefile中所有的函数都是有返回值的。
3. 这个变量`obj=add.o main.o`,如果项目中有n个.c，这里就要写n个.o
4. 函数调用样式：`$(函数名 参数， 参数, ...)`
5. 这样就可以使用makefile中的函数
    
    ```
    target=app
    //获取指定目录下的所有.c文件
    //&(函数名 路径+文件类型)  
    //查找某个目录下面的某种类型的文件
    src=$(wildcard ./*.c)
    //将某个目录下的所有.c，替换成某个 目录下的所有.o
    obj=$(patsubst ./%.c, ./%.o, $(src))
    CC=gcc
    CPPFLAGS = -I
    $(target):$(obj)
            $(CC) $(obj) -o $(target)
     %.o:%.c
             $(CC) -c $< -o $@
    ```
5. 每次修改源文件，再次执行make之前，都要把之前生成的.o与可执行文件app全部删除，才能重新执行make，这个很麻烦，也能通过makefile设置，新增一条规则如下：
    
    ```
    //防止当前目录下有个同名文件叫clean,如果没这句,执行make clean就不行了
    .PHYONY:clean
    //删除所有.o文件和最终的可执行目标文件target
    clean:
          rm $(obj) $(target) -f
    ```   
    
    1. 保存makefile后直接输入命令`make clean`即可
    2. `make 目标`，只执行makefile的对应目标命令。
6. makefile最终内容如下：
    
    ```
    #obj=add.o main.o
    
    target=app
    src=$(wildcard ./*.c)
    obj=$(patsubst ./%.c, ./%.o, $(src))
    CC=gcc
    CPPFLAGS = -I
    $(target):$(obj)
            $(CC) $(obj) -o $(target)
    %.o:%.c
            $(CC) -c $< -o $@
    .PHYONY:clean
    clean:
            rm $(obj) $(target) -f
    ```

## Linux系统IO函数

![图4](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/linux-07.png)

1. linux中的系统库函数与C语言中的系统库函数相对应
2. 调用fopen函数获取一个`FILE *`类型的指针变量，其余的函数都需要传入这个变量，那个这个`FILE *`本质是什么呢？
3. FILE的本质是一个结构体，这个结构体组要内容有三部分
    1. **文件描述符（整型值）**：索引到对应的磁盘文件
        1. 使用fopen打开某个文件，这个文件对应磁盘上的某个位置，就是使用文件描述符找到并访问磁盘上的某个文件
    2. 文件读写指针位置：读写文件过程中指针的实际位置
        1. 文件被打开之后肯定有个文件指针，文件指针指向文件起始位置，当写入内容时，文件指针向后移动，写到哪文件指针就指到哪
        2. 这就是为什么，当写一些内容到文件，但是文件没有保存关闭，然后就直接使用文件指针去读取内容，读取不到值的原因，指针指向最后，当然读取不到
        3. 必须重置文件指针的位置，重置到开始位置，才能读取到
    3. I/O缓冲区（内存地址）：通过寻址找到对应的内存块
        1. 在标准C库函数中都提供了I/O缓冲区
        2. 缓冲区默认大小8KB
        3. 为什么需要一个I/O缓冲区呢？
            1. 理论上通过C库函数读一个(fgetc)然后写到磁盘中(fputc),但实际上不是这样
            2. 实际上是每次读一个字符，然后放到缓冲区，然后再读，直到缓冲区满了之后才会放入到磁盘
            3. 这样能够减少操作硬盘的次数从而提高效率，内存的效率比硬盘效率高太多。
        4. 把内存中的数据刷到硬盘上,通常有3种情况
            1. 用户主动执行刷新缓冲区：`fflush`
            2. 缓冲区已满
            3. 正常关闭文件
                1. fclose
                2. return (main函数)
                3. exit（main函数）
        5. 注意:**Linux的系统函数是没有这块缓存的。**
            1. linux函数的缓存需要程序员提供
            2. C库函数是内部封装好的

### 虚拟地址空间
![图4](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/linux-06.png)

1. 每一个应用程序执行起来之后，操作系统都会给他分配一个对应的虚拟地址空间
2. 这个虚拟地址空间时在虚拟内存中的，虚拟内存空间不是内存而是占用的硬盘空间！！！
3. 在32位操作系统中，给程序分配的是0-4G(2的32次方)的虚拟地址空间
4. 其中0-3G被称为用户区，专门用于程序员使用的。
5. 3-4G为Linux 的内核区，不允许程序员访问操作。

#### Linux的内核区
1. Linux的内核区可以做
    1. 内存管理
    2. 进程管理
    3. 设备驱动管理
    4. VFS虚拟文件系统
2. 上面讲的文件描述符到底是什么呢？
    ![图4](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/linux-08.png)

    1. 文件描述符就位于内核区，内核区有进程管理，进程管理中有个PCB进程控制块，在PCB进程控制块中有个文件描述符表
    2. 文件描述符表本质是一个数组，数组的大小为0~1023，每个位置代表能够打开一个文件
    3. 每打开一个文件就会在表中占有一个位置
    4. 一个进程最多能够打开1024个文件，但是用户能够打开的有1024-3个文件，因为表的前3个（标准输入、标准输出、标出错误）总是处于被打开的状态，被占用
    5. 没打开一个新文件，则占用一个文件描述符，而且使用的是空间最小的描述符
        1. 打开A文件，占用3；打开B文件占用4；若此时关闭了A文件，3被空出来了，再打开C文件时，会占用3.

#### Linux的用户区
1. 首先可执行文件a.out被执行，然后操作系统给这个应用程序分配一个虚拟地址空间。
2. 用户区主要分为
    1. 0-4k受保护部分
    2. ELF段
    3. 堆空间
    4. 共享库
    5. 栈空间
    6. 命令行参数
    7. 环境变量
3. ELF
    1. Linux下可执行文件格式叫ELF
    2. 查看一个可执行程序的文件格式：`file 可执行文件`,比如，输入`file app`,输出如下
            
        ```
        app: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 3.2.0, BuildID[sha1]=48823ee318ab5fec0c08f6b6ea62533f7dc42689, not stripped
        ```
    3. EFL内部都有哪些区域呢？
        1. `.text`代码段，二进制机器指令：
            1. 把源代码放到该段
        2. `.data`:存放已经初始化的的全局变量
        3. `.bss`:未初始化的全局变量
        4. 其他段：只读数据段、符号段等
4. **可执行程序的执行过程**
    1. CPU在执行程序的时候从main函数开始，即从代码段开始，如果遇到全局变量的就放在`.data`或者`.bss`；如果遇到局部变量就放在栈空间；如果遇到了malloc或者new这放到堆空间；如果遇到了调用C标准函数比如fread，这个是动态库函数，那么就会加载相应的动态库到共享区
    2. 栈空间分配地址从大到小
    3. 堆空间分配地址从小到大
    4. 共享区域的加载是无序的，见空插针，所以生成动态库的时候就要生成一个与位置无关的库。静态库就直接放到代码段`.text`
5. 命令行参数主要用于存放main函数的参数
6. 环境变量（env），用于存储当前进程的所有环境变量
7. cpu为什么要使用虚拟地址空间与物理地址空间映射？ 解决了什么样的问题？
    1. 方便编译器和操作系统安排程序的地址分布
        1. 程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。
        2. 比如一个进程需要内存中有一块10M的连续空间，但是呢？ 物理内存中有大于10m的空间，但是不是连续的。这时如果有了虚拟内存，就可以通过虚拟内存来映射，通过这个映射功能就能够解决这个问题。
    2. 方便进程之间隔离
        1. 不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程使用的物理内存。
    3. 方便OS使用可怜的内存
        1. 程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓存区。当物理内存供应量变小时，内存管理器会将物理内存页（通常大小为4k）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动
8. 虚拟内存空间的本质
    1. 程序启动之后，从**硬盘**上会有一块虚拟内存分配出来，这个内存叫虚拟地址空间。
    2. 实际上当执行一个程序之后，内存并没有少4个g。
    3. 虚拟内存就是有4个g的空间供你操作，实际上这个程序用了多少空间，内存才少多少空间。
    4. 用通俗的话来说，先用硬盘给你提供一个4G的操作环境，而在操作过程中实际需要的空间，才会占据物理内存。

### C库函数与系统函数的关系
![图4](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/linux-09.png)

1. 标准C函数printf，怎么就能把字符输出到屏幕上呢？
2. prinf不能直接操作硬件
3. printf的本质
    1. printf内部调用标准输出：(stdout):FILE*
    2. 本质是文件操作
    3. 文件指针内部有
        1. FD：文件描述符
        2. FP_POS:文件指针
        3. BUFFER:缓冲区
    4. 其余如上图。

### linux下应用层的系统I/O函数
1. man文档使用
    
    ```
    man man :打开man文档目录
    man 3 printf： 查找man文档第3章中的printf函数
    man 2 open：查看man文档第2张的open函数
    ```
    
    1. 查看man文档时会看到很多的陌生数据类型，比如：size_t
    2. 因为man文档是nuix下面的，unix早于C语言，unix用C语言重写之前就有自己的数据类型。所以那些陌生类型就是Unix的数据类型，但是他跟C语言的基本数据类型本质一样。比如size_t就是int
2. open函数
    
    ```
    //文件已经存在
    int open(const char *pathname, int flags);
    //文件不存在
    int open(const char *pathname, int flags, mode_t mode);
    ```
    
    1. pathname :要打开的文件路径
    2. flags：要打开的方式
        
        ```
        The  argument  flags  must  include  one of the following access modes:
        O_RDONLY, O_WRONLY, or O_RDWR.  
        The  file  creation  flags  are O_CLOEXEC,O_CREAT,O_DIRECTORY,O_EXCL,O_NOCTTY,  O_NOFOLLOW,  O_TMPFILE, and O_TRUNC. 
        ```
    3. mode:这个调用方式是用于文件不存在调用方式
        1. 给创建文件制定访问权限
    4. 返回值：
        
        ```
        //返回一个新的文件描述符。或者-1，如果为-1就是错误发生（在这种情况下，有个全局变量errno就会被赋值。可以通过errno的值来判别错误的具体原因）
        open(), openat(), and creat() return the new file descriptor, or -1  if
        an error occurred (in which case, errno is set appropriately).
        ```
    5. errno是linux系统的全局变量，专门用于标记错误类型。
        1. 通过`void perror(const char *s)`函数来获取到errno的具体错误内容
        2. 使用perror函数时，会先读取errno的值，然后就会把错误原因输出到标准设备（stderr）
        3. 参数s所指的字符串会先打印出，后面再加上错误原因字符串
        4. 错误原因依照全局变量errno的值来决定要输出的字符串
        5. errno的声明在errno.h头文件中：`vi /usr/include/errno.h`
    6. open函数的使用
        
        ```
        #include<sys/types.h>
        #include<sys/stat.h>
        #include<fcntl.h>
        #include<unistd.h>
        #include<stdlib.h>
        #include<stdio.h>
           
        int main()
        {
             int fd;
             //打开一个已经存在的文件
             //2K(shift+k)跳转到man文档中open函数
             fd = open("add.c",O_RDWR);
             if(fd==-1)
             {
                     perror("open file");
                     exit(1);
             }
             //打开一个不存在的文件
             fd = open("hello",O_RDWR | O_CREAT,0777);
             if(fd==-1)
             {
                     perror("open file");
                     exit(1);
             }
             printf("fd=%d",fd);
             //
             int ret = close(fd);
             printf("ret = %d",ret);
             if(ret=-1)
             {
                     perror("close file");
             }
             return 0;
        }
        ```
3. read和write函数
    1. 查看man文档:`man 2 read`
        
        ```
        //锁需要包含的头文件
        #include <unistd.h>
        //ssize_t 有符号整型
        ssize_t read(int fd, void *buf, size_t count);
        ```
        
        1. fd:文件描述符
        2. buf:需要用户提供的缓冲区
        3. 每次读数据用多大的buf
        4. 返回值:
            
            ```
            -1:读取失败了
            0: 文件读完了
            >0: 读取的字节数
            ```
        5. 同理文件读取的错误信息,会赋值给errno
    2. 查看man文档:`man 2 write`
        
        ```
        #include <unistd.h>
        ssize_t write(int fd, const void *buf, size_t count);
        ```
        
        1. 将buf中的内容写到磁盘上
    3. 查看man文档:`man 2 lseek`
        
        ```
        #include <sys/types.h>
        #include <unistd.h>
        off_t lseek(int fd, off_t offset, int whence);
        ```
        
        1. 作用:移动文件指针,获取文件长度
        2. offset:文件指针的偏移量


