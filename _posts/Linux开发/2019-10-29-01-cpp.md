---
layout: post
title: makefile
category: Linux开发
tags: Linux开发
description: Linux开发
--- 

## makefile
1. 什么是makefile？
    1. 项目代码管理工具，用于管理我们程序的源代码。
2. 为何需要makefile？
    1. 比如程序有100个文件，那么编译时：`gcc *c .....`,由于各个文件的目录还不同，那么gcc就很长，很复杂
    2. 因此makefile就是为了解决这个问题而生
    3. makefile可以把所有代码编译的命令都写到makefile中
    4. 只需要执行makefile命令就可以完成编译了
3. makefile这么复杂谁来编写？
    1. 通常不需要普通程序员编写，通常是项目管理人编写
    2. 普通程序员只需要编写自己的模块
4. makefile的本质
    1. 就是一个文件，内部写了编译程序的步骤
    
### 编写一个最简单的makefile
1. makefile的命名规则
    1. 方式1：`makefile`
    2. 方式2：`Makefile`
2. 创建makefaile文件:`vi makefile`
3. makefile编写规则
    1. 规则中的三要素
        1. 目标
        2. 依赖
        3. 命令
    2. 固定格式：
        ```
        目标:依赖条件
            (tab缩进)命令
        ```
    3. 代码举例：
        
        ```
        app:add.c main.c
            gcc add.c  main.c -o app    
        ```
    4. 编写完后，保存退出vi
4. 执行makefile
    1. 输入make，就能输出makefile中编写的编译命令,然后执行，并且生成可执行文件app
        
        ```
        gcc add.c  main.c -o app 
        ```
5. 上面的写法有个缺点，每次执行一次make都会吧所有的文件都编译一遍，如果我仅仅修改了其中的某一个文件，其他文件都会重新编译，比较浪费,因此需要优化makefile，修改如下
    
    ```
    app:add.o main.o
        gcc add.o main.o -o app
    main.o:main.c
        gcc -c main.c    
    add.o:add.c
        gcc -c add.c
    ```
    
    1. 上面一共有3条规则
        1. 第一条规则用于生成终极目标app
        2. 下面的几个叫做子目标，下面的子目标跟第一个目标的依赖有关系
        3. 当要生成终极目标app时，他就会查找依赖，发现依赖add.o没有，向下查找对应的规则，直到查找到有一条规则是生成这个依赖的，main.o也一样。
        4. 子目标就是用来生成第一个目标的依赖条件的。
        5. 当所有的依赖都找到了，才会执行第一个目标下面的命令
        6. 再次输入make命令时执行如下：
        
            ```
            gcc -c main.c
            gcc -c add.c
            gcc add.o -o app
            ```
        7. 如果修改了main.c,然后再执行make
            
            ```
            gcc -c main.c
            gcc add.o -o app
            ```
        8. 说明已经实现了目的
    2. makefile怎么知道哪些文件被修改了呢？
        1. 如果没有修改，那么终极目标文件app肯定是时间最晚的；一旦某个.c文件被修改，那么这个文件的时间就大于目标文件app
        2. 用终极目标的app时间与其他.c文件时间进行比较，来进行判断
        3. 如下图
            ![图4](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/linux-05.png)
            
### makefile中的变量
1. 看下面makefile中的内容
    
    ```
    app:add.o main.o
        gcc add.o main.o -o app
    main.o:main.c
        gcc -c main.c    
    add.o:add.c
        gcc -c add.c
    ```
    
    1. 可以看到第一条规则`add.o main.o`重复了，如果很多文件这里就要写更多重复了
    2. 第二条、第三条，也非常像似，只是文件的名字不一样
    3. 那么可不可以简化呢？----使用变量代替
2. makefile中的变量
    1. **makefil中的普通变量**
        1. makefile中的变量是不需要类型的，直接输入一个标识符即可。
        2. makefile中从变量取值：`$(变量名)`
    2. 多行替换命令：`:3,4s/app/$(target)`
        1. 将第3、4行的app替换成`$(target)`
    3. **makefile中的占位符%**
        
        ```
        app:add.o main.o
            gcc add.o main.o -o app
        %.o:%.c
            gcc -c $< -o $@
        ```
        
        1. `%.o:%.c`这个是什么意思呢？
            1. 当生成中级目标时，先查找第一个依赖add.o，发现没有，就下子目标中查找
            2. 此时找到`%.o:%.c`,就会将里面的`%`替换成这个依赖的名字`add`
            3. 替换之后就如下:`add.o:add.c`
            4. 其他依赖依次进行。
            5. 因此即使有n个.c文件，只需要写一个公式即可
                
                ```
                %.o:%.c
                gcc -c $< -o $@
                ```
        2. `gcc -c $< -o $@`是什么意思呢？
    4. **makefile中的自动变量**
        1. `$<`:自动变量,代表**当前规则**中的第一个依赖
        2. `$@`:自动变量，代表**当前规则**中的第一个目标
        3. `$^`:自动变量，代表**当前规则**中的所有依赖
        4. 这3个变量，只能在规则中的命令中使用
        5. 比如这个目标：`app:add.o main.o`,对应命令如下
            
            ```
            gcc -c $^ -o $@
            ```
    5. **makefile中自己维护的变量**
        1. 特点：都是大写
        2. 小写的变量都是用户自定义的，大写的变量是系统维护的。
        3. 系统维护的变量，有些事有默认值的，有些没有
        4. 比如：
            
            ```
            CC = gcc
            CPPFLAGS = -I
            cPPFLAGS:预处理器需要的选项，比如-I
            CFLAGS:编译的时候使用的参数 -Wall -g -c
            LDFLAGS:链接库使用的选项 -L -l
            ```
3. makefile文件简化后如下：
    
    ```
    obj=add.o main.o //变量obj
    target=app //变量target
    CC=gcc //makefile自己维护的变量
    $(target):$(obj)
            $(CC) $(obj) -o $(target)
    %.o:%.c
            $(CC) -c $< -o $@
    ```
    
### makefile中的函数
1. makefile中提供了很多函数
2. 在makefile中所有的函数都是有返回值的。
3. 这个变量`obj=add.o main.o`,如果项目中有n个.c，这里就要写n个.o
4. 函数调用样式：`$(函数名 参数， 参数, ...)`
5. 这样就可以使用makefile中的函数
    
    ```
    target=app
    //获取指定目录下的所有.c文件
    //&(函数名 路径+文件类型)  
    //查找某个目录下面的某种类型的文件
    src=$(wildcard ./*.c)
    //将某个目录下的所有.c，替换成某个 目录下的所有.o
    obj=$(patsubst ./%.c, ./%.o, $(src))
    CC=gcc
    CPPFLAGS = -I
    $(target):$(obj)
            $(CC) $(obj) -o $(target)
     %.o:%.c
             $(CC) -c $< -o $@
    ```
5. 每次修改源文件，再次执行make之前，都要把之前生成的.o与可执行文件app全部删除，才能重新执行make，这个很麻烦，也能通过makefile设置，新增一条规则如下：
    
    ```
    //防止当前目录下有个同名文件叫clean,如果没这句,执行make clean就不行了
    .PHYONY:clean
    //删除所有.o文件和最终的可执行目标文件target
    clean:
          rm $(obj) $(target) -f
    ```   
    
    1. 保存makefile后直接输入命令`make clean`即可
    2. `make 目标`，只执行makefile的对应目标命令。
6. makefile最终内容如下：
    
    ```
    #obj=add.o main.o
    
    target=app
    src=$(wildcard ./*.c)
    obj=$(patsubst ./%.c, ./%.o, $(src))
    CC=gcc
    CPPFLAGS = -I
    $(target):$(obj)
            $(CC) $(obj) -o $(target)
    %.o:%.c
            $(CC) -c $< -o $@
    .PHYONY:clean
    clean:
            rm $(obj) $(target) -f
    ```



