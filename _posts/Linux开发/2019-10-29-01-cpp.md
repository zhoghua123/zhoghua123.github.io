---
layout: post
title: makefile
category: Linux开发
tags: Linux开发
description: Linux开发
--- 

## makefile
1. 什么是makefile？
    1. 项目代码管理工具，用于管理我们程序的源代码。
2. 为何需要makefile？
    1. 比如程序有100个文件，那么编译时：`gcc *c .....`,由于各个文件的目录还不同，那么gcc就很长，很复杂
    2. 因此makefile就是为了解决这个问题而生
    3. makefile可以把所有代码编译的命令都写到makefile中
    4. 只需要执行makefile命令就可以完成编译了
3. makefile这么复杂谁来编写？
    1. 通常不需要普通程序员编写，通常是项目管理人编写
    2. 普通程序员只需要编写自己的模块
4. makefile的本质
    1. 就是一个文件，内部写了编译程序的步骤
    
### 编写一个最简单的makefile
1. makefile的命名规则
    1. 方式1：`makefile`
    2. 方式2：`Makefile`
2. 创建makefaile文件:`vi makefile`
3. makefile编写规则
    1. 规则中的三要素
        1. 目标
        2. 依赖
        3. 命令
    2. 固定格式：
        ```
        目标:依赖条件
            (tab缩进)命令
        ```
    3. 代码举例：
        
        ```
        app:add.c main.c
            gcc add.c  main.c -o app    
        ```
    4. 编写完后，保存退出vi
4. 执行makefile
    1. 输入make，就能输出makefile中编写的编译命令,然后执行，并且生成可执行文件app
        
        ```
        gcc add.c  main.c -o app 
        ```
5. 上面的写法有个缺点，每次执行一次make都会吧所有的文件都编译一遍，如果我仅仅修改了其中的某一个文件，其他文件都会重新编译，比较浪费,因此需要优化makefile，修改如下
    
    ```
    app:add.o main.o
        gcc add.o main.o -o app
    main.o:main.c
        gcc -c main.c    
    add.o:add.c
        gcc -c add.c
    ```
    
    1. 上面一共有3条规则
        1. 第一条规则用于生成终极目标app
        2. 下面的几个叫做子目标，下面的子目标跟第一个目标的依赖有关系
        3. 当要生成终极目标app时，他就会查找依赖，发现依赖add.o没有，向下查找对应的规则，直到查找到有一条规则是生成这个依赖的，main.o也一样。
        4. 子目标就是用来生成第一个目标的依赖条件的。
        5. 当所有的依赖都找到了，才会执行第一个目标下面的命令
        6. 再次输入make命令时执行如下：
        
            ```
            gcc -c main.c
            gcc -c add.c
            gcc add.o -o app
            ```
        7. 如果修改了main.c,然后再执行make
            
            ```
            gcc -c main.c
            gcc add.o -o app
            ```
        8. 说明已经实现了目的
    2. makefile怎么知道哪些文件被修改了呢？
        1. 如果没有修改，那么终极目标文件app肯定是时间最晚的；一旦某个.c文件被修改，那么这个文件的时间就大于目标文件app
        2. 用终极目标的app时间与其他.c文件时间进行比较，来进行判断
        3. 如下图
            ![图4](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/linux-05.png)



