---
layout: post
title: iOS开发面试整理之专题篇
category: iOS小知识
tags: iOS小知识
description: iOS小知识
---

## Runloop篇
1. **什么是RunLoop**?
    1. 从字面意思看:运行循环/跑圈
    2. 其实它内部就是do-while循环,在这个循环内部不断地处理各种任务(比如:source/Timer/Observer)
    3. 一个线程对应一个runloop,主线程的runloop默认已经启动,子线程的runloop需要自己手动启动(调用run方法)
    4. RunLoop只能选择一个Mode启动,如果当Mode中没有任何source(source0/source1),Timer,那么就直接退出RunLoop
2. **自动释放池什么时候释放**?
    1. 通过Observer监听RunLoop的状态,一旦监听到RunLoop即将进入休眠等待状态,就释放自动释放池(`KCFRunLoopBeforeWaiting`)
    2. 详细分析
        1. 分两种情况：手动干预释放和系统自动释放
            1. 手动干预释放就是指定autoreleasepool(手动创建的),当前作用域大括号结束就立即释放
            2. 系统自动去释放:不手动指定autoreleasepool,Autorelease对象会在当前的 runloop 迭代结束时释放
                1. kCFRunLoopEntry(1):第一次进入会自动创建一个autorelease
                2. kCFRunLoopBeforeWaiting(32):进入休眠状态前会自动销毁一个autorelease,然后重新创建一个新的autorelease
                3. kCFRunLoopExit(128):退出runloop时会自动销毁最后一个创建的autorelease
3. **在开发中如何使用RunLoop?什么应用场景?**
    1. 开启一个常驻线程(让一个子线程不进入消亡状态,等待其他的线程发来消息,处理其他事件) 
    2. 在子线程中开启一个定时器 在子线程中进行一些长期监控
    3. 可以控制定时器在特定模式下运行
    4. 可以让某些事件(行为/任务)在特定模式下执行
    5. 可以添加Observer监听runloop的状态,比如监听点击事件的处理(在所有点击事件之前做一些事情)     
4. **NSTimer定时器**
    1. 定时器默认情况下是添加在RunLoop的默认(Default)模式下的,因此当滚动界面时,定时器会停止,滚动停止定时器重新工作
    2. 解决办法:
        1. 使用将定时器添加到占位(CommonMode)模式中
        2. 使用GCD定时,GCD的定时器不受runLoop的Mode影响(滚动界面时,定时器不受影响)GCD定时器实现不一样,GCD比NSTimer准确
    3. 可以添加NSTimer到指定的Mode中,比如:滚动开始就有作用
    4. NSTimer会保留目标对象,如果定时器重复定时(反复执行任务),容易引入保留环,一次性的定时器执行完会自动失效调用invalidate
    
## Runtime篇
1. **使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？**
    1. 无论在MRC下还是ARC下均不需要,被关联的对象在生命周期内要比对象本身释放的晚很多，它们会在被 NSObject -dealloc 调用的object_dispose()方法中释放
    2. 对象的内存销毁时间表，分四个步骤
        1. 调用 -release ：引用计数变为零
            1. 对象正在被销毁，生命周期即将结束. 
            2. 不能再有新的 __weak 弱引用，否则将指向 nil.
            3. 调用 [self dealloc]
        2. 父类调用 -dealloc 
            1. 继承关系中最直接继承的父类再调用 -dealloc 
            2. 如果是 MRC 代码 则会手动释放实例变量们（iVars）
            3. 继承关系中每一层的父类 都再调用 -dealloc
        3. NSObject 调 -dealloc 
            1. 只做一件事：调用 Objective-C runtime 中object_dispose() 方法
        4. 调用 object_dispose()
            1. 为 C++ 的实例变量们（iVars）调用 destructors
            2. 为 ARC 状态下的 实例变量们（iVars） 调用 -release 
            3. 解除所有使用 runtime Associate方法关联的对象 
            4. 解除所有 __weak 引用 
            5. 调用 free()
2. **能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？**
    1. 不能向编译后得到的类中增加实例变量；能向运行时创建的类中添加实例变量；
    2. 分析如下：
        1. 因为编译后的类已经注册在runtime中，类结构体中的objc_ivar_list 实例变量的链表和instance_size实例变量的内存大小已经确定，同时runtime 会调用class_setIvarLayout 或 class_setWeakIvarLayout来处理strong weak引用，所以不能向存在的类中添加实例变量
        2. 运行时创建的类是可以添加实例变量，调用 class_addIvar函数，但是得在调用objc_allocateClassPair之后，objc_registerClassPair之前，原因同上。
3. **runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）**
    1. 每一个类对象中都一个对象方法列表（对象方法缓存）
    2. 类方法列表是存放在类对象中isa指针指向的元类对象中（类方法缓存）
    3. 方法列表中每个方法结构体中记录着方法的名称,方法实现,以及参数类型，其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现.
    4. 当我们发送一个消息给一个NSObject对象时，这条消息会在对象的类对象方法列表里查找
    5. 当我们发送一个消息给一个类时，这条消息会在类的Meta Class对象的方法列表里查找
    6. 具体实现
        1. 在寻找IMP的地址时，runtime提供了两种方法,而根据官方描述，第一种方法可能会更快一些 
        2. 通过该传入的参数不同，找到不同的方法列表，方法列表中保存着下面方法的结构体，结构体中包含这方法的实现，selector本质就是方法的名称，通过该方法名称，即可在结构体中找到相应的实现。 
          
            ```
            IMP class_getMethodImplementation(Class cls, SEL name);
            IMP method_getImplementation(Method m)
            ```
        3. 第一种
            1. 获取实例方法和类方法
                
                ```
                //类方法（假设有一个类A）
      class_getMethodImplementation(objc_getMetaClass("A"),@selector(methodName));
                //实例方法
                class_getMethodImplementation([A class],@selector(methodName));
                ```
        4. 第二种
            
            ```
            //类方法
            Method class_getClassMethod(Class cls, SEL name)
        //实例方法
        Method class_getInstanceMethod(Class cls, SEL name)
        //获取IMP地址
        IMP method_getImplementation(Method m)
            ```

## 加密篇
1. 加密分为对称加密和非对称加密（又叫公钥密码）
    2. 对称加密：加解密用一个密钥
        1. 常见的对称加密有：DES、3DES、AES
        2. DES加密
            1. 密钥长度为56bit,本来也是有64位，但是每隔7bit有个错误校验位
            2. 每次只能加密64bit数据，需要数据分组加密
            3. 3DES，DES3重加密
        3. AES加密
            1. 密钥长度有128、192、256bit三种
            2. 非对称加密最安全的一种方式
    3. 非对称加密：由于密钥配送泄露的问题，出现了非对称加密
        1. 公钥用来加密，私钥用来解密。
        2. 由消息接收者生成公私钥对，私钥自己保存，公钥公开
        3. 常用的非对称加密有：RSA、ECC
            1. RSA是由3个人做出来的算法。三个人的首字母取名。
    4. 混合密码系统
        1. 对称加密缺点：钥匙配送问题
        2. 非对称加密缺点：加密、解密速度较慢。
        3. 混合密码: 对称加密、非对称加密相结合
            1. 网络上的密码通信所用的SSL/TLS都运用了混合密码系统
            2. 原理
                1. 消息加密：加密通过对称加密，形成加密消息
                2. 钥匙配送：**对称密钥**通过公钥加密，形成密钥消息
                3. 最后发送消息为：对称加密的消息+公钥加密的密码
    5. 单向散列函数(不可逆加密)
        1. 单向散列函数：根据消息内容计算出散列值
        2. 单向散列函数的特点：
            1. **任意长度**的消息，计算出固定长度的散列值
            2. 计算速度快，能快速计算出散列值
            3. 消息不同，散列值也不同
            4. 具备单向性,不可逆的
        3. 常见的单向散列函数
            1. MD4、MD5：产生128bit的散列值
            2. SHA-1: 产生160bit的散列值
            3. SHA-2: SHA-256、SHA-384、SHA-512，散列值长度分别是256bit、384bit、512bit
            4. SHA-3：全新标准
        4. 单向散列函数的作用：防止数据被篡改
            1. 通常的笨方法：要防止被篡改，每次必须要拷贝一下源文件放到安全的地方，下次查看时将源文件与拷贝副本进行比较。
            2. 如果源文件非常大，这样耗内存
            3. 解决办法：将源文件的单向散列值保存到安全地方，下次拿到源文件生成散列值与曾经保存的进行比对。
    6. 数字签名
        1. 问题：公钥加密不能解决消息被串改问题，因为公钥公开任何人都可以加密，私钥在消息接收者手里。
        2. 解决办法：**消息发送者**生成公钥、私钥，并且将公钥公开，**消息发送者**用**私钥**加密，**消息接收者**用**公钥**解密，这就叫**数字签名**
        3. 数字签名与公钥密码区别：
            1. 数字签名是为了防止消息不被串改，不管保密性。
            2. 公钥密码是为了防止消息被查看，不管是否被串改。
            3. **数字签名：**私钥加签，公钥验签； **公钥密码：**私钥解密，公钥加密。
        4. 存在问题：
            1. 我们知道直接用公钥加密消息整体是**非常耗时**的，公钥密码采用了混合密码系统解决这个问题的，那数字签名怎么办呢？
            2. 解决：
                1. 生成消息体的单向散列函数（时间快）
                2. 用私钥加签单向散列函数值（函数值小）
        5. 消息发送者最终发送的是：**消息明文+消息函数散列值的签名**
        6. 数字签名的作用：保证消息的完整性、防止消息被篡改
    7. 证书：
        1. 公钥密码与数字签名都有一个共同的bug，如果在发送公钥的过程中公钥被中间人拦截，替换成中间人的了呢？ 那么消息发送者或者验签者用的公钥是中间人的，那么就出现了问题。
            1. 公钥加密：消息发送者加密的消息，只能由中间人解密
            2. 数字签名：中间人串改成自己的签名，消息验签者可以接受
        2. 证书就是为了解决这个问题的
        3. 证书机构CA用自己的私钥加签用户的公钥生成证书放到数据库，使用者到证书机构下载证书，通过证书机构的公钥验证证书的合法性(证书内部的公钥是否合法、被替换)。
            1. 证书的内容包括：申请者的公钥明文、申请者的信息、申请者公钥明文加签的签名


## 线程篇
1. **线程死锁**
    1. 结论:  **一个线程**里面，**同步（sync）**调用**同一个串行队列**会死锁
    2. 代码举例：
        1. 例1：主线程中同步执行主队列（主队列是串行队列）
            
            ```
            - (void)viewDidLoad {
                [super viewDidLoad];
                NSLog(@"1");
                //卡死
                dispatch_sync(dispatch_get_main_queue(), ^{
                    NSLog(@"2");
                });
                NSLog(@"3");
            }
            ```
        2. 例2：主线程中异步执行主队列（主队列是串行队列）
            
            ```
            - (void)viewDidLoad {
                [super viewDidLoad];
                NSLog(@"1");
                //不会卡死
                dispatch_async(dispatch_get_main_queue(), ^{
                    NSLog(@"2");
                    //卡死
                    dispatch_sync(dispatch_get_main_queue(), ^{
                        NSLog(@"3");
                    });
                    NSLog(@"4");
                });
                NSLog(@"5");
            }
            ```
        3. 例3: 子线程、串行队列，同步执行
            
            ```
            - (void)viewDidLoad {
                [super viewDidLoad];
                //串行队列
                dispatch_queue_t q = dispatch_queue_create("hhhhh", DISPATCH_QUEUE_SERIAL);
                //子线程
                dispatch_async(q, ^{
                    NSLog(@" %@----111", [NSThread currentThread]);
                    //同一个串行队列，同步执行，即同一个线程执行，结果，卡死
                    dispatch_sync(q, ^{
                        NSLog(@" %@----2222", [NSThread currentThread]);
                    });
                });
            }
            ```
        4. 例3: 子线程、并发队列，同步执行
            
            ```
            - (void)viewDidLoad {
                [super viewDidLoad];
                //并发队列
                dispatch_queue_t q = dispatch_queue_create("hhhhh", DISPATCH_QUEUE_CONCURRENT);
                //子线程
                dispatch_async(q, ^{
                    NSLog(@" %@----111", [NSThread currentThread]);
                    //同一个并行队列，同步执行，即同一个线程执行，结果，正常
                    dispatch_sync(q, ^{
                        NSLog(@" %@----2222", [NSThread currentThread]);
                    });
                });
            }
            ```
2. **线程通信**
    1. 从子线程切回到主线程
        
        ```
        dispatch_sync(dispatch_get_main_queue(), ^{ });
        ```
    2. 多个线程间切换执行代码
        1. 在1个进程中，线程往往不是孤立存在的，多个线程之间需要经常进行通信
        2. 线程间通信的体现
            1. 1个线程传递数据给另1个线程
            2. 在1个线程中执行完特定任务后，转到另1个线程继续执行任务
        3. 线程间通信常用方法
            
            ```
            - (void)performSelectorInBackground:(SEL)aSelector withObject:(id)arg;
            - (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait;
            - (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait;
            ```
   


