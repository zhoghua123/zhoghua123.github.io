---
layout: post
title: iOS底层-Runtime系列一
category: iOS底层
tags: iOS底层
description: iOS底层
--- 

## 简介
1. Objective-C是一门动态性比较强的编程语言，跟C、C++等语言有着很大的不同
2. Objective-C的动态性是由Runtime API来支撑的
3. Runtime API提供的**接口**基本都是C语言的，**源码**由C\C++\汇编语言编写

## isa

### 位域
1. 代码示例: Person类
    
    ```
    @interface Person : NSObject
    @property (nonatomic, assign) BOOL tall;
    @property (nonatomic, assign) BOOL rich;
    @property (nonatomic, assign) BOOL handsome;
    @end
    ```
    
    1. 如果当前Person使用3个BOOL属性，那么这3个属性将占据3个字节，那么我们可以不可以用一个字节来表达这3个属性的值呢？以便于节省内存
    2. 可以申请一个char成员变量,占据1个字节（8个二进制位），可以指定其中的某3个二进制位分别表示3个属性的值，比如后三位： 0b 0000 0111
    3. 那么如何取出相应的二进制位呢？
        1. 使用二进制按位与运算： &
    4. 如何设置相应的二进制位呢？
        1. 使用二进制按位或运算： | 
2. 优化代码：
    
    ```
    @interface Person : NSObject
    - (void)setTall:(BOOL) tall;
    - (BOOL)isTall;
    
    - (void)setRich:(BOOL) rich;
    - (BOOL)isRich;
    
    - (void)setHandsome:(BOOL) handsome;
    - (BOOL)isHandsome;
    @end
    
    //Mask掩码，一般用来与&运算
    #import "Person.h" 
    
    //#define TallMask 1
    //#define RichMask 2
    //#define HandsomeMask 4
    
    //#define TallMask 0b00000001
    //#define RichMask 0b00000010
    //#define HandsomeMask 0b00000100
    
    #define TallMask  (1<<0)      //1左移0位
    #define RichMask  (1<<1)      //1左移1位
    #define HandsomeMask  (1<<2)  //1左移2位
    
    @interface Person ()
    {
        char _tallRichHandsome;//二级制后3位分别代表：handsome、rich、tall, 0b 0000 0111
    }
    
    @end
    
    @implementation Person
    
    - (instancetype)init
    {
        self = [super init];
        if (self) {
            _tallRichHandsome = 0b00000111;
        }
        return self;
    }
    
    - (void)setTall:(BOOL) tall{
        if (tall) {
            _tallRichHandsome |= TallMask;
        }else{
            _tallRichHandsome &= ~TallMask;
        }
        
    }
    - (BOOL)isTall{
        
        return !!(_tallRichHandsome & TallMask);
    }
    
    - (void)setRich:(BOOL) rich{
        if (rich) {
            _tallRichHandsome |= RichMask;
        }else{
            _tallRichHandsome &= ~RichMask;
        }
    }
    - (BOOL)isRich{
        
         return !!(_tallRichHandsome & RichMask);
    }
    
    - (void)setHandsome:(BOOL) handsome{
        
        if (handsome) {
            _tallRichHandsome |= HandsomeMask; // _tallRichHandsome= _tallRichHandsome | HandsomeMask
        }else{
            //先将HandsomeMask按位取反，然后在于_tallRichHandsome，进行&运算
            _tallRichHandsome &= ~HandsomeMask;
        }
    }
    /**
     0000 0000
     &
     0000 1000
     */
    - (BOOL)isHandsome{
        
         return !!(_tallRichHandsome & HandsomeMask);
    }
    @end
    
    //测试
    Person *person = [[Person alloc] init];
    [person setRich:NO];
    NSLog(@"%d=%d=%d",person.isTall,person.isRich,person.isHandsome);
    ```
3. 使用结构体的位域功能
    
    ```
    #import "Person.h"

    @interface Person ()
    {
        //定义一个结构体类型成员变量
        //结构体支持位域技术
        struct{
            char tall : 1; //代表只占用1个二进制位,不用管左边的char类型，以右边的 :1 为准
            char rich : 1;
            char handsome : 1;
        }_tallRichHandsome;//变量整体占用一个字节：0b00000000，第一个成员在最后一位，往下依次
    }
    @end
    
    @implementation Person
    
    
    - (void)setTall:(BOOL) tall{
        
        _tallRichHandsome.tall = tall;
    }
    - (BOOL)isTall{
        //如果tall值为1，为何返回为-1？
        //_tallRichHandsome.tall是一个二进制位1，而返回值是BOOL，如果强制转换为BOOL，那么它会将剩余的7位全部补为1
            //就变成： 0b 1111 1111
    //    return _tallRichHandsome.tall;
        //2次取反可以解决这个问题: !_tallRichHandsome.tall 返回值一定是一个BOOL，非0即真。 再次！就是原值0或1
        return  !!_tallRichHandsome.tall;
    }
    
    - (void)setRich:(BOOL) rich{
       _tallRichHandsome.rich = rich;
    }
    - (BOOL)isRich{
        
        return !!_tallRichHandsome.rich;
    }
    
    - (void)setHandsome:(BOOL) handsome{
        
        _tallRichHandsome.handsome = handsome;
    }
    
    - (BOOL)isHandsome{
        
        return !!_tallRichHandsome.handsome;
    }
    @end
    
    //使用        
    Person *person = [[Person alloc] init];  
    [person setRich:YES];
    [person setHandsome:YES];
    //0=-1=-1 为何是-1呢？
    NSLog(@"%d=%d=%d",person.isTall,person.isRich,person.isHandsome);
    ```
    
### 联合体、结构体位域表示
1. 示例：
    
    ```
    #import "Person.h"
    
    #define TallMask  (1<<0)      //1左移0位
    #define RichMask  (1<<1)      //1左移1位
    #define HandsomeMask  (1<<2)  //1左移2位
    
    @interface Person ()
    {
        //联合体成员_tallRichHandsome
        union{
            char bits;//占据一个字节
            //这个没有用，仅仅是为了增加可读性，就是告诉bits这个字节数据哪些二进制位表示什么
            struct{
                char tall : 1; //bits二进制位最后一位是tall
                char rich : 1; //bits二进制位倒数第二位是rich
                char handsome : 1;//bits二进制位倒数第三位是handsome
            };
        }_tallRichHandsome;
        
        //等价
        //    char _tallRichHandsome;
          
    }
    @end
    
    @implementation Person
    - (void)setTall:(BOOL) tall{
        if (tall) {
            _tallRichHandsome.bits |= TallMask;
        }else{
            _tallRichHandsome.bits &= ~TallMask;
        }
    }
    - (BOOL)isTall{
        
        return !!(_tallRichHandsome.bits & TallMask);
    }
    
    - (void)setRich:(BOOL) rich{
        if (rich) {
            _tallRichHandsome.bits |= RichMask;
        }else{
            _tallRichHandsome.bits &= ~RichMask;
        }
    }
    - (BOOL)isRich{
        
        return !!(_tallRichHandsome.bits & RichMask);
    }
    
    - (void)setHandsome:(BOOL) handsome{
        
        if (handsome) {
            _tallRichHandsome.bits |= HandsomeMask;
        }else{
            _tallRichHandsome.bits &= ~HandsomeMask;
        }
    }
    
    - (BOOL)isHandsome{
        
        return !!(_tallRichHandsome.bits & HandsomeMask);
    }
    @end
    ```
    
    1. 分析：
        1. 上面联合体成员变量_tallRichHandsome，等价于直接写一个 _tallRichHandsome成员`char _tallRichHandsome;`,那么为何偏要用一个union类型的呢？
        2. 因为如果仅仅是`char _tallRichHandsome;`成员变量，那么如何告诉别人这个字节的8位中哪一位分别代表什么呢？
        3. 联合体union的**内存公用**技术，结构体的struct**位域**技术，同时可以满足：**不占用多余内存，又能直接说明二进制位每一位都代表什么**
            1. union内部尽管有2个成员：一个是bits，一个是无名称的struct，bits是char类型占据1个字节，struct仅仅只是3个二进制位，内存对齐后则也是1个字节，因此union类型的成员整体还是占用一个字节
        4. union中的无名的struct成员，仅仅是为了增加可读性，就是告诉bits这个字节数据哪些二进制位表示什么


