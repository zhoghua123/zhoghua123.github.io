---
layout: post
title: iOS底层-Block系列二
category: iOS底层
tags: iOS底层
description: iOS底层
---

## block的copy 
1. 在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上，比如以下情况
    1. block作为函数返回值时
    2. 将block赋值给__strong指针时
    3. block作为Cocoa API中方法名含有usingBlock的方法参数时
    4. block作为GCD API的方法参数时
2. MRC下block属性的建议写法
    1. `@property (copy, nonatomic) void (^block)(void);`
3. ARC下block属性的建议写法
    1. `@property (strong, nonatomic) void (^block)(void);`
    2. `@property (copy, nonatomic) void (^block)(void);`
4. 代码举例：
    
    ```
    //1. block作为函数返回值
    typedef void(^Block)(void);
    Block myblocfunc(){
        int a = 10;
        //这个block本来是一个栈block
        return ^{
            NSLog(@"===%d",a);
        };
    }
    
    int main(int argc, const char * argv[]) {
        @autoreleasepool {
            //打印结果：====__NSMallocBlock__
            //说明变为堆block
    //        NSLog(@"====%@",[myblocfunc() class]);
            
            //2. 强引用
            //OC中,定义的变量就是一个强引用
            int a = 0;
            Block block2 = ^{
                NSLog(@"====%d",a);
            };
            //ARC: __NSMallocBlock__  MRC: __NSStackBlock__
            NSLog(@"====%@",[block2 class]);
            
            //3. Cocoa API中方法名含有usingBlock的方法参数时
            NSArray *arr = @[];
            [arr enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
                
            }];
            //4. 作为GCD API的方法参数时
            static dispatch_once_t onceToken;
            dispatch_once(&onceToken, ^{
                
            });
        }
        return 0;
    }
    ```


