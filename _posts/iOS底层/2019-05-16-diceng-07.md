---
layout: post
title: iOS底层-Block系列二
category: iOS底层
tags: iOS底层
description: iOS底层
---

## block的copy 
1. 在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上，比如以下情况
    1. block作为函数返回值时
    2. 将block赋值给__strong指针时
    3. block作为Cocoa API中方法名含有usingBlock的方法参数时
    4. block作为GCD API的方法参数时
2. MRC下block属性的建议写法
    1. `@property (copy, nonatomic) void (^block)(void);`
3. ARC下block属性的建议写法
    1. `@property (strong, nonatomic) void (^block)(void);`
    2. `@property (copy, nonatomic) void (^block)(void);`
4. 代码举例：
    
    ```
    //1. block作为函数返回值
    typedef void(^Block)(void);
    Block myblocfunc(){
        int a = 10;
        //这个block本来是一个栈block
        return ^{
            NSLog(@"===%d",a);
        };
    }
    
    int main(int argc, const char * argv[]) {
        @autoreleasepool {
            //打印结果：====__NSMallocBlock__
            //说明变为堆block
    //        NSLog(@"====%@",[myblocfunc() class]);
            
            //2. 强引用
            //OC中,定义的变量就是一个强引用
            int a = 0;
            Block block2 = ^{
                NSLog(@"====%d",a);
            };
            //ARC: __NSMallocBlock__  MRC: __NSStackBlock__
            NSLog(@"====%@",[block2 class]);
            
            //3. Cocoa API中方法名含有usingBlock的方法参数时
            NSArray *arr = @[];
            [arr enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
                
            }];
            //4. 作为GCD API的方法参数时
            static dispatch_once_t onceToken;
            dispatch_once(&onceToken, ^{
                
            });
        }
        return 0;
    }
    ```

## block对 对象类型的auto变量 的捕获
1. 当block内部访问了对象类型的auto变量时
    1. 如果block是在栈上，将不会对auto变量产生强引用，auto变量会在block之前释放
    2. 如果block被拷贝到堆上
        1. 会调用block内部的copy函数
        2. copy函数内部会调用_Block_object_assign函数
        3. _Block_object_assign函数会根据auto变量的修饰符（__strong、__weak、__unsafe_unretained）做出相应的操作（如果auto变量是强引用，就retain），形成强引用（retain）或者弱引用
    3. 如果block从堆上移除
        1. 会调用block内部的dispose函数
        2. dispose函数内部会调用_Block_object_dispose函数
        3. _Block_object_dispose函数会自动释放引用的auto变量（release）
2. 如下示例：
    
    ```
    #import <Foundation/Foundation.h>
    #import "Person.h"
    int main(int argc, const char * argv[]) {
        @autoreleasepool {
            //定义一个block变量，在ARC下，任何一个局部变量都是强引用__strong
            //在MRC下是弱引用
            void (^block)(void);//定义block变量
            //作用域
            {
                //对象类型的auto变量
                Person *person = [[Person alloc] init];
                person.age =10;
                
                //弱引用
                //__weak Person *weakPerson = person;
                //ARC下这个block会调用copy，放到堆上； MRC下这个block在栈上
                block = ^{
                    NSLog(@"====%d",person.age);
                };
            }
            
            //此处打断点
            NSLog(@"---------------");
        }
        return 0;
    }
    ```
3. 如果代码中有__weak字段，转化为C++代码时注意：
    1. 使用原来的方式会报错： `cannot create __weak reference in file using manual reference`
    2. 解决方案：支持ARC、指定运行时系统版本，比如: `pxcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m`

## __block的本质



