---
layout: post
title: iOS底层-Runtime系列三
category: iOS底层
tags: iOS底层
description: iOS底层
--- 

## super的本质
1. 实例：
    
    ```
    #import "Student.h"
    @implementation Student
    
    - (instancetype)init
    {
        self = [super init];
        if (self) {
            NSLog(@"%@",[self class]);//Student
            NSLog(@"%@",[self superclass]);//Person
            NSLog(@"----------");
            NSLog(@"%@",[super class]);//Student
            NSLog(@"%@",[super superclass]);//Person
        }
        return self;
    }
    @end
    ```
    
    1. 为何`[super class]`与`[super superclass]`返回的是Student与Person，难道不该是Person与Nsobject吗？
2. 分析super的底层：将下面代码编译成C++,核心代码如下
    
    1. OC代码
    
        ```
        #import "Student.h"
        @implementation Student
        
        -(void)run{
            [super run];
        }
        @end
        ```
    2. C++核心代码如下
        
        ```
        //super结构体
        struct __rw_objc_super {
        struct objc_object *object;
        struct objc_object *superClass;
        __rw_objc_super(struct objc_object *o, struct objc_object *s) : object(o), superClass(s) {}
        };
         
         //run函数
        static void _I_Student_run(Student * self, SEL _cmd) {
         //消息发送
        ((void (*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super){(id)self, (id)class_getSuperclass(objc_getClass("Student"))}, sel_registerName("run"));
        }
        
        ```
        
        1. 简化
            
            ```
             //简化
            struct __rw_objc_super arg = {
            self,
            class_getSuperclass(objc_getClass("Student")) //本质就是[Person class];
            };
             
            //objc_msgSendSuper(arg, sel_registerName("run"));
             
            objc_msgSendSuper(arg, @selector(run));
            ```
3. objc公开源码分析：
    1. 找到objc_super结构体对象的定义
        
        ```
        /// Specifies the superclass of an instance.
        struct objc_super {
            /// Specifies an instance of a class.
            //一个类的实例
            __unsafe_unretained _Nonnull id receiver;
            /// Specifies the particular superclass of the instance to message.
            //一个类实例的父类，而且仅仅是第一个父类
            __unsafe_unretained _Nonnull Class super_class;   //哪里去搜索方法的实现
            /* super_class is the first class to search */
        };
        ```
4. 分析：
    1. `[super class]`,本质是调用这个函数：
        
        ```
        OBJC_EXPORT void
objc_msgSendSuper(void /* struct objc_super *super, SEL op, ... */ )
        ```
    2. 第一个参数是`objc_super`结构体对象
        
        ```
        {
            self,
            [Person class]
        }
        ```
    3. **`[super class]`本质是：**
        
        ```
        struct objc_super arg = {
            self,
            [Person class]
        };
        objc_msgSendSuper(arg, @selector(run));
        ```
5. 最开始的实例本质如下：
    
    ```
    - (instancetype)init
    {
        self = [super init];
        if (self) {
            NSLog(@"%@",[self class]);//Student
            NSLog(@"%@",[self superclass]);//Person
            NSLog(@"----------");
            //本质：objc_msgSendSuper({self,[Student class]},@selector(class));
            NSLog(@"%@",[super class]);//Student
            //本质：objc_msgSendSuper({self,[Student superclass]},@selector(class));
            NSLog(@"%@",[super superclass]);//Person
        }
        return self;
    }
    ```
6. 总结
    1. `[super message]`的底层实现
        1. 消息接收者receiver仍然是子类对象
        2. 从父类开始查找方法
7. 注意：class与superclass方法
    1. 都是在NSObject.mm中实现的
    2. 在开源objec中的NSObject.mm可以查到：
        
        ```
        //class的底层实现
        //因此class这个方法的返回值取决于self，即receiver
        -(Class)class{
            return  object_getClass(self);
        }
        //superclass的底层实现
        -(Class)superclass{
            return  class_getSuperclass(object_getClass(self));
        }
        ```
8. 汇编本质（以这个为准）
    1. super调用，底层会转换为objc_msgSendSuper2函数的调用，接收2个参数
        1. struct objc_super2
        2. SEL
    2. 与编译成C++区别，名称不一样（objc_msgSendSuper2、objc_super2）
        
## isMemberOfClass、isKindOfClass
1. 这两个方法在objc开源的NSObject.mm中已经开源，如下：
    
    ```
    //object_getClass这个函数如果参数cls是类对象那么返回的是元类对象了
    + (BOOL)isMemberOfClass:(Class)cls {
    return object_getClass((id)self) == cls;
    }
     
    - (BOOL)isMemberOfClass:(Class)cls {
    return [self class] == cls;
    }
     
    //object_getClass这个函数如果参数cls是类对象那么返回的是元类对象了
    + (BOOL)isKindOfClass:(Class)cls {
    for (Class tcls = object_getClass((id)self); tcls; tcls = tcls->superclass) {
    if (tcls == cls) return YES;
    }
    return NO;
    }
     
    - (BOOL)isKindOfClass:(Class)cls {
    for (Class tcls = [self class]; tcls; tcls = tcls->superclass) {
    if (tcls == cls) return YES;
    }
    return NO;
    }
    ```
    
    1. 对象方法：
        
        ```
        - isMemberOfClass ：左边的对象，是否是右边的类型
        - isKindOfClass ：边的对象，对否是左右边的类型，或者是他的子类型 
        ```
    2. 类方法
        
        ```
        + isMemberOfClass ：左边类的元类，是否是右边的类型
        + isKindOfClass ： 左边类的元类，对否是右边的类型，或者是他的子类型
        ```
2. 示例：
        
    ```
    /*********对象方法**********/
    //- isMemberOfClass ：左边的对象，是否是右边的类型
    // - isKindOfClass ： 左边的对象，对否是右边的类型，或者是他的子类型
    id person = [[Person alloc] init];
    NSLog(@"====%d",[person isMemberOfClass:[Person class]]);  //1
    NSLog(@"====%d",[person isMemberOfClass:[NSObject class]]); //0
    
    NSLog(@"====%d",[person isKindOfClass:[Person class]]);  //1
    NSLog(@"====%d",[person isKindOfClass:[NSObject class]]); //1
    
    
    /*********类方法**********/
    //+ isMemberOfClass ：左边类的元类，是否是右边的类型
    // + isKindOfClass ： 左边类的元类，对否是右边的类型，或者是他的子类型
    NSLog(@"====%d",[Person isMemberOfClass:[Person class]]);  //0
    //左边传类，右边传元类才是正确的比较
    NSLog(@"====%d",[Person isMemberOfClass:object_getClass([Person class])]);  //1
    NSLog(@"====%d",[Person isMemberOfClass:[NSObject class]]); //0
    
    
    
    NSLog(@"====%d",[Person isKindOfClass:[Person class]]);  //0
    //NSObject的元类等于它本身
    NSLog(@"====%d",[Person isKindOfClass:[NSObject class]]); //1
    ```
3. 总结：
    1. 区别：
        1. `isMemberOfClass`：判断两个类是否正好相等
        2. `isKindOfClass`：判断2个类是否是继承体系
    3. 如何使用:(两个方法同样适用)
        1. 如果是对象方法：**左边一定要是实例对象，右边参数传类对象**
        2. 如果是类方法：**左边一定是类，右边参数传元类对象**


## LLVM的中间代码（IR）
1. Objective-C在变为机器代码之前，会被LLVM编译器转换为中间代码（Intermediate Representation）(**注意了，可不是转成C++代码**)
    1. OC->llvm转成的中间代码->汇编->机器码
    2. C++仅仅是OC底层方法的实现
2. 可以使用以下命令行指令生成中间代码(.ll文件)
    
    ```
    clang -emit-llvm -S main.m
    ```
3. .ll文件内部是一种全新的语法
    
    ```
    @ - 全局变量
    % - 局部变量
    alloca - 在当前执行的函数的堆栈帧中分配内存，当该函数返回到其调用者时，将自动释放内存
    i32 - 32位4字节的整数
    align - 对齐
    load - 读出，store 写入
    icmp - 两个整数值比较，返回布尔值
    br - 选择分支，根据条件来转向label，不根据条件跳转的话类似 goto
    label - 代码标签
    call - 调用函数
    ```
4. 具体可以参考官方文档：[https://llvm.org/docs/LangRef.html](https://llvm.org/docs/LangRef.html)


