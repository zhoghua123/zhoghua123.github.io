---
layout: post
title: iOS底层-isa指针、class结构
category: iOS底层
tags: iOS底层
description: iOS底层
---

## isa指针
1. isa指针
    1. instance的isa指向class
        1. 当调用对象方法时，通过instance的isa找到class，最后找到对象方法的实现进行调用
    2. class的isa指向meta-class
        1. 当调用类方法时，通过class的isa找到meta-class，最后找到类方法的实现进行调用
        
        ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/diceng03.png)
2. superclass指针
    1. class对象的superclass指针 
        1. 当Student的instance对象要调用Person的对象方法时，会先通过isa找到Student的class，然后通过superclass找到Person的class，最后找到对象方法的实现进行调用
            
            ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/diceng04.png)
    2. meta-class对象的superclass指针 
        1. Student的class要调用Person的类方法时，会先通过isa找到Student的meta-class，然后通过superclass找到Person的meta-class，最后找到类方法的实现进行调用
            
            ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/diceng05.png)
3. isa、superclass总结 
    * instance的isa指向class
    * class的isa指向meta-class
    * meta-class的isa指向基类的meta-class
    * **基类meta-class的isa指向它自己(基类meta-class)**
    * class的superclass指向父类的class
        * 如果没有父类，superclass指针为nil 
    * meta-class的superclass指向父类的meta-class
        * **基类的meta-class的superclass指向基类的class**
    * instance调用对象方法的轨迹
        * isa找到class，方法不存在，就通过superclass找父类
    * class调用类方法的轨迹
        * isa找meta-class，方法不存在，就通过superclass找父类

    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/diceng06.png)
    
    * **疑问：**
        * 通过上面的图，如过一个类调用一个类方法，首先通过当前类的isa指针到当前类的元类中去找，找不到，会通过superclass指针，到其父类的元类中去找，如果父类此时是根类元类，而且根类元类中也没有该类方法，那么按照上图的分析
        * 根类元类会通过它的superclass指针找到它的（根类）类对象，那么问题来了？ 类对象中只有对象方法呀？ 难道会调用对象方法？
        * 结论：**会到根类类对象中寻找同名的对象方法，有就调用，没有就报错**
        * 也就是说，类对象不一定会调用类方法，也有可能调用对象方法
        * 举例证明：
            
            ```
            //NSObject的分类
            #import <Foundation/Foundation.h>
            @interface NSObject (Test)
            +(void)test;
            @end
            
            #import "NSObject+Test.h"
            @implementation NSObject (Test)
            //+(void)test{
            //    NSLog(@"NSObject====+test  ===%p",self);
            //}
            -(void)test{
                NSLog(@"NSObject====-test  ===%p",self);
            }
            @end
            
            //main文件
            #import <Foundation/Foundation.h>
            #import "NSObject+Test.h"
            @interface Person : NSObject
            +(void)test;
            @end
            
            @implementation Person
            
            //+(void)test{
            //    NSLog(@"Person====+test ===%p",self);
            //}
            
            @end
            
            int main(int argc, const char * argv[]) {
                @autoreleasepool {
                    NSLog(@"Person=====%p",[Person class]);
                    NSLog(@"NSObject======%p",[NSObject class]);
                    [Person test];
                    [NSObject test];
                }
                return 0;
             }
             
             //打印
             2019-05-06 11:28:52.147363+0800 03-isa与superclass[3060:191786] Person=====0x1000011e0
            2019-05-06 11:28:52.147779+0800 03-isa与superclass[3060:191786] NSObject======0x7fff9840a140
            2019-05-06 11:28:52.147796+0800 03-isa与superclass[3060:191786] NSObject====-test  ===0x1000011e0
            2019-05-06 11:28:52.147808+0800 03-isa与superclass[3060:191786] NSObject====-test  ===0x7fff9840a140
            ```
            
            1. 从打印可以看出，调用的是`-test`,调用了对象方法

### class结构



