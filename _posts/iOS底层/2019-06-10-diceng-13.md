---
layout: post
title: iOS底层-多线程
category: iOS底层
tags: iOS底层
description: iOS底层
---  

## 简介
1. iOS中的常见多线程方案 
    ![图4](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/diceng20.png)
2. GCD的常用函数 
    1. GCD中有2个用来执行任务的函数
        1. 用同步的方式执行任务
            
            ```
            dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);
            üqueue：队列
            üblock：任务
            ```
        2. 用异步的方式执行任务
            
            ```
            dispatch_async(dispatch_queue_t queue, dispatch_block_t block);
            ```
    2. GCD源码：[https://github.com/apple/swift-corelibs-libdispatch](https://github.com/apple/swift-corelibs-libdispatch)
2. GCD的队列
    1. GCD的队列可以分为2大类型
        1. 并发队列（Concurrent Dispatch Queue）
            1. 可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）
            2. 并发功能只有在异步（dispatch_async）函数下才有效
        2. 串行队列（Serial Dispatch Queue）
            1. 让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）
3. 容易混淆的术语 
    1. 有4个术语比较容易混淆：同步、异步、并发、串行
        1. 同步和异步主要影响：能不能开启新的线程
            1. 同步：在当前线程中执行任务，不具备开启新线程的能力
            2. 异步：在新的线程中执行任务，**具备**开启新线程的能力
        2. 并发和串行主要影响：任务的执行方式
            1. 并发：多个任务并发（同时）执行
            2. 串行：一个任务执行完毕后，再执行下一个任务
4. 各种队列的执行效果 
    ![图4](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/diceng21.png)
    
    1. 注意：**使用sync函数往当前串行队列中添加任务，会卡住当前的串行队列（产生死锁）！！！**
        1. 使用使用sync函数
        2. 当前队列
        3. 当前队列是串行队列
        
    2. 所谓的死锁就是卡主当前的线程崩溃
    
        ```
        - (void)viewDidLoad {
            [super viewDidLoad];
            NSLog(@"==任务1==");
            //1. 拿到当前的队列-主队列
            dispatch_queue_t queue = dispatch_get_main_queue();
            //2. 将block这个任务放到主队列中
            //队列特点：FIFO，先进先出.
            //dispatch_sync:立马在当前线程执行block，执行完才能往下走
            dispatch_sync(queue, ^{
                NSLog(@"==任务2==");
            });
            
            NSLog(@"==任务3==");
        }
        ```
        
        1.  分析为何死锁：
            1. **队列是存放任务的，而且任务是按一定顺序的**
                1. 当前主队列的任务：`1.viewDidLoad 2. 任务2`
            2. **线程是执行任务的，按照队列中的任务顺序执行任务**
                1. 正常情况下：
                    * 执行viewDidLoad任务
                        * 任务1
                        * dispatch_sync函数
                        * 任务3
                    * 执行“任务2”block 
                2. 但是在执行viewDidLoad内部的dispatch_sync函数时，该函数的目的是将“任务2”立刻执行，执行完才能继续执行任务3
                3. 由于任务2是排在viewDidLoad后面的，因此dispatch_sync函数肯定取"任务2"失败，导致函数不能返回，而“任务3”又是在dispatch_sync函数执行完之后才能执行，所以造成了卡死
    3. 如果使用dispatch_async就不会卡死
        
        ```
         /**
         dispatch_async函数不要求立刻在当前线程执行block里面的任务，因此，不会卡线程
         */
        dispatch_async(queue, ^{
             NSLog(@"==任务2==");
        });
        ```
        
        1. 打印：
            
            ```
            ==任务1==
            ==任务3==
            ==任务2==
            ```
    4. 分析死锁的关键：**线程执行的任务顺序 是否跟 队列中存放的任务顺序一致，一致则没问题，不一致则卡住**
    
    

