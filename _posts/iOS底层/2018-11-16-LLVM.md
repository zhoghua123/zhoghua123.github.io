---
layout: post
title: 编译器之王LLVM
category: iOS底层
tags: LLVM
description: LLVM
---

## 引言
1. 做iOS开发我们都知道，Xcode内置有编译器
    1. 打开项目-target->build setting ->搜索compiler（编译器)->能看见编译器就是LLVM
    2. 早期的Xcode（<4）内置的编译器是GCC，后来的就是LLVM

## LLVM简介
1. 什么是LLVM
    1. 官网:[https://llvm.org/](https://llvm.org/)
    2. The LLVM Project is a collection of modular and reusable compiler and toolchain technologies.
    3. 译：LLVM项目是模块化、可重用的编译器以及工具链技术的集合
    4. 美国计算机协会 (ACM) 将其2012 年软件系统奖项颁给了LLVM，之前曾经获得此奖项的软件和技术包括:Java、Apache、 Mosaic、the World Wide Web、Smalltalk、UNIX、Eclipse等等
2. 创始人
    1. Chris Lattner，亦是Swift之父
3. 有些文章把LLVM当做Low Level Virtual Machine(低级虚拟机)的缩写简称，官方描述如下
    1. The name "LLVM" itself is not an acronym; it is the full name of the project.
    2. 译： “LLVM”这个名称本身不是首字母缩略词; 它是项目的全名
4. 学习LLVM编译器有什么用呢？
    1. 我们知道，Xcode内置的是LLVM编译器
    2. 我们写完OC代码后，通过LLVM编译成汇编，然后在编译成二进制可执行文件
    3. 我们知道在编译时，如果我们的代码有明显的语法或者其他非正常的编写，编译器就会提示红色报错，或者黄色警告，这些都是编译器来控制操作的
    4. 因此如果我们学习了编译器语法，那么我们就可以给编译器编写一些插件，让我们的OC代码在编译时按照我们自己的想法编译
        1. 比如：写一个编译器插件用于检查我们写的类命名是否有下划线或者其他非正常字符，如果有，编译时就报错。

## 传统的编译器架构     
![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/llvm01.png)

1. 传统编译器架构通常分为3段
    1. Frontend:前端
        1. 词法分析、语法分析、语义分析、生成中间代码
        2. 我们编写的源码，首先会经过编译器前端(上面操作)生成中间代码
    2.  Optimizer:优化器
        1.  中间代码优化
    3. Backend:后端
        1. 生成机器码

## LLVM架构
![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/llvm02.png)

1. 不同语言他的编译前端不一样，比如C语言用Clang
1. 不同的前端后端使用统一的中间代码LLVM Intermediate Representation (LLVM IR)
2. 如果需要支持一种新的编程语言，那么只需要实现一个新的前端
3. 如果需要支持一种新的硬件设备，那么只需要实现一个新的后端
4. 优化阶段是一个通用的阶段，它针对的是统一的LLVM IR，不论是支持新的编程语言，还是支持新的硬件设备，都不需要对优化阶段做修改
5. 相比之下，**GCC**的前端和后端没分得太开，前端后端耦合在了一起。所以GCC为了支持一门新的语言，或者为了支持一个新的目标平台，就变得特别困难
6. LLVM现在被作为实现各种静态和运行时编译语言的通用基础结构(GCC家族、Java、.NET、Python、Ruby、Scheme、Haskell、D等)
 
## GCC
1. 什么是Clang?
    1. LLVM项目的一个子项目
    2. 基于LLVM架构的C/C++/Objective-C编译器**前端**
    3. 官网:http://clang.llvm.org/
2. 相比于GCC，Clang具有如下优点
    1. 编译速度快:在某些平台上，Clang的编译速度显著的快过GCC(Debug模式下编译OC速度比GGC快3倍)
    2. 占用内存小:Clang生成的AST（语法树）所占用的内存是GCC的五分之一左右
    3. 模块化设计:Clang采用基于库的模块化设计，易于 IDE 集成及其他用途的重用
    4. 诊断信息可读性强:在编译过程中，Clang 创建并保留了大量详细的元数据 (metadata)，有利于调试和错误报告
    5. 设计清晰简单，容易理解，易于扩展增强
3. Clang与LLVM

    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/llvm03.png)
    
    1. 广义的LLVM
        1. 整个LLVM架构
    2. 狭义的LLVM
        1.  LLVM后端(代码优化、目标代码生成等)
    3. 举例：
        ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/llvm04.png)

