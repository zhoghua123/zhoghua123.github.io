---
layout: post
title: iOS底层-多线程(二)
category: iOS底层
tags: iOS底层
description: iOS底层
---  

## iOS中的线程同步方案

1. 将买卖票和存取钱封装到一个基类中
    
    ```
    #import <Foundation/Foundation.h>    
    @interface ZHBaseDemo : NSObject
    /**
     存取钱演示
     */
    -(void)moneyTest;
    /**
     存钱
     */
    -(void)saveMoney;
    /**
     取钱
     */
    -(void)drawMoney;
    /**
     卖一张票
     */
    -(void)saleTicket;
    /**
     卖多张票
     */
    -(void)saleTicketTest;
    @end
  
    
    #import "ZHBaseDemo.h"

    @interface ZHBaseDemo ()
    @property (nonatomic, assign) int ticketsCount;
    @property (nonatomic, assign) int money;
    @end
    
    @implementation ZHBaseDemo
    
    /**
     存取钱演示
     */
    -(void)moneyTest{
        self.money = 100;
        dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
        dispatch_async(queue, ^{
            for (int i =0; i<3; i++) {
                [self saveMoney];
            }
        });
        dispatch_async(queue, ^{
            for (int i =0; i<3; i++) {
                [self drawMoney];
            }
        });
    }
    
    /**
     存钱
     */
    -(void)saveMoney{
      
        int oldMoney = self.money;
        sleep(.2);
        oldMoney+= 50;
        self.money = oldMoney;
        NSLog(@"存50，还剩%d元====%@",oldMoney,[NSThread currentThread]);
       
    }
    /**
     取钱
     */
    -(void)drawMoney{
       
        int oldMoney = self.money;
        sleep(.2);
        oldMoney-= 20;
        self.money = oldMoney;
        NSLog(@"取20，还剩%d元====%@",oldMoney,[NSThread currentThread]); 
    }
    
    /**
     卖一张票
     */
    -(void)saleTicket{
        int oldTicketsCount = self.ticketsCount;
        sleep(.2);
        oldTicketsCount--;
        self.ticketsCount = oldTicketsCount;
        NSLog(@"还剩%d张票====%@",oldTicketsCount,[NSThread currentThread]);
    }
    
    /**
     卖多张票
     */
    -(void)saleTicketTest{
        self.ticketsCount = 15;
        dispatch_async(dispatch_get_global_queue(0, 0), ^{
            for (int i =0; i<2; i++) {
                [self saleTicket];
            }
        });
        dispatch_async(dispatch_get_global_queue(0, 0), ^{
            for (int i =0; i<2; i++) {
                [self saleTicket];
            }
        });
        dispatch_async(dispatch_get_global_queue(0, 0), ^{
            for (int i =0; i<2; i++) {
                [self saleTicket];
            }
        });
    }
    
    @end
    ```

### os_unfair_lock 
1. os_unfair_lock用于取代不安全的OSSpinLock ，从iOS10开始才支持
2. 从底层调用看，等待os_unfair_lock锁的线程会处于休眠状态，并非忙等
3. 需要导入头文件#import <os/lock.h>
4. 代码举例：
    
    ```
    #import "ZHBaseDemo.h"

    @interface OSUnfairLockDemo : ZHBaseDemo
    
    @end
    
    #import "OSUnfairLockDemo.h"
    #import <os/lock.h>
    
    @interface OSUnfairLockDemo ()
    @property (nonatomic, assign) os_unfair_lock moneyLock;
    @property (nonatomic, assign) os_unfair_lock ticketLock1;
    @end
    
    @implementation OSUnfairLockDemo
    
    - (instancetype)init{
        self = [super init];
        if (self) {
            //初始化
            self.moneyLock = OS_UNFAIR_LOCK_INIT;
            self.ticketLock1 = OS_UNFAIR_LOCK_INIT;
        }
        return self;
    }
    -(void)saleTicket{
        //尝试加锁，已经加锁就不走，没有加锁就加锁
        if (os_unfair_lock_trylock(&_ticketLock1)) {
           [super saleTicket];
            //解锁
            os_unfair_lock_unlock(&_ticketLock1);
        }
    }
    
    -(void)drawMoney{
        //加锁
        os_unfair_lock_lock(&_moneyLock);
        [super drawMoney];
        //解锁
        os_unfair_lock_unlock(&_moneyLock);
    }
    
    -(void)saveMoney{
        //加锁
        os_unfair_lock_lock(&_moneyLock);
        [super saveMoney];
        //解锁
        os_unfair_lock_unlock(&_moneyLock);
    }
    
    @end
    ```
    
### pthread_mutex 
1. 凡是以pthread开头的基本上都是跨平台使用的
2. mutex叫做”互斥锁”，等待锁的线程会处于休眠状态
3. 需要导入头文件#import <pthread.h>
4. 基本用法示例
    
    ```
    #import "PthreadMutexLockDemo.h"
    #import <pthread.h>
    @interface PthreadMutexLockDemo ()
    @property (nonatomic, assign) pthread_mutex_t moneyLock;
    @property (nonatomic, assign) pthread_mutex_t ticketLock1;
    @property (nonatomic, assign) pthread_mutex_t mutexLock;
    @end
    
    /**
     //Mutex type attributes
    #define PTHREAD_MUTEX_NORMAL        0
    #define PTHREAD_MUTEX_ERRORCHECK    1
    #define PTHREAD_MUTEX_RECURSIVE        2    //递归锁
    #define PTHREAD_MUTEX_DEFAULT        PTHREAD_MUTEX_NORMAL
    
     */
    @implementation PthreadMutexLockDemo
    
    -(void)__initMutex:(pthread_mutex_t *)mutex{
        //初始化锁的属性
        pthread_mutexattr_t attr;
        pthread_mutexattr_init(&attr);
        pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_NORMAL);
        //初始化锁
        pthread_mutex_init(mutex, &attr);
        
        //销毁相关资源
    //    pthread_mutexattr_destroy(&attr);
    //    pthread_mutex_destroy(mutex);
    }
    - (instancetype)init
    {
        self = [super init];
        if (self) {
            [self __initMutex:&_moneyLock];
            [self __initMutex:&_ticketLock1];
            [self __initMutex:&_mutexLock];
        }
        return self;
    }
    -(void)saleTicket{
        //尝试加锁，已经加锁就不走，没有加锁就加锁
        if (pthread_mutex_trylock(&_ticketLock1)) {
            [super saleTicket];
            //解锁
            pthread_mutex_unlock(&_ticketLock1);
        }
        
    }
    
    -(void)drawMoney{
        //加锁
        pthread_mutex_lock(&_moneyLock);
        [super drawMoney];
        //解锁
        pthread_mutex_unlock(&_moneyLock);
    }
    
    -(void)saveMoney{
        //加锁
        pthread_mutex_lock(&_moneyLock);
        [super saveMoney];
        //解锁
        pthread_mutex_unlock(&_moneyLock);
    }
    
    //这里需要销毁锁
    -(void)dealloc{
        pthread_mutex_destroy(&_ticketLock1);
        pthread_mutex_destroy(&_moneyLock);
    }
    
    @end
    ```
5. pthread_mutex之递归锁
    1. 下面的死锁现象
        
        ```
        /*********死锁现象分析**********/
        -(void)otherTest{
            //加锁
            pthread_mutex_lock(&_mutexLock);
            
            //只有_mutexLock的锁解开才能执行otherTest2中的代码
            [self otherTest2];
            
            NSLog(@"==========%s",__func__);
            
            //但是要解锁必须otherTest2执行完成，因此造成死锁
            //解锁
            pthread_mutex_unlock(&_mutexLock);
        }
        
        -(void)otherTest2{
            //进来发现_mutexLock已经锁住了，所以无法进行下去，等待
            //加锁
            pthread_mutex_lock(&_mutexLock);
            
            NSLog(@"==========%s",__func__);
            //解锁
            pthread_mutex_unlock(&_mutexLock);
        }
        ```
        
        1. otherTest将_mutexLock锁住，内部调用otherTest2
        2. 但是otherTest2也是用的_mutexLock锁，发现锁住了，那就线程等待，不能继续执行，一直等到_mutexLock锁打开为止。
        3. otherTest的解锁在otherTest2执行完之后才能开锁，因此造成了死锁现象
        4. 解决办法
            1. 这2个方法用不同的锁即可
        5. 疑问，如果是递归呢？ 怎么办呢
            
            ```
             -(void)otherTest{
                //加锁
                pthread_mutex_lock(&_mutexLock);
                static int count = 0;
                count ++;
                //只有_mutexLock的锁解开才能执行otherTest
                if(count >10) return;
                [self otherTest];
                //一次也不会执行
                NSLog(@"==========%s",__func__);
                //解锁
                pthread_mutex_unlock(&_mutexLock);
            }
            ```
    2. 递归锁
        1. 将__initMutex这个方法中的下面这个属性改成递归属性，就是一把递归锁
            
            ```
            pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
            ```
        2. 这样就可以解决上面的问题了。
        3. 那么问题来了，递归锁既然可以重复加锁，那么当多个线程访问的时候，那岂不是又不安全了？
            1. **递归锁的原理： 允许同一个线程对一把锁进行重复加锁**
            2. 即当多个线程来访问时，不同的线程是不能重复加锁的，仍然是安全的
6. 
    
    


