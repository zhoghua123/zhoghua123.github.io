---
layout: post
title: iOS底层-多线程(二)
category: iOS底层
tags: iOS底层
description: iOS底层
---  

## iOS中的线程同步方案

1. 将买卖票和存取钱封装到一个基类中
    
    ```
    #import <Foundation/Foundation.h>    
    @interface ZHBaseDemo : NSObject
    /**
     存取钱演示
     */
    -(void)moneyTest;
    /**
     存钱
     */
    -(void)saveMoney;
    /**
     取钱
     */
    -(void)drawMoney;
    /**
     卖一张票
     */
    -(void)saleTicket;
    /**
     卖多张票
     */
    -(void)saleTicketTest;
    @end
  
    
    #import "ZHBaseDemo.h"

    @interface ZHBaseDemo ()
    @property (nonatomic, assign) int ticketsCount;
    @property (nonatomic, assign) int money;
    @end
    
    @implementation ZHBaseDemo
    
    /**
     存取钱演示
     */
    -(void)moneyTest{
        self.money = 100;
        dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
        dispatch_async(queue, ^{
            for (int i =0; i<3; i++) {
                [self saveMoney];
            }
        });
        dispatch_async(queue, ^{
            for (int i =0; i<3; i++) {
                [self drawMoney];
            }
        });
    }
    
    /**
     存钱
     */
    -(void)saveMoney{
      
        int oldMoney = self.money;
        sleep(.2);
        oldMoney+= 50;
        self.money = oldMoney;
        NSLog(@"存50，还剩%d元====%@",oldMoney,[NSThread currentThread]);
       
    }
    /**
     取钱
     */
    -(void)drawMoney{
       
        int oldMoney = self.money;
        sleep(.2);
        oldMoney-= 20;
        self.money = oldMoney;
        NSLog(@"取20，还剩%d元====%@",oldMoney,[NSThread currentThread]); 
    }
    
    /**
     卖一张票
     */
    -(void)saleTicket{
        int oldTicketsCount = self.ticketsCount;
        sleep(.2);
        oldTicketsCount--;
        self.ticketsCount = oldTicketsCount;
        NSLog(@"还剩%d张票====%@",oldTicketsCount,[NSThread currentThread]);
    }
    
    /**
     卖多张票
     */
    -(void)saleTicketTest{
        self.ticketsCount = 15;
        dispatch_async(dispatch_get_global_queue(0, 0), ^{
            for (int i =0; i<2; i++) {
                [self saleTicket];
            }
        });
        dispatch_async(dispatch_get_global_queue(0, 0), ^{
            for (int i =0; i<2; i++) {
                [self saleTicket];
            }
        });
        dispatch_async(dispatch_get_global_queue(0, 0), ^{
            for (int i =0; i<2; i++) {
                [self saleTicket];
            }
        });
    }
    
    @end
    ```

### os_unfair_lock 
1. os_unfair_lock用于取代不安全的OSSpinLock ，从iOS10开始才支持
2. 从底层调用看，等待os_unfair_lock锁的线程会处于休眠状态，并非忙等
3. 需要导入头文件#import <os/lock.h>
4. 代码举例：
    
    ```
    #import "ZHBaseDemo.h"

    @interface OSUnfairLockDemo : ZHBaseDemo
    
    @end
    
    #import "OSUnfairLockDemo.h"
    #import <os/lock.h>
    
    @interface OSUnfairLockDemo ()
    @property (nonatomic, assign) os_unfair_lock moneyLock;
    @property (nonatomic, assign) os_unfair_lock ticketLock1;
    @end
    
    @implementation OSUnfairLockDemo
    
    - (instancetype)init{
        self = [super init];
        if (self) {
            //初始化
            self.moneyLock = OS_UNFAIR_LOCK_INIT;
            self.ticketLock1 = OS_UNFAIR_LOCK_INIT;
        }
        return self;
    }
    -(void)saleTicket{
        //尝试加锁，已经加锁就不走，没有加锁就加锁
        if (os_unfair_lock_trylock(&_ticketLock1)) {
           [super saleTicket];
            //解锁
            os_unfair_lock_unlock(&_ticketLock1);
        }
    }
    
    -(void)drawMoney{
        //加锁
        os_unfair_lock_lock(&_moneyLock);
        [super drawMoney];
        //解锁
        os_unfair_lock_unlock(&_moneyLock);
    }
    
    -(void)saveMoney{
        //加锁
        os_unfair_lock_lock(&_moneyLock);
        [super saveMoney];
        //解锁
        os_unfair_lock_unlock(&_moneyLock);
    }
    
    @end
    ```
    
### pthread_mutex 
1. 凡是以pthread开头的基本上都是跨平台使用的
2. mutex叫做”互斥锁”，**等待锁的线程会处于休眠状态**
3. 需要导入头文件#import <pthread.h>
4. 基本用法示例
    
    ```
    #import "PthreadMutexLockDemo.h"
    #import <pthread.h>
    @interface PthreadMutexLockDemo ()
    @property (nonatomic, assign) pthread_mutex_t moneyLock;
    @property (nonatomic, assign) pthread_mutex_t ticketLock1;
    @property (nonatomic, assign) pthread_mutex_t mutexLock;
    @end
    
    /**
     //Mutex type attributes
    #define PTHREAD_MUTEX_NORMAL        0
    #define PTHREAD_MUTEX_ERRORCHECK    1
    #define PTHREAD_MUTEX_RECURSIVE        2    //递归锁
    #define PTHREAD_MUTEX_DEFAULT        PTHREAD_MUTEX_NORMAL
    
     */
    @implementation PthreadMutexLockDemo
    
    -(void)__initMutex:(pthread_mutex_t *)mutex{
        //初始化锁的属性
        pthread_mutexattr_t attr;
        pthread_mutexattr_init(&attr);
        pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_NORMAL);
        //初始化锁
        pthread_mutex_init(mutex, &attr);
        
        //销毁相关资源
    //    pthread_mutexattr_destroy(&attr);
    //    pthread_mutex_destroy(mutex);
    }
    - (instancetype)init
    {
        self = [super init];
        if (self) {
            [self __initMutex:&_moneyLock];
            [self __initMutex:&_ticketLock1];
            [self __initMutex:&_mutexLock];
        }
        return self;
    }
    -(void)saleTicket{
        //尝试加锁，已经加锁就不走，没有加锁就加锁
        if (pthread_mutex_trylock(&_ticketLock1)) {
            [super saleTicket];
            //解锁
            pthread_mutex_unlock(&_ticketLock1);
        }
        
    }
    
    -(void)drawMoney{
        //加锁
        pthread_mutex_lock(&_moneyLock);
        [super drawMoney];
        //解锁
        pthread_mutex_unlock(&_moneyLock);
    }
    
    -(void)saveMoney{
        //加锁
        pthread_mutex_lock(&_moneyLock);
        [super saveMoney];
        //解锁
        pthread_mutex_unlock(&_moneyLock);
    }
    
    //这里需要销毁锁
    -(void)dealloc{
        pthread_mutex_destroy(&_ticketLock1);
        pthread_mutex_destroy(&_moneyLock);
    }
    
    @end
    ```
5. **pthread_mutex之递归锁**
    1. 下面的死锁现象
        
        ```
        /*********死锁现象分析**********/
        -(void)otherTest{
            //加锁
            pthread_mutex_lock(&_mutexLock);
            
            //只有_mutexLock的锁解开才能执行otherTest2中的代码
            [self otherTest2];
            
            NSLog(@"==========%s",__func__);
            
            //但是要解锁必须otherTest2执行完成，因此造成死锁
            //解锁
            pthread_mutex_unlock(&_mutexLock);
        }
        
        -(void)otherTest2{
            //进来发现_mutexLock已经锁住了，所以无法进行下去，等待
            //加锁
            pthread_mutex_lock(&_mutexLock);
            
            NSLog(@"==========%s",__func__);
            //解锁
            pthread_mutex_unlock(&_mutexLock);
        }
        ```
        
        1. otherTest将_mutexLock锁住，内部调用otherTest2
        2. 但是otherTest2也是用的_mutexLock锁，发现锁住了，那就线程等待，不能继续执行，一直等到_mutexLock锁打开为止。
        3. otherTest的解锁在otherTest2执行完之后才能开锁，因此造成了死锁现象
        4. 解决办法
            1. 这2个方法用不同的锁即可
        5. 疑问，如果是递归呢？ 怎么办呢
            
            ```
             -(void)otherTest{
                //加锁
                pthread_mutex_lock(&_mutexLock);
                static int count = 0;
                count ++;
                //只有_mutexLock的锁解开才能执行otherTest
                if(count >10) return;
                [self otherTest];
                //一次也不会执行
                NSLog(@"==========%s",__func__);
                //解锁
                pthread_mutex_unlock(&_mutexLock);
            }
            ```
    2. 递归锁
        1. 将__initMutex这个方法中的下面这个属性改成递归属性，就是一把递归锁
            
            ```
            pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
            ```
        2. 这样就可以解决上面的问题了。
        3. 那么问题来了，递归锁既然可以重复加锁，那么当多个线程访问的时候，那岂不是又不安全了？
            1. **递归锁的原理： 允许同一个线程对一把锁进行重复加锁**
            2. 即当多个线程来访问时，不同的线程是不能重复加锁的，仍然是安全的
6. **pthread_mutex – 条件**
    1. 代码举例：
        
        ```
        #import "PthreadMutexLockDemo2.h"
        #import <pthread.h>
        
        @interface PthreadMutexLockDemo2 ()
        @property (nonatomic, assign) pthread_mutex_t mutexLock;
        @property (nonatomic,strong) NSMutableArray *data;
        @property (nonatomic, assign) pthread_cond_t cond;
        @end
        @implementation PthreadMutexLockDemo2
        
        - (instancetype)init
        {
            self = [super init];
            if (self) {
                //初始化锁的属性
                pthread_mutexattr_t attr;
                pthread_mutexattr_init(&attr);
                //递归锁
                pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
                //初始化锁
                pthread_mutex_init(&_mutexLock, &attr);
                
                self.data = [NSMutableArray array];
                //初始化条件
                //NULL代表使用默认属性
                pthread_cond_init(&_cond, NULL);
            }
            return self;
        }
        //删除数组中的元素
        -(void)__remove{
            //加锁
            pthread_mutex_lock(&_mutexLock);
            NSLog(@"------remove");
            
            //一旦发现当前数组无元素就开始等待，让当前线程休眠。但是同时把锁打开，允许别的线程使用这把锁加锁
            if (self.data.count == 0) {
                //等待条件（进入休眠，放开_mutexLock锁；被唤醒后，会再次对_mutexLock锁住）
                pthread_cond_wait(&_cond, &_mutexLock);
            }
            
            [self.data removeLastObject];
            NSLog(@"删除了元素");
            //解锁
            pthread_mutex_unlock(&_mutexLock);
        }
        //往数组中添加元素
        -(void)__add{
            //加锁
            pthread_mutex_lock(&_mutexLock);
            NSLog(@"------add");
            [self.data addObject:@"test"];
            NSLog(@"添加了元素");
            //激活一个等待该条件的线程
            //发信号通知等待（_cond），不用等了，唤醒等待的线程，让它继续执行
            pthread_cond_signal(&_cond);
            //激活所有等待该条件的线程
        //    pthread_cond_broadcast(&_cond);
            //解锁
            pthread_mutex_unlock(&_mutexLock);
        }
        -(void)otherTest{
            [[[NSThread alloc] initWithTarget:self selector:@selector(__remove) object:nil] start];
            sleep(1);
            [[[NSThread alloc] initWithTarget:self selector:@selector(__add) object:nil] start];
        }
        //这里需要销毁锁
        -(void)dealloc{
            pthread_mutex_destroy(&_mutexLock);
            pthread_cond_destroy(&_cond);
        }
        
        @end
        ```
        
        1. 分析流程
            1. 线程1先进入`__remove`，但是发现`data`没有数据
            2. 让线程1等待，进入休眠状态，不继续执行，同时放开`_mutexLock`锁
            3. 此时线程2进入`__add`，`_mutexLock`上锁（因为线程1已经给他放开了），执行`addobject`
            4. 执行完成，唤醒线程1(此时线程2还没有开锁，需要等着线程2开完锁)，线程2`_mutexLock`解锁，线程1`_mutexLock`加锁，继续执行删除`remove`
            5. 线程1执行`remove`完毕，`_mutexLock`开锁
        2. 测试
            
            ```
            -(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
                PthreadMutexLockDemo2 *demo3 = [[PthreadMutexLockDemo2 alloc] init];
                [demo3 otherTest];
            }
            ```
        3. 打印：
            
            ```
            ------remove
            ------add
            添加了元素
            删除了元素
            ```
            
            1. 可以看到尽管先执行了remove方法，但是最终停下了了
            2. 去执行了add，执行完，才返回执行删除
    2. 使用场合：
        1. 某个线程执行完之后当前线程再执行
    

### NSLock、NSRecursiveLock 
1. NSLock是对mutex普通锁的封装
    
    ```
    @protocol NSLocking
    //加锁
    - (void)lock;
    //解锁
    - (void)unlock;
    @end
    
    @interface NSLock : NSObject <NSLocking> {
    @private
        void *_priv;
    }
    //试着加锁（不等待）
    - (BOOL)tryLock;
    //等待limit时间，时间内锁打开就加锁，到limit时间了，还没有开锁那就不加了，返回加锁失败
    - (BOOL)lockBeforeDate:(NSDate *)limit;
    @property (nullable, copy) NSString *name;
    @end
    ```
2. NSRecursiveLock也是对mutex递归锁的封装，**API跟NSLock基本一致**
3. 举例：
    
    ```
    #import "NSLockDemo.h"

    @interface NSLockDemo ()
    
    @property (nonatomic, strong) NSLock *moneyLock;
    @property (nonatomic, strong) NSLock *ticketLock1;
    @end
    
    @implementation NSLockDemo
    - (instancetype)init
    {
        self = [super init];
        if (self) {
            self.moneyLock = [[NSLock alloc] init];
            self.ticketLock1 = [[NSLock alloc] init];
        }
        return self;
    }
    -(void)saleTicket{
        //尝试加锁，已经加锁就不走，没有加锁就加锁
        if ([self.ticketLock1 tryLock]) {
            [super saleTicket];
            //解锁
            [self.ticketLock1 unlock];
        }
    }
    
    -(void)drawMoney{
        //加锁
        [self.moneyLock lock];
        [super drawMoney];
        //解锁
        [self.moneyLock unlock];
    }
    
    -(void)saveMoney{
        //加锁
        [self.moneyLock lock];
        [super saveMoney];
        //解锁
        [self.moneyLock unlock];
    }
    @end
    ```
4. NSRecursiveLock不在举例，因为跟NSLock用法一样

### NSCondition、NSConditionLock
1. NSCondition是对mutex和cond的封装
    
    ```
    @interface NSCondition : NSObject <NSLocking> {
    @private
        void *_priv;
    }
    //等待
    - (void)wait;
    //等待多长时间
    - (BOOL)waitUntilDate:(NSDate *)limit;
    //给等待发送信号
    - (void)signal;
    //给所有等待发送信号
    - (void)broadcast;
    @property (nullable, copy) NSString *name ;
    @end
    ```
2. NSConditionLock是对NSCondition的进一步封装，可以设置具体的条件值
    
    ```
    @interface NSConditionLock : NSObject <NSLocking> {
    @private
        void *_priv;
    }
    
    - (instancetype)initWithCondition:(NSInteger)condition NS_DESIGNATED_INITIALIZER;
    
    @property (readonly) NSInteger condition;
    - (void)lockWhenCondition:(NSInteger)condition;
    - (BOOL)tryLock;
    - (BOOL)tryLockWhenCondition:(NSInteger)condition;
    - (void)unlockWithCondition:(NSInteger)condition;
    - (BOOL)lockBeforeDate:(NSDate *)limit;
    - (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;
    
    @property (nullable, copy) NSString *name;
    
    @end
    ```
3. 举例使用(NSCondition)
    
    ```
    #import "NSConditionDemo.h"
    @interface NSConditionDemo ()
    
    @property (nonatomic, strong) NSCondition *condition;
    @property (nonatomic,strong) NSMutableArray *data;
    @end
    @implementation NSConditionDemo
    
    - (instancetype)init
    {
        self = [super init];
        if (self) {
            self.data = [NSMutableArray array];
            self.condition = [[NSCondition alloc] init];
        }
        return self;
    }
    //删除数组中的元素
    -(void)__remove{
        //加锁
        [self.condition lock];
        NSLog(@"------remove");
        
        //一旦发现当前数组无元素就开始等待，让当前线程休眠。但是同时把锁打开，允许别的线程使用这把锁加锁
        if (self.data.count == 0) {
            //等待条件（进入休眠，放开_mutexLock锁；被唤醒后，会再次对_mutexLock锁住）
            [self.condition wait];
        }
        
        [self.data removeLastObject];
        NSLog(@"删除了元素");
        //解锁
        [self.condition unlock];
    }
    //往数组中添加元素
    -(void)__add{
        //加锁
       [self.condition lock];
        NSLog(@"------add");
        [self.data addObject:@"test"];
        NSLog(@"添加了元素");
        //激活一个等待该条件的线程
        //发信号通知等待（_cond），不用等了，唤醒等待的线程，让它继续执行
        [self.condition signal];
        //激活所有等待改条件的线程
        [self.condition broadcast];
        //解锁
        [self.condition unlock];
    }
    -(void)otherTest{
        [[[NSThread alloc] initWithTarget:self selector:@selector(__remove) object:nil] start];
        sleep(1);
        [[[NSThread alloc] initWithTarget:self selector:@selector(__add) object:nil] start];
    }
    @end
    ```
    

