---
layout: post
title: iOS底层-内存管理(一)
category: iOS底层
tags: iOS底层
description: iOS底层
---  

## 定时器
### CADisplayLink、NSTimer使用注意 
1. NStimer与CADisplayLink初始化示例
    
    ```
    #import "ZHTestViewController.h"
    @interface ZHTestViewController ()
    //@property (nonatomic,strong) CADisplayLink *playLink;
    @property (nonatomic,strong) NSTimer *timer;
    @end
    
    @implementation ZHTestViewController
    
    - (void)viewDidLoad {
        [super viewDidLoad];
        self.view.backgroundColor = UIColor.blueColor;
        
        /*********CADisplayLink**********/
        //每隔一段时间掉一共一次方法
        //调用时间不用设置，调用时间间隔跟屏幕刷帧频率一样。
        //displayLinkWithTarget: selector: 该方法会对target捕捉，造成循环引用
    //    self.playLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(linkTest)];
    //    [self.playLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];
        
        /*********NSTimer**********/
        //scheduledTimerWithTimeInterval也对target有一个强引用，导致循环引用
        self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timerTest) userInfo:nil repeats:YES];
    }
    - (void)linkTest {
        NSLog(@"%s",__func__);
    }
    - (void)timerTest {
        NSLog(@"%s",__func__);
    }
    
    -(void)dealloc{
    //    [self.playLink invalidate];
        [self.timer invalidate];
    }
    
    @end
    ```
    
    1. 发现问题，无论是NSTimer还是CADisplayLink，back到上一个控制器时，都不能正常的停止定时器，而且当前控制器也不会销毁，说明产生了循环引用
    2. 经过分析分别是：`displayLinkWithTarget: selector: `与`scheduledTimerWithTimeInterval`都对target进行了强引用，导致循环引用
    3. 对于NSTeimer可以用另外一种创建方式来解决这个问题
        
        ```
         //这个只能在block中使用
        __weak typeof(self) weakself = self;
        self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) {
            [weakself timerTest];
        }];
        ```
    3. 但是CADisplayLink呢？ 而且NSTimer的非block方式就不能解决了吗？
    4. 循环引用分析以及解决办法如下：
        
        ![图4](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/diceng24.png)
        
        1. 解决办法
            1. 引入一个中间对象proxy，让timer的target引用为中间对象proxy
            2. 中间对象proxy的target弱引用viewcontroller
            3. 但是有个问题：timer触发时，调用的是proxy的方法，可是触发方法在viewcontroller怎么办呢？ 
                1. 解决办法：消息转发
2. 解决办法：
    
    ```
    //中间对象proxy
    #import <Foundation/Foundation.h>

    @interface ZHProxy : NSObject
    +(instancetype)proxyWithTarget:(id)target;
    @end
    
    #import "ZHProxy.h"
    #import <objc/runtime.h>
    
    @interface ZHProxy ()
    @property (nonatomic,weak) id target;
    @end
    
    @implementation ZHProxy
    +(instancetype)proxyWithTarget:(id)target{
        ZHProxy *proxy = [[ZHProxy alloc] init];
        proxy.target = target;
        return  proxy;
    }
    //消息转发
    -(id)forwardingTargetForSelector:(SEL)aSelector{
        return self.target;
    }
    @end
    
    //使用
    #import "ZHTestViewController.h"
    #import "ZHProxy.h"
    @interface ZHTestViewController ()
    @property (nonatomic,strong) CADisplayLink *playLink;
    @property (nonatomic,strong) NSTimer *timer;
    @end
    
    @implementation ZHTestViewController
    
    - (void)viewDidLoad {
        [super viewDidLoad];
        self.view.backgroundColor = UIColor.blueColor;
        //定时器
        //每隔一段时间掉一共一次方法
        //调用时间不用设置，调用时间间隔跟屏幕刷帧频率一样。
        //displayLinkWithTarget: selector: 该方法会对target捕捉，造成循环引用
    //    self.playLink = [CADisplayLink displayLinkWithTarget:[ZHProxy proxyWithTarget:self] selector:@selector(test)];
    //    [self.playLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];
        
        /*********NSTimer**********/
        //scheduledTimerWithTimeInterval也对target有一个强引用，导致循环引用        
        //这个却不能使用weakself
        self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:[ZHProxy proxyWithTarget:self] selector:@selector(timerTest) userInfo:nil repeats:YES];
    }
    - (void)linkTest {
        NSLog(@"%s",__func__);
    }
    - (void)timerTest {
        NSLog(@"%s",__func__);
    }
    -(void)dealloc{
    //    [self.playLink invalidate];
        [self.timer invalidate];
    }
    
    @end

    ```
3. **NSProxy**
    1. NSProxy类
    
        ```
        @interface NSProxy <NSObject> {
            Class	isa;
        }
        //NSObject比较
        @interface NSObject <NSObject> {
            Class isa;
        }
        ```
        
        1. NSProxy是一个跟NSObject一样的基类，不继承任何父类
        2. 这个类专门用于做消息转发的
        3. **效率高**
            1. 不需要通过像NSObject对象一样通过isa一系列查找方法来进行了
            2. 当前对象没有相应的方法，直接走消息转发
        3. 初始化不需要`init`
    2. 如果上面的ZHProxy继承自NSProxy，如下
        
        ```
        #import <Foundation/Foundation.h>
        @interface ZHProxy1 : NSProxy
        +(instancetype)proxyWithTarget:(id)target;
        @end
        #import "ZHProxy1.h"
        @interface ZHProxy1 ()
        @property (nonatomic,weak) id target;
        @end
        
        @implementation ZHProxy1
        +(instancetype)proxyWithTarget:(id)target{
            //NSProxy没有init方法
            ZHProxy1 *proxy = [ZHProxy1 alloc];
            proxy.target = target;
            return  proxy;
        }
        
        //返回方法签名
        -(NSMethodSignature *)methodSignatureForSelector:(SEL)sel{
            return  [self.target methodSignatureForSelector:sel];
        }
        //
        -(void)forwardInvocation:(NSInvocation *)invocation{
        //    invocation.target = self.target;
            [invocation invokeWithTarget:self.target];
        }
        @end
        ```

