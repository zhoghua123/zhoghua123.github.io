---
layout: post
title: iOS底层-KVO、KVC
category: iOS底层
tags: iOS底层
description: iOS底层
---

## KVO
1. KVO的全称是Key-Value Observing，俗称“键值监听”，可以用于监听某个对象属性值的改变
2. 代码分析：
    
    ```
    #import "ViewController.h"
    #import "Person.h"
    #import <objc/runtime.h>
    @interface ViewController ()
    @property (nonatomic,strong) Person *person1;
    @property (nonatomic,strong) Person *person2;
    @end
    
    @implementation ViewController
    
    - (void)viewDidLoad {
        [super viewDidLoad];
        self.person1 = [[Person alloc] init];
        self.person1.age = 10;
        
        self.person2 = [[Person alloc] init];
        self.person2.age = 20;
        //监听isa的变化
        NSLog(@"===添加KVO之前===%@===%@",object_getClass(self.person1),object_getClass(self.person2));
        //监听setAge的实现变化
        NSLog(@"person1添加KVO监听之前 - %p === person2===%p",
                  [self.person1 methodForSelector:@selector(setAge:)],
                  [self.person2 methodForSelector:@selector(setAge:)]);
        //给person对象添加监听KVO
        NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;
        [self.person1 addObserver:self forKeyPath:@"age" options:options context:@"age"];
        
        //监听isa的变化
        NSLog(@"===添加KVO之后===%@===%@",object_getClass(self.person1),object_getClass(self.person2));
        
        //监听setAge的实现变化
        NSLog(@"person1添加KVO监听之后 - %p === person2=== %p",
              [self.person1 methodForSelector:@selector(setAge:)],
              [self.person2 methodForSelector:@selector(setAge:)]);
        
        //监听类实现了那些方法
        [self printMethodNamesOfClass:object_getClass(self.person1)];
        [self printMethodNamesOfClass:object_getClass(self.person2)];
        //打断点处
        NSLog(@"==============");
    }
    - (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
        self.person1.age = 20;
    }
    //当监听对象的属性值发生改变的时候
    
    - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context{
        
      NSLog(@"age=== %@====%@===%@",keyPath,object,change);
    }
    
    //打印一个类的所有方法实现
    - (void)printMethodNamesOfClass:(Class)cls
    {
        unsigned int count;
        // 获得方法数组
        Method *methodList = class_copyMethodList(cls, &count);
        
        // 存储方法名
        NSMutableString *methodNames = [NSMutableString string];
        
        // 遍历所有的方法
        for (int i = 0; i < count; i++) {
            // 获得方法
            Method method = methodList[i];
            // 获得方法名
            NSString *methodName = NSStringFromSelector(method_getName(method));
            // 拼接方法名
            [methodNames appendString:methodName];
            [methodNames appendString:@", "];
        }
        
        // 释放
        free(methodList);
        
        // 打印方法名
        NSLog(@"类名===%@== 类中的方法列表=== %@", cls, methodNames);
    }
    -(void)dealloc{
        
        [self removeObserver:self forKeyPath:@"age"];
    }
    @end
    ```
3. 打印调试如下：
    
    ```
    //isa指向监听
    ===添加KVO之前===Person===Person
    //setAge方法实现监听
    person1添加KVO监听之前 - 0x10fb5d400 === person2===0x10fb5d400
     
    -------person1调用了addObserver方法
     
    //isa指向监听
    ===添加KVO之后===NSKVONotifying_Person===Person
    //setAge方法实现监听
    person1添加KVO监听之后 - 0x10feb83d2 === person2=== 0x10fb5d400
     
    //当前类的方法列表监听
    类名===NSKVONotifying_Person== 类中的方法列表=== setAge:, class, dealloc, _isKVOA,
    类名===Person== 类中的方法列表=== height, setHeight:, setAge:, age,
     
    //使用lldb命令，查看地址对应的实现方法名
    (lldb) p (IMP)0x10feb83d2
    (IMP) $0 = 0x000000010feb83d2 (Foundation`_NSSetIntValueAndNotify)
    (lldb) po (IMP) 0x10fb5d400
    (-[Person setAge:] at Person.h:15)
    ```
    
    1. 可以发现`person1`执行了`addoObserver`之后，`person1`的isa指针指向的不是`Person`了，而是`NSKVONotifying_Person`了
    2. 说明，`person1`调用`setAge`对应的方法实现是`_NSSetIntValueAndNotify`这个函数，而不是调用setAge方法了
    3. `NSKVONotifying_Person`这个类内部实现了`setAge:, class, dealloc, _isKVOA`这4个方法
4. `_NSSet*ValueAndNotify`的内部实现 
    1. 调用`willChangeValueForKey:`
    2. 调用原来的`setter`实现
    3. 调用`didChangeValueForKey:`
        1. `didChangeValueForKey:`内部会调用`observer`的`observeValueForKeyPath:ofObject:change:context:`方法
5. Person对象调用addObserver之后如下：

    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/diceng07.png)

### 相关面试题
1. iOS用什么方式实现对一个对象的KVO？(KVO的本质是什么？)
    1. 利用RuntimeAPI动态生成一个子类，并且让instance对象的isa指向这个全新的子类
    2. 当修改instance对象的属性时，会调用Foundation的_NSSetXXXValueAndNotify函数
        1. willChangeValueForKey:
        2. 父类原来的setter
        3. didChangeValueForKey:
            1. 内部会触发监听器（Oberser）的监听方法( `observeValueForKeyPath:ofObject:change:context:`） 
2. 如何手动触发KVO？
    1. 手动调用willChangeValueForKey:和didChangeValueForKey:
3. 直接修改成员变量会触发KVO么？
    1. 不会触发KVO，因为本质是监听setter方法


