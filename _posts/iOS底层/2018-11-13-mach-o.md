---
layout: post
title: MAC、iOS平台可执行文件：Mach-O
category: iOS底层
tags: mach-o
description: mach-o
---

## APP的生命周期
1. 开发生成ipa包的本质过程
    
    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/mach01.png)

    1. 我们开发完程序，command +B 编译，然后打开文件目录Products，发现有一个app包
        1. 这个过程其实经历了编译、连接、签名
    2. 右击选择show in finder，可以找到这个app包
    3. 然后右击这个包选择显示包内容，我们可以看见上图列表
        1. Xib被编译成nib文件，storyboard 被编译成storyboardc文件
        2. 有一个签名文件
        3. 那么.m的代码被编译成什么了呢？ 就是那个黑色的可执行文件
            1. EverythingSendUser.app 中的EverythingSendUser文件是iOS可执行文件
            2. 文件的格式是Mach-O(machine object)
    4. app文件是如何变成ipa文件呢？
        1. 新建文件夹，命名为Payload
        2. 右击压缩为zip格式
        3. 修改文件后缀名为ipa
        4. 修改ipa文件名为EverythingSendUser
        5. 这个就是整个压缩成ipa的过程
        6. 如果你讲一个打包好的ipa文件，后缀名改为zip然后解压，会发现本质就是这样
2. ipa文件是如何安装到手机上呢？
    1. 方法一：
        1. 开发者将ipa文件上传到App Store，用户在App Store下载安装
    2. 方法二:
        1. 通过pp助手、iFunbox、Xcode等工具安装
        2. 注意：如果你的开发账号是免费版的，那么安装的APP也就6天的使用时间。

## 逆向APP的思路
1. 界面分析
    1. Cycript、Reveal工具分析界面的控件
2. 代码分析
    1. 对Mach-O文件的静态分析
    2. MachOView、class-dump、Hopper Disassembler、ida等，这些工具分析
    3. 作用就是大概知道代码怎么写的
3. 动态调试
    1. 对运行中的APP进行代码调试
    2. debugserver、LLDB
    3. 将程序跑起来，然后在运行中进行调试
4. 代码编写
    1. 注入代码到APP中
    2. 必要时还可能需要重新签名、打包ipa

## class-dump 
1. 顾名思义，它的作用就是把Mach-O文件的class信息给dump出来（把类信息给导出来），生成对应的.h头文件（只能生产.h头文件）
2. 官方地址：`http://stevenygard.com/projects/class-dump/`
3. 下载完工具包后双击dmg将class-dump文件复制到Mac的/usr/local/bin目录，这样在终端就能识别class-dump命令了
    1. cd /usr/local/bin
    2. open ./
    3. 然后复制进去就可以了
    4. **MAC上终端指令的原理是什么呢？**
        1. 我们在终端敲一个指令比如 `cd`,那么他就会去**两个**地方去找这个指令
            1. 第一个地方：`/usr/bin目录中去找`,打开这个路径，我们会发现里面后很多命令，其中就有cd命令
                1. **注意： 自从mac10.11之后这个目录就不允许写入内容了，因此只能使用下面的路径了**
            2. 第二个地方：`/usr/local/bin`,这个也有很多命令。
                1. 我们可以看到这个目录下有如下命令：
                2. pod： cocoapods命令
                3. jekyll： 博客命令
                4. 等等我们自己安装的命令
4. 常用格式
    1. `class-dump  -H  Mach-O文件路径  -o  头文件存放目录`
        1. -H表示要生成头文件
        2. -o用于制定头文件的存放目录
5. 使用步骤
    1. 拿到ipa文件
    2. 将ipa改为zip，然后解压
    3. 右击app的显示包内容，将mach-o文件复制到一个文件中
    4. 然后执行`class-dump  -H  Mach-O文件路径  -o  头文件存放目录`命令，就可以拿到这个项目中所有类的头文件了，而且这个头文件中会将每个类的所有方法都列表出来。
    5. 将这个头文件文件夹直接拖到sublime（这个东西自己百度搜搜）中即可以快速查看了。

## Hopper
1. 代码的编译过程（即OC代码是如何变成Mach-O文件的呢？）
    1. 首先会编译成汇编
    2. 然后再编译成机器指令
    3. 这个机器指令就是Mach-O文件
    
    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/mach02.png)
2. Hopper Disassmbler 
    1. Hopper Disassmbler能够将Mach-O文件的机器语言代码反编译成**汇编代码、OC伪代码或者Swift伪代码**
    2. [下载地址](https://www.jianshu.com/p/c04ac36c6641)
    3. 常用快捷键
        1. Shift + Option + X
        2. 找出哪里引用了这个方法 
    4. 使用
        1. 将mach-O直接拖入到Hopper Disassmbler即可分析出，所有的汇编代码
        2. 点击工具栏的按钮，可以转换成OC伪代码。
    
## 系统的动态库
1. 动态库共享缓存（dyld shared cache）
    1. 从iOS3.1开始，为了提高性能，绝大部分的系统动态库文件都打包存放到了一个缓存文件中（dyld shared cache）
    2. 缓存文件路径（iPhone逆向后可以查看手机文件）：/System/Library/Caches/com.apple.dyld/dyld_shared_cache_arm**X**
        1. 也就是说系统的动态库都放在上面那个文件中了
    3. dyld_shared_cache_armX的X代表ARM处理器指令集架构
    4. armv6
        1. Phone、iPhone3G
        2. iPod Touch、iPod Touch2
    5. armv7
        1. iPhone3GS、iPhone4、iPhone4S
        2. iPad、iPad2、iPad3(The New iPad)
        3. iPad mini
        4. iPod Touch3G、iPod Touch4、iPod Touch5
    6. armv7s
        1. iPhone5、iPhone5C
        2. iPad4
    7. arm64
        1. iPhone5S、iPhone6、iPhone6 Plus、iPhone6S、iPhone6S Plus
        2. iPhoneSE、iPhone7、iPhone7 Plus、iPhone8、iPhone8 Plus、iPhoneX
        3. iPad5、iPad Air、iPad Air2、iPad Pro、iPad Pro2
        4. iPad mini with Retina display、iPad mini3、iPad mini4
        5. iPod Touch6
    8. 所有指令集原则上都是向下兼容的
    9. 动态库共享缓存一个非常明显的好处是节省内存
    10. 现在的ida、Hopper反编译工具都可以识别动态库共享缓存
2. 动态库共享缓存的好处
    1. 这样做的好处就是节省了内存
    2. 所谓的动态库就是动态链接、动态加载，在内存中只有一份的，大家公用这一份内存。
    3. 如果把不同的动态库放在不同的文件
        1. 由于每个动态库都是mach-O文件，并且里面包含了这个文件的一些描述信息
        2. 因此多个动态库的话每个文件都需要这些描述信息
    4. 如果吧不同的动态库放在同一个文件
        1. 这样的话相当于把不同的各个动态库压缩成一个文件，大家公共有一个描述信息等，这样更节省内存。
3. 动态库的加载
    1. 在Mac\iOS中，是使用了/usr/lib/dyld程序来加载动态库
    2. dyld
        1. dynamic link editor，动态链接编辑器
        2. dynamic loader，动态加载器
    3. dyld源码 
        1. [https://opensource.apple.com/tarballs/dyld/](https://opensource.apple.com/tarballs/dyld/)
    4. 苹果开源的一些源码
        1. [https://opensource.apple.com/tarballs](https://opensource.apple.com/tarballs)
4. 从动态库共享缓存抽取动态库 （学逆向时再看）
    1. 由于所有的动态库都压缩成一个文件（dyld_shared_cache_arm**X**）了，但是如果我只想要UIKit这个动态库的Mach-O呢？ 这就需要抽取了
    2. 可以使用dyld源码中的`launch-cache/dsc_extractor.cpp`这个文件，编译成一个可执行文件
    3. 编译dsc_extractor.cpp
        1. clang++ -o dsc_extractor dsc_extractor.cpp
    4. 使用dsc_extractor命令
        1. ./dsc_extractor  动态库共享缓存文件的路径   用于存放抽取结果的文件夹 


