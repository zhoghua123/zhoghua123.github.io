---
layout: post
title: iOS底层-Block的本质
category: iOS底层
tags: iOS底层
description: iOS底层
---

## Block的本质
1. block本质上也是一个OC对象，它内部也有个isa指针
2. block是封装了函数调用以及函数调用环境的OC对象
3. block的底层结构如右图所示
    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/diceng12.png)
4. 编译分析
    1. OC代码
        
        ```
        int main(int argc, const char * argv[]) {
            @autoreleasepool {
                void (^myblock)(void) = ^{
                    NSLog(@"myblock");
                };
                
                myblock();
            }
            return 0;
        }
        ```
    2. 通过编译后，取出核心代码如下：**注意这里从C++角度分析！！！**
        
        ```
         //结构体__block_impl对象
         struct __block_impl {
             void *isa;
             int Flags;
             int Reserved;
             void *FuncPtr;
         };
         //C++中的对象，就是那个结构体的原型
         struct __main_block_impl_0 {
         
             struct __block_impl impl;
             struct __main_block_desc_0* Desc;
         
            //构造函数，带有默认参数
             __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {
                 impl.isa = &_NSConcreteStackBlock; //block的类型
                 impl.Flags = flags;
                 impl.FuncPtr = fp;
                 Desc = desc;
             }
         };
         
         //静态函数
         static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
         
             NSLog((NSString *)&__NSConstantStringImpl__var_folders_t2_d94848jx1fq4vd6k8qcsfdq00000gn_T_main_448c61_mi_0);
         }
         
         //创建一个静态结构体变量__main_block_desc_0_DATA并初始化
         static struct __main_block_desc_0 {
             size_t reserved;//保留字
             size_t Block_size;//block的大小
         } __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};
         
         //main函数
         int main(int argc, const char * argv[]) {
             { __AtAutoreleasePool __autoreleasepool;
         
                 //因此block本质是一个__main_block_impl_0结构体对象指针
                 void (*myblock)(void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA));
                 //函数调用：把myblock转化成__block_impl* 类型，取出FuncPtr成员函数，然后调用
                 ((void (*)(__block_impl *))((__block_impl *)myblock)->FuncPtr)((__block_impl *)myblock);
             }
        return 0;
        }
        ```
        
        1. block本质就是一个`__main_block_impl_0`类型的结构体对象指针
        2. 疑问难点：
            
            ```
            ((void (*)(__block_impl *))((__block_impl *)myblock)->FuncPtr)((__block_impl *)myblock);
            ```
            
            1. `myblock`表面上是一个函数指针，但本质上是一个`__main_block_impl_0`结构体对象类型的指针
            2. 为何可以强制转换成`__block_impl`对象指针，而且可以直接从里面取出成员`FuncPtr`呢？
            3. 原因分析：
                1. ` __main_block_impl_0`对象内部的第一个成员是`__block_impl的impl`，**根据对象在内存中存储的本质，对象的地址 == 第一个成员变量的地址**。
                2.  因此`__main_block_impl_0`对象的地址，就是他的第一个成员变量的地址，因此可以直接强制转换，而且去取成员变量不会报错。

### block的变量捕获（capture） 
1. 为了保证block内部能够正常访问外部的变量，block有个变量捕获机制
    1. 局部变量
        1. 自动变量（auto）：会捕获到block内部，但是捕获到的仅仅是变量的值，值传递
            1. **自动变量的内存随时会销毁，所以不能捕获地址！！！**
        2. 静态变量（static）：会捕获到block内部，但是捕获到的是变量的地址，指针传递
    2. 全局变量
        1. 不会捕获到block内部，使用时直接可以访问。
2. 举例论证：
    1. OC代码：
        
        ```
        //全局变量
        int g_var = 9;
        
        int main(int argc, const char * argv[]) {
            @autoreleasepool {
                //自动变量 auto
                int age = 10;
                
                //static变量
                static int height = 20;
                void (^myblock)(void) = ^{
                    //将外部的age捕获进来
                    NSLog(@"====%d===%d====%d",age,height,g_var);
                };
                age = 20;
                height = 30;
                g_var = 10;
                //打印 ====10===30====10
                myblock();
            }
            return 0;
        }

        ```
    2. 编译成C++,核心代码
        
        ```
        int g_var = 9;
        struct __main_block_impl_0 {
            struct __block_impl impl;
            struct __main_block_desc_0* Desc;
            //age成员，值
            int age;
            //height成员，注意这里是指针！！！
            int *height;
            //构造函数，带有初始化列表，默认参数
            __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int *_height, int flags=0) : age(_age), height(_height) {
                impl.isa = &_NSConcreteStackBlock; //block类型
                impl.Flags = flags;
                impl.FuncPtr = fp;
                Desc = desc;
            }
        };
        
        static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
            
            //值传递
            int age = __cself->age; // bound by copy
            //指针传递
            int *height = __cself->height; // bound by copy
            //__cself取值age 、 *height
            //g_var直接取值
            NSLog((NSString *)&__NSConstantStringImpl__var_folders_t2_d94848jx1fq4vd6k8qcsfdq00000gn_T_main_f0817d_mi_0,age,(*height),g_var);
        }
        
        static struct __main_block_desc_0 {
          size_t reserved;
          size_t Block_size;
        } __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};
        int main(int argc, const char * argv[]) {
            /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; 
        
                int age = 10;
        
        
                static int height = 20;
                void (*myblock)(void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, age, &height));
                age = 20;
                height = 30;
                g_var = 10;
        
                ((void (*)(__block_impl *))((__block_impl *)myblock)->FuncPtr)((__block_impl *)myblock);
            }
            return 0;
        }
        ```
        


