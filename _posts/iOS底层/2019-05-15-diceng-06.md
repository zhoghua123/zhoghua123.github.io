---
layout: post
title: iOS底层-Block的本质
category: iOS底层
tags: iOS底层
description: iOS底层
---

## Block的本质
1. block本质上也是一个OC对象，它内部也有个isa指针
2. block是封装了函数调用以及函数调用环境的OC对象
3. block的底层结构如右图所示
    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/diceng12.png)
4. 编译分析
    1. OC代码
        
        ```
        int main(int argc, const char * argv[]) {
            @autoreleasepool {
                void (^myblock)(void) = ^{
                    NSLog(@"myblock");
                };
                
                myblock();
            }
            return 0;
        }
        ```
    2. 通过编译后，取出核心代码如下：**注意这里从C++角度分析！！！**
        
        ```
         //结构体__block_impl对象
         struct __block_impl {
             void *isa;
             int Flags;
             int Reserved;
             void *FuncPtr;
         };
         //C++中的对象，就是那个结构体的原型
         struct __main_block_impl_0 {
         
             struct __block_impl impl;
             struct __main_block_desc_0* Desc;
         
            //构造函数，带有初始化列表，默认参数
             __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {
                 impl.isa = &_NSConcreteStackBlock; //block的类型
                 impl.Flags = flags;
                 impl.FuncPtr = fp;
                 Desc = desc;
             }
         };
         
         //静态函数
         static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
         
             NSLog((NSString *)&__NSConstantStringImpl__var_folders_t2_d94848jx1fq4vd6k8qcsfdq00000gn_T_main_448c61_mi_0);
         }
         
         //创建一个静态结构体变量__main_block_desc_0_DATA并初始化
         static struct __main_block_desc_0 {
             size_t reserved;//保留字
             size_t Block_size;//block的大小
         } __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};
         
         //main函数
         int main(int argc, const char * argv[]) {
             { __AtAutoreleasePool __autoreleasepool;
         
                 //因此block本质是一个__main_block_impl_0结构体对象指针
                 void (*myblock)(void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA));
                 //函数调用：把myblock转化成__block_impl* 类型，取出FuncPtr成员函数，然后调用
                 ((void (*)(__block_impl *))((__block_impl *)myblock)->FuncPtr)((__block_impl *)myblock);
             }
        return 0;
        }
        ```
        
        1. block本质就是一个`__main_block_impl_0`类型的结构体对象指针
        2. 疑问难点：
            
            ```
            ((void (*)(__block_impl *))((__block_impl *)myblock)->FuncPtr)((__block_impl *)myblock);
            ```
            
            1. `myblock`表面上是一个函数指针，但本质上是一个`__main_block_impl_0`结构体对象类型的指针
            2. 为何可以强制转换成`__block_impl`对象指针，而且可以直接从里面取出成员`FuncPtr`呢？
            3. 原因分析：
                1. ` __main_block_impl_0`对象内部的第一个成员是`__block_impl的impl`，**根据对象在内存中存储的本质，对象的地址 == 第一个成员变量的地址**。
                2.  因此`__main_block_impl_0`对象的地址，就是他的第一个成员变量的地址，因此可以直接强制转换，而且去取成员变量不会报错。


