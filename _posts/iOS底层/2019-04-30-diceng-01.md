---
layout: post
title: iOS底层-01
category: iOS底层
tags: iOS底层
description: iOS底层
---

## OC对象的本质
1. 简介
    1. 我们平时编写的Objective-C代码，底层实现其实都是C\C++代码
        1. OC->C/C++->汇编语言->机器语言
    2. 所以Objective-C的面向对象都是基于C\C++的数据结构实现的
    3. 思考：Objective-C的对象、类主要是基于C\C++的什么数据结构实现的？
        1. 结构体
2. 如何将OC代码转化为C++代码？ 
    1. 打开终端cd 到想要转化的文件目录，输入一下命令
    2. `xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc OC源文件 -o 输出的CPP文件`
        1. xcrun：xcode run
        2. -sdk  iphoneos: sdk  运行在iOS平台
        3. clang：Xcode内置的编译器
        4. -arch  arm64 ： 编译后支持的架构
        5. -rewrite-objc ：重写OC代码
        6. -o： 写入到哪个文件
    3. 如果需要链接其他框架，使用-framework参数。比如-framework UIKit
3. 一个OC对象在内存中是如何布局的
    1. main.m实现如下代码
        
        ```
        int main(int argc, const char * argv[]) {
            @autoreleasepool {
                NSObject *obj = [[NSObject alloc] init];
            }
            return 0;
        }
        ```
        
        1. command 右击进入NSObject类,定义如下：
            
            ```
             //command右击进入NSObject类
             @interface NSObject {
             Class isa ;
             }
             @end
            ```
    2. 转化成cpp，然后搜索NSObject可以搜索到NSObject的类定义如下：
        
        ```
        struct NSObject_IMPL {
            Class isa;
        };
        ```
        
    3. 说明一下问题：
        1. 说明在C/C++中NSObject类就是一个结构体，含有一个成员变量isa，那么Class呢？
        2. command右击进入Class类:
            
            ```
            typedef struct objc_class *Class;
            ```
            
            1. 发现Class就是一个结构体指针，在Arm64位中，一个指针占8个字节
            2. 因此，**推断**NSObject占据8个字节
                
                ```
                NSObject *obj = [[NSObject alloc] init];
                这句话那么就是分配一个8个字节的内存，然后把地址赋值给obj变量
                而且该地址也是isa的地址
                ```
    4. 用一些计算内存的方法验证一下：
        
        ```
        #import <Foundation/Foundation.h>
        #import <objc/runtime.h>
        #import <malloc/malloc.h>
        int main(int argc, const char * argv[]) {
            @autoreleasepool {
                NSObject *obj = [[NSObject alloc] init];
                
                // 获得NSObject实例对象的成员变量所占用的大小结果为： 8
                NSLog(@"%zd", class_getInstanceSize([NSObject class]));
                
                // 获得obj指针所指向内存的大小结果为：16
                NSLog(@"%zd", malloc_size((__bridge const void *)obj));
            }
            return 0;
        }
        ```
        
        1. 那么这两个方法哪个计算的真的呢？
        2. 查找苹果官方源码，地址：https://opensource.apple.com/tarballs
            1. 在里面搜索objc，找到obc4进入下载最新的即可
            2. 打开源码项目，搜索class_getInstanceSize，找到实现，如下：
                
                ```
                size_t class_getInstanceSize(Class cls)
                {
                    if (!cls) return 0;
                    return cls->alignedInstanceSize();
                }
                ```
                
                1. 由此可见class_getInstanceSize方法仅仅是返回了一个类成员变量实例大小，并不是整个类的内存分配大小
    5. 结论：一个NSOject对象的内存大小是16个字节，但是实际上只用了8个字节
        
            



