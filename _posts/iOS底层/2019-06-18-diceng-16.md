---
layout: post
title: iOS底层-内存管理(二)
category: iOS底层
tags: iOS底层
description: iOS底层
---  

## 内存布局

### Tagged Pointer
1. 从64bit开始，iOS引入了`Tagged Pointer`技术，用于优化NSNumber、NSDate、NSString等小对象的存储
2. 在没有使用`Tagged Pointer`之前， NSNumber等对象需要动态分配内存、维护引用计数等，`NSNumber`指针存储的是堆中`NSNumber`对象的地址值
3. 使用`Tagged Pointer`之后，`NSNumber`指针里面存储的数据变成了：`Tag + Data`，也就是将数据直接存储在了指针中(Tag指的是数据类型)
    1. 即用指针类型(8个字节)存储`Tag+Data`
4. 当指针不够存储数据时，才会使用动态分配内存的方式来存储数据
5. `objc_msgSend`能识别`Tagged Pointer`，比如NSNumber的`intValue`方法，直接从指针提取数据，节省了以前的调用开销
6. 如何判断一个指针是否为`Tagged Pointer`？
    1. iOS平台，最高有效位是1（第64bit）
    2. Mac平台，最低有效位是1
    3. objc源码证明：
        1. `struct objc_object`这个结构体对象有个判断当前对象是否是`taggedPointer`的成员函数`isTaggedPointer`
            ```
            //判断当前对象是否是TaggedPointer
            bool isTaggedPointer();
            inline bool objc_object::isTaggedPointer() 
            {
                return _objc_isTaggedPointer(this);
            }
            
            static inline bool _objc_isTaggedPointer(const void * _Nullable ptr)
            {
                return ((uintptr_t)ptr & _OBJC_TAG_MASK) == _OBJC_TAG_MASK;
            }
            
            //_OBJC_TAG_MASK的宏定义
            #if (TARGET_OS_OSX || TARGET_OS_IOSMAC) && __x86_64__
            // 64-bit Mac - tag bit is LSB //mac开发64位
            #   define OBJC_MSB_TAGGED_POINTERS 0
            #else
                // Everything else - tag bit is MSB 其他开发
            #   define OBJC_MSB_TAGGED_POINTERS 1
            #endif
            
            #if OBJC_MSB_TAGGED_POINTERS
            #   define _OBJC_TAG_MASK (1UL<<63)  //第一位为1
            #else
            #   define _OBJC_TAG_MASK 1UL //最后一位为1
            #endif
            ```
        2. 那么TaggedPointer是如何编码的呢？
            
            ```
            static inline void * _Nonnull  _objc_makeTaggedPointer(objc_tag_index_t tag, uintptr_t value)
            {
                // PAYLOAD_LSHIFT and PAYLOAD_RSHIFT are the payload extraction shifts.
                // They are reversed here for payload insertion.
            
                // assert(_objc_taggedPointersEnabled());
                if (tag <= OBJC_TAG_Last60BitPayload) {
                    // assert(((value << _OBJC_TAG_PAYLOAD_RSHIFT) >> _OBJC_TAG_PAYLOAD_LSHIFT) == value);
                    uintptr_t result =
                        (_OBJC_TAG_MASK | 
                         ((uintptr_t)tag << _OBJC_TAG_INDEX_SHIFT) | 
                         ((value << _OBJC_TAG_PAYLOAD_RSHIFT) >> _OBJC_TAG_PAYLOAD_LSHIFT));
                    //编码
                    return _objc_encodeTaggedPointer(result);
                } else {
                    // assert(tag >= OBJC_TAG_First52BitPayload);
                    // assert(tag <= OBJC_TAG_Last52BitPayload);
                    // assert(((value << _OBJC_TAG_EXT_PAYLOAD_RSHIFT) >> _OBJC_TAG_EXT_PAYLOAD_LSHIFT) == value);
                    uintptr_t result =
                        (_OBJC_TAG_EXT_MASK |
                         ((uintptr_t)(tag - OBJC_TAG_First52BitPayload) << _OBJC_TAG_EXT_INDEX_SHIFT) |
                         ((value << _OBJC_TAG_EXT_PAYLOAD_RSHIFT) >> _OBJC_TAG_EXT_PAYLOAD_LSHIFT));
                    //编码
                    return _objc_encodeTaggedPointer(result);
                }
            }
            
            //编码
            static inline void * _Nonnull _objc_encodeTaggedPointer(uintptr_t ptr)
            {
                return (void *)(objc_debug_taggedpointer_obfuscator ^ ptr);
            }
            //解码
            static inline uintptr_t _objc_decodeTaggedPointer(const void * _Nullable ptr)
            {
                return (uintptr_t)ptr ^ objc_debug_taggedpointer_obfuscator;
            }
            
            //objc_debug_taggedpointer_obfuscator 的初始化
            static void initializeTaggedPointerObfuscator(void)
            {
                //mac_os< 10.14 和 iOS< 12.0 
                if (sdkIsOlderThan(10_14, 12_0, 12_0, 5_0, 3_0) ||
                    // Set the obfuscator to zero for apps linked against older SDKs,
                    // in case they're relying on the tagged pointer representation.
                    DisableTaggedPointerObfuscation) {
                    objc_debug_taggedpointer_obfuscator = 0;
                } else {
                    // Pull random data into the variable, then shift away all non-payload bits.
                    arc4random_buf(&objc_debug_taggedpointer_obfuscator,
                                   sizeof(objc_debug_taggedpointer_obfuscator));
                    objc_debug_taggedpointer_obfuscator &= ~_OBJC_TAG_MASK;
                }
            }
            ```
        3. 分析：
            1. 可以看到一个对象通过`_objc_makeTaggedPointer`函数创建一个TaggedPointer
            2. `_objc_makeTaggedPointer`内部本质调用了`_objc_encodeTaggedPointer`进行编码
            3. `_objc_encodeTaggedPointer`的本质是对ptr进行了异或操作与`objc_debug_taggedpointer_obfuscator`
            4. `objc_debug_taggedpointer_obfuscator`这个值很有**特点**：
                1. 在MAC_OS<14.0，iOS<12.0时，`objc_debug_taggedpointer_obfuscator` = 0 ;
                2. 反之：`objc_debug_taggedpointer_obfuscator &= ~_OBJC_TAG_MASK;`
                3. `_OBJC_TAG_MASK`又根据当前是mac或者非mac取不同的值
            
7. 由于当前的平台是MAC_OS>14,与iOS>12,因此，打印出来的值并不是tag+Data，因此我们需要手动实现_objc_decodeTaggedPointer方法:
    1. iOS平台时
        
        ```
        
        ```
    
    1. 例1：
        
        ```
        int main(int argc, char * argv[])
        {
            @autoreleasepool {
                NSNumber *number1 = @1;
                NSNumber *number2 = @2;
                NSNumber *number3 = @3;
                NSNumber *numberFFFF = @(0xFFFF);
                
                NSLog(@"number1 pointer is %p", number1);
                NSLog(@"number2 pointer is %p", number2);
                NSLog(@"number3 pointer is %p", number3);
                NSLog(@"numberffff pointer is %p", numberFFFF);
                return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
            }
        }
        
        //打印
        number1 pointer is 0xb000000000000012
        number2 pointer is 0xb000000000000022
        number3 pointer is 0xb000000000000032
        numberFFFF pointer is 0xb0000000000ffff2
        ```
    2. 例2:
        ```
        /**
         会崩溃
         因为self.name的本质是掉用set方法
         -(void)setName:(NSString *)name{
         if (name != _name) {
         //n个线程同时访问，就会一个对象多次释放，崩溃
         [_name release];
         _name = [name copy];
         }
         }
        */
        dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
        for (int i = 0; i<1000; i++) {
            dispatch_async(queue, ^{
                //会崩溃
                //self.name = [NSString stringWithFormat:@"abcdefghijk"];
                //不会崩溃,是Tagged Pointer不是oc对象，因此不会调用set方法
                self.name = [NSString stringWithFormat:@"abc"];
            });
        }
        ```

