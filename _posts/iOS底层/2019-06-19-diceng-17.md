---
layout: post
title: iOS底层-内存管理(二)
category: iOS底层
tags: iOS底层
description: iOS底层
---   

## OC对象的内存管理 
1. 在iOS中，使用**引用计数**来管理OC对象的内存
2. 一个新创建的OC对象引用计数默认是1，当引用计数减为0，OC对象就会销毁，释放其占用的内存空间
3. 调用retain会让OC对象的引用计数+1，调用release会让OC对象的引用计数-1
4. 内存管理的经验总结
    1. 当调用alloc、new、copy、mutableCopy方法返回了一个对象，在不需要这个对象时，要调用release或者autorelease来释放它
    2. 想拥有某个对象，就让它的引用计数+1；不想再拥有某个对象，就让它的引用计数-1
5. 以上的示例以及详解**清空OC语法-内存管理部分**，这里不再详细讲
6. 可以通过以下私有函数来查看自动释放池的情况
    1. `extern void _objc_autoreleasePoolPrint(void); `

### 引用计数的存储
1. 前面讲runtime的isa的本质的时候讲过，isa使用位域技术存储一些数据，其中就有引用计数器的值
    
    ```
    uintptr_t has_sidetable_rc  : 1;
    uintptr_t extra_rc          : 19;
    ```
    
    1. 里面存储的值是引用计数器减1
    2. 当引用计数器是否过大无法存储在isa中时，has_sidetable_rc至1，引用计数会存储在一个叫SideTable的类的属性中
2. 在64bit中，引用计数可以直接存储在优化过的isa指针中，也可能存储在SideTable类中
    
    ```
    struct SideTable {
        spinlock_t slock;
        //map容器，相当于字典
        RefcountMap refcnts;
        weak_table_t weak_table;
        ...
    }
    ```
    
    1. refcnts是一个存放着对象引用计数的散列表
3. retainCount方法的源码
    
    ```
    //返回引用计数器的值
    - (NSUInteger)retainCount {
        return ((id)self)->rootRetainCount();
    }
    //获取引用计数器的值
    inline uintptr_t 
    objc_object::rootRetainCount()
    {
        //1. 如果是TaggedPointer（当前不是对象类型），直接返回自己
        if (isTaggedPointer()) return (uintptr_t)this;
        
        //可能会多线程同时访问一个容器，因此需要加锁
        //加锁
        sidetable_lock();
        
        //2. 拿到isa的bits
        isa_t bits = LoadExclusive(&isa.bits);
        
        ClearExclusive(&isa.bits);
        //3. 判断是否采用位域技术优化，即isa位域存储优化
        if (bits.nonpointer) {
            //3.1 是isa优化，那么就到isa的位中分离出来
            
            // extra_rc+1 = 引用计数器的值
            uintptr_t rc = 1 + bits.extra_rc;
            
            //3.2 判断extra_rc是否不够存储，即是否存满，足够存储，直接返回r
            if (bits.has_sidetable_rc) {
                //3.3 不够存储，到sidetable找，此时的引用计数器=extra_rc+1 + sidetable存储的值
                rc += sidetable_getExtraRC_nolock();
            }
            //解锁
            sidetable_unlock();
            return rc;
        }
        //解锁
        sidetable_unlock();
        //4. 没有采用位域技术，即isa仅仅存储的是地址，那么就直接到sidetable类中找
        return sidetable_retainCount();
    }
    
    /**
     额外的引用计数器值
    当前isa的extra_rc位不够存储，即has_sidetable_rc为1时，多余的计数器值会存储到这里
     @return 额外的计数器值
     */
    size_t
    objc_object::sidetable_getExtraRC_nolock()
    {
        assert(isa.nonpointer);
        SideTable& table = SideTables()[this];
        //map容器查找，采用指示器
        RefcountMap::iterator it = table.refcnts.find(this);
        //没有找到
        if (it == table.refcnts.end()) return 0;
        //找到了，返回： it->second值，右移2位
        else return it->second >> SIDE_TABLE_RC_SHIFT;
    }
    
    /**
     isa是非位域优化指针时
     直接到sidetable类中查找引用计数器的值
    
     @return 值
     */
    uintptr_t
    objc_object::sidetable_retainCount()
    {
        //拿到table
        SideTable& table = SideTables()[this];
       
        size_t refcnt_result = 1;
        
        table.lock();
        RefcountMap::iterator it = table.refcnts.find(this);
        if (it != table.refcnts.end()) {//指示器不是最后一位，即计数器的值不为0
            //返回引用计数器的值：it->second 右移2位，然后+1
            // this is valid for SIDE_TABLE_RC_PINNED too
            refcnt_result += it->second >> SIDE_TABLE_RC_SHIFT;
        }
        table.unlock();
        return refcnt_result;
    }
    ```


