---
layout: post
title: CPP应用-外挂开发(一)
category: CPP基础
tags: CPP基础
description: CPP基础
---    

1. 开发一个外挂程序的步骤
    1. 外挂界面
    2. 事件处理
        1. 监听外挂界面上面的按钮事件等
    3. 跨进程访问
        1. 用于控制实际的应用

## 外挂界面
1. Windows平台的桌面开发
    1. 使用C++开发
        1. MFC、Qt
    2. 使用C#开发
        1. WinForm、WPF
2. 我们课程选用最古老的MFC，不用引入其他外部的框架
3. 要先安装好MFC组件
4. 创建MFC项目
    1. 打开vs新建项目->visual C++  -> MFC应用程序 ->选择路径、命名->下一步
    2. 应用程序类型选择：基于对话框 ，然后点击完成即可
    3. 此时点击f5运行程序就出现一个简单的弹框界面应用程序
5. 搭建界面
    1. 找到界面(就相当于iOS的xib界面)
        1. 顶部工具栏->视图->其他窗口->资源视图->项目名文件夹下->dialog->IDD_项目名大写_DIALOG双击打开
    2. 修改左上角的logo
        1. 右击项目文件->打开文件夹->res->换掉里面的ico图片就行了
    3. 修改窗口标题
        1. 右击界面->属性->外观->caption（输入标题即可）
    4. 增删界面控件
        1. 删除：点击控件，点击delete即可
        2. 添加：
            1. 视图->工具箱->里面有很多控件
            2. 拖拽到界面即可
            3. 右击控件属性，选择外观，可以设置样式
    5. 监听事件（相当于iOS中的xib脱线成方法）
        1. 事件注册 – 手动
            1. 给控件设置唯一ID
                1. 右击控件属性->杂项->ID->右边重命名（ID_COURSE）
                2. 点击原来项目->头文件->Resource.h
                    1. 在这文件中可以看到一堆宏定义，其中就有（ID_COURSE）
            2. 声明、实现事件函数
                1. 凡是DIALOG界面的空间，绑定代码都在源文件的：项目名Dlg.cpp中写
                2. 首先在：”项目名Dlg.h“ 中新增函数声明
                3. 在”项目名Dlg.cpp“中新增函数实现
            3. 将控件与事件函数通过控件ID绑定
                
                ```
                //消息映射开始
                BEGIN_MESSAGE_MAP(CPVZCheaperDlg, CDialogEx)
                	ON_WM_SYSCOMMAND()
                	ON_WM_PAINT()
                	ON_WM_QUERYDRAGICON()
                	//ON_BN_CLICKED:按钮单击，参数：id按钮的，对应的函数
                	ON_BN_CLICKED(ID_COURSE, CPVZCheaperDlg::OnBnClickedCourse)
                	//消息隐射结束
                END_MESSAGE_MAP()
                ```
            4. 如下图：
                ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/cpp31.png)
                
        2. 事件注册 – 自动(也可以直接双击控件)
            1. 给控件设置唯一ID（同手动）
            2. 声明、实现事件函数/将控件与事件函数通过控件ID绑定--自动方式生成
                1. 右击控件-> 添加事件处理程序->选择消息类型（点击、长按等)/修改函数处理程序名称->点击添加编辑即可 （直接双击控件等价于当前所有操作）  
                2. 注意：手动监听控件的第2、3步，都在这里自动实现了 
6. 绑定成员变量（相当于iOS中XIB中的控件脱线成成员变量）
    1. 绑定成员变量 – 手动
        1. 给控件设置唯一ID（同监听事件）
        2. 声明成员变量
            1. 项目名Dlg.h中声明一个成员变量`CButton m_kill;`
        3. 将成员变量与控件通过ID绑定
            2. 项目名Dlg.cpp中DoDataExchange函数中进行绑定
                
                ```
                DDX_Control(pDX, IDC_KILL, m_kill);
                ```
    2. 绑定成员变量 – 自动
        1. 给控件设置唯一ID（同手动）
        2. 右击控件->添加变量->设置控件的属性(名称、权限等)->点击下一步即可（手动绑定成员变量的第2、3步，都在这里自动实现了） 
7. MFC开发中的打印
    1. TRACE函数:类似于C语言的printf，只能在DEBUG调试模式下看到打印信息(F5启动)
        
        ```
        TRACE("age is %d\n",20);
        ```
    2. AfxMessageBox函数(弹框提示)
        
        ```
        CString str;
        	str.Format(CString("age is %d"),20);
        	AfxMessageBox(str);
        ```
    3. MessageBox函数:只在CWnd的子类中使用，功能比AfxMessageBox多
        
        ```
        CString str;
        	str.Format(CString("age is %d"),20);
        MessageBox(str);
        MessageBox(str,CString("错误")，MB_YESNO|MB_ICONERROR);
        ```
    4. 自定义log宏，简化打印
        
        ```
        # define log(fmt,...)\
        CString str; \
        str.Format(CString(fmt),_VA_ARGS_);\
        AfxMessageBox(str);
        
        
        //使用
        log("age is %d\n",20);
        ```
8. 常用方法
    1. 打开URL
    
        ```
        ShellExecute(NULL, CString("open"), CString("www.baidu.com"), NULL, NULL, SW_SHOWNORMAL);
        ```
    2. 单选框的状态读取和修改 
        1. 方法1：
            
            ```
            //读取，参数为单选框控件的ID
            BOOL state = IsDlgButtonChecked(IDC_CHOSE1)
            //修改
            CheckDlgButton(IDC_CHOSE1, true);
            ```
        2. 方法2；
            
            ```
            CButton *button = (CButton *)GetDlgItem(IDC_CHOSE1);
            //读取
            BOOL state = button->GetCheck();
            //修改
            button->SetCheck(true);
            ```
        3. 方法3:
            1. 将按钮设置为成员变量,然后通过成员变量获取/设置
            
            ```
            //读取
            BOOL state = this->m_kill.GetCheck();
            //修改
            this->m_kill.SetCheck(true);
            ```
  
## 软件破解 
1. 请查看汇编部分最后一节：软件破解

## 植物大战僵尸外挂
1. 外挂常用工具：
    1. Cheat Engine
        1. 安装：解压之后双击文件夹中的Cheat Engine.exe运行  
        2. 作用：
            1. 点击左上角的电脑+放大镜图标，会显示当前PC机的所有应用进程
            2.  选择一个应用进程，点击打开
            3. 右边的输入框Hex是用于搜索的值（还有其他的筛选条件等），点击扫描，就可以搜索出来当前进程中那个地址内存存储到了当前值。
            4. 主要作用就是**监控某一个进程的内存，根据某个索引找到对应进程中的内存地址，然后双击相应的内存地址就可以修改内存中的数据**。
            5. 找到内存地址了，就可以修改内存的数据，达到破解的目的。
2. 外挂的本质
    1. 常见的外挂功能有2种做法
        1. 修改内存中的数据
            1. 数据的话，变量地址值可以是固定的，也可以是变化的
            2. 如果是全局变量，那么他的地址值就是固定的，这就比较容易找
            3. 如果是局部变量，那么他的地址值就是变化的，这就比较难找（通过基地址+偏移量定位）
        2. 修改内存中的代码
            1. 比较容易一些，因为代码段的内存地址在内存中是固定的。每局代码的内存地址在exe文件中都已经固定了。
    2. 其实数据和代码并没有本质区别, 在内存中都是0和1
 

### 植物大战僵尸详细破解步骤
1. 工具
    1. OD（OllyDbg）
        1. 用来剖析exe文件，形成汇编
    2. CE(Cheat Engine)
        1. 用来定位想要破解的东西的内存地址
    3. 植物大战僵尸程序exe
        1. 要破解的对象
    4. VS
        1. 通过MFC来编写外挂Windows应用程序界面
        2. 通过Windows API来跨进程修改目标应用程序的内存地址
2. 实现功能：
    1. 外挂界面监控游戏的打开关闭
    2. 无限阳光
    3. 秒杀僵尸
3. 破解步骤（这里只讲解秒杀僵尸、外挂界面监控）
    1. 获取减少僵尸生命值的汇编代码对应的内存地址
        1. 通过CE定位，获取僵尸生命值的内存地址
            1. 打开CE运行起来
            2. 打开植物大战僵尸游戏
            3. 点击CE左上角（放大镜+电脑）选择植物大战僵尸应用进程
            4. 切换至游戏，等待僵尸出来
            5. 切换CE条件选择“未知的初始值”，首次扫描
            6. 切换至游戏，然后在切换至CE，条件选择“未变化的值”，再次扫描
            7. 切换游戏，用豌豆打僵尸一枪，切换至CE，条件选择“减少的数值”，再次扫描
            8. 循环6，7，就可以定位到僵尸生命值那个内存地址了
            9. 双击左边的地址，在下面的内存浏览（双击数值）就能修改这些值
            10. 在内存浏览中右击地址，选择”找出是什么改写了这个地址“
            11. 切换到游戏，一旦打中僵尸，就可以看到是那句汇编代码起到了这个作用
            12. 根据这个汇编代码的地址值，比如：`00531319`
        2. 根据CE定位的内存地址，在OD中寻找相应的汇编代码
            1. 运行OD，将植物大战僵尸exe拖入OD
            2. control+G搜索这个地址值，就能定位到那句汇编代码
        3. 前两步定位的结果如下：
            
            ```
            //1. CE中根据内存地址00531319定位到的汇编代码
            00531313 - 89 44 24 1C  - mov [esp+1C],eax
            00531317 - 8B C5  - mov eax,ebp
            00531319 - 89 BD C8000000  - mov [ebp+000000C8],edi <<
            0053131F - E8 ECC3FFFF - call PlantsVsZombies.exe+12D710
            00531324 - 8B D8  - mov ebx,eax
            
            
            //2. 通过00531319在OD中 搜索定位到的代码
            //地址        16进制源码          对应的汇编代码
            //这一句是sub，是每打一次，僵尸的生命值减少
            0053130F  |.  2B7C24 20          sub edi,dword ptr ss:[esp+0x20]
            00531313  |.  894424 1C          mov dword ptr ss:[esp+0x1C],eax          ;  kernel32.BaseThreadInitThunk
            00531317  |.  8BC5               mov eax,ebp
            //定位：这一句是赋值僵尸的生命值
            00531319  |.  89BD C8000000      mov dword ptr ss:[ebp+0xC8],edi
            
            
            //3. 因此分析，只要将地址0053130F是这个的汇编代码换成如下即可
            // sub edi,edi
            
            //4. 在OD中双击这句汇编，然后修改为sub edi，edi，然后这段汇编变成如下：
            
            0053130F      2BFF               sub edi,edi
            00531311      90                 nop
            00531312      90                 nop
            00531313  |.  894424 1C          mov dword ptr ss:[esp+0x1C],eax          ;  kernel32.BaseThreadInitThunk
            00531317  |.  8BC5               mov eax,ebp
            00531319  |.  89BD C8000000      mov dword ptr ss:[ebp+0xC8],edi
            
            //因此分析，只要将内存中的源码由原来的2B7C2420改为2BFF9090即可
            ```
    2. 通过VS编写windows 外挂程序
        1. 下面是需要写的代码
            
            ```
            PVZCheaperDlg.cpp: 实现文件
            
            //指向对话框的指针
            static CPVZCheaperDlg *g_dlg = NULL;
            
            // 用来监控的线程
            static HANDLE g_monitorThead = NULL;
            
            //植物大战僵尸的进程句柄
            static HANDLE g_process = NULL;
            
            /*
            写内存
            */
            void WriteMemory(void *value, DWORD valueSize, ...)
            {
            	if (value == NULL || valueSize == 0 || g_process == NULL) return;
            
            	DWORD tempValue = 0;
            
            	va_list addresses;
            	va_start(addresses, valueSize);
            	DWORD offset = 0;
            	DWORD lastAddress = 0;
            	//根据0x6A9EC0, 0x320, 0x8, 0x0, 0x8, 0x144, 0x2c, 0x5560， -1这些数据遍历便宜找到阳光地址值
            	while ((offset = va_arg(addresses, DWORD)) != -1)
            	{
            		//加上偏移量
            		lastAddress = tempValue + offset;
            		//取地址对应的值
            		ReadProcessMemory(g_process, (LPCVOID)lastAddress, &tempValue, sizeof(DWORD), NULL);
            	}
            	va_end(addresses);
            	//写入到内存，参数：进程句柄、要写入到的内存地址、值、值有多大
            	//往哪个应用进程的内存中写入哪些数据
            	WriteProcessMemory(g_process, (LPVOID)lastAddress, value, valueSize, NULL);
            }
            
            /*
            value: 要写入数据的内存地址
            valueSize：数据有多大
            address：内存地址
            */
            void WriteMemory(void *value, DWORD valueSize, DWORD address) {
            	WriteMemory(value, valueSize, address, -1);
            }
            

            //用来监控线程
            DWORD WINAPI monitorThreadFunc(LPVOID lpThreadParameter) {
            
            	while (true)
            	{
            		//1. 监控植物大战僵尸是否打开、关闭
            		//该函数用户发现当前桌面是否有某个窗口，参数有2个，类名、窗口名
            		/*
            		如何知道某个窗口的类名和窗口名呢？ 通过Spy++
            		VS->工具->spy++->点击“望远镜+文本”图标->鼠标按住查找程序工具右边的靶子，然后移动鼠标到你
            		想要知道的窗口即可以找到类和窗口名称
            		*/
            		HWND window = FindWindow(CString("MainWindow"),CString("植物大战僵尸中文版"));
            		if (!window)
            		{
            			//没有打开植物大战僵尸窗口
            			//2个勾选按钮失效，而且取消勾选
            			g_dlg->m_kill.EnableWindow(false);
            			g_dlg->m_sun.EnableWindow(false);
            			g_dlg->m_kill.SetCheck(false);
            			g_dlg->m_sun.SetCheck(false);
            		}
            		else if(!g_process)//只需要获取一次植物大战僵尸的进程句柄
            		{
            			// 获取植物大战僵尸的进程句柄
            			//进程id
            			DWORD pid = NULL;
            			//通过一个窗口获取当前进程的id
            			GetWindowThreadProcessId(window, &pid);
            			//根据id获取进程的句柄（用于操作进程）
            			g_process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
            
            			//打开了植物大战僵尸窗口
            			//2个勾选按钮生效
            			g_dlg->m_kill.EnableWindow(true);
            			g_dlg->m_sun.EnableWindow(true);
            		}	
            
            		// 每隔1s修改一次阳光值，并且是在勾选无限阳光的基础下才可以
            		if (g_dlg->m_sun.GetCheck())
            		{
            			/*
            			1. 阳光值是一个数据段，如果这个数据段的变量是全局变量，那么整个内存中的内存地址是不变的。但是，如果是局部变量，每次重新分配，地址值不一样，所以无法固定
            			2. 如何才能定位到阳光值呢？
            			3. 我们不能定位到阳光值，但是我们可以定位到阳光对象，然后通过对象的偏移量就可以找到阳光值
            			就是这个
            			 0x6A9EC0, 0x320, 0x8, 0x0, 0x8, 0x144, 0x2c, 0x5560， -1
            			 0x6A9EC0是基址
            			 -1代表结束
            			 其他的是偏移量
            			 根据基址0x6A9EC0取值，然后加上偏移量0x320，取值，在加偏移量0x8，。。。，直到遇到-1停止，就是阳光的地址值
            			*/
            			DWORD value = 9990;
            			WriteMemory(&value, sizeof(value), 0x6A9EC0, 0x320, 0x8, 0x0, 0x8, 0x144, 0x2c, 0x5560, -1);
            		}
            
            		Sleep(1000);
            	}
            	return 0;
            }
            
            // CPVZCheaperDlg 消息处理程序
            //当界面初始化完毕时回调用这个方法相当于OC中的ViewDidload
            BOOL CPVZCheaperDlg::OnInitDialog()
            {
            	CDialogEx::OnInitDialog();
            	//系统默认的。。。。略
            // TODO: 在此添加额外的初始化代码
            	//保存当前对话框
            	g_dlg = this;
            	//创建一个子线程用于：1. 间隔性的自动修改阳光值，使阳光值永远用不完 2.实时监控植物大战僵尸的程序开关状态
            	//HANDLE：句柄
                //设置成全局变量
            	//HANDLE monitorThead = CreateThread(NULL,0,monitorThreadFunc,NULL,0,NULL);
            	g_monitorThead = CreateThread(NULL, 0, monitorThreadFunc, NULL, 0, NULL);
            	//终止线程
            	//TerminateThread(g_monitorThead, 0);
            
            	return TRUE;  // 除非将焦点设置到控件，否则返回 TRUE
            }	
            
            	
            //点击打开一个网页
            void CPVZCheaperDlg::OnBnClickedCourse() {
            	/*TRACE("======");
            	CString str;
            	str.Format(CString("age is %d"),20);
            	AfxMessageBox(str);*/
            	ShellExecute(NULL, CString("open"), CString("www.baidu.com"), NULL, NULL, SW_SHOWNORMAL);
            
            
            	//BOOL state = this->m_kill.GetCheck();
            	//this->m_kill.SetCheck(true);
            }
            
            //点击是否需要无限阳光
            void CPVZCheaperDlg::OnBnClickedCheck1()
            {
            	// TODO: 在此添加控件通知处理程序代码
            	//获取到当前按钮的选择状态
            	//IsDlgButtonChecked(IDC_CHOSE1)
            
            	if (IsDlgButtonChecked(IDC_CHOSE1)){
            	//勾选
            		//AfxMessageBox(CString("需要无限阳光"));
            	}else{
            	//没有勾选
            		//AfxMessageBox(CString("不需要无限阳光"));
            	}
            }
            
            //点击是否需要秒杀僵尸
            void CPVZCheaperDlg::OnBnClickedKill()
            {
            	// TODO: 在此添加控件通知处理程序代码
            
            	//将植物大战僵尸的汇编代码改掉
            		/*
            		问题来了，我需要知道植物大战僵尸的打击僵尸的汇编代码的内存地址
            		这里注意了，每一个平台的应用程序，他的代码段运行到操作系统时，他的内存地址是固定不变的。在PE文件
            		里面就已经固定下来了
            		1. 通过Cheat Engine找到僵尸的生命值
            		2. 通过OD减少僵尸生命值的汇编代码地址
            
            		游戏之前的：
            		地址          16进制     对应的汇编代码（每一句二进制对应一句汇编代码）
            		0053130F	2B7C2420    sub edi,dword ptr ss:[esp+0x20]
            		//秒杀替换
            		0053130F	2BFF9090    sub edi,edi
            		修改方法1： 直接将整句汇编代码换掉：即2B7C2420换成 2BFF9090即可
            
            		*/
            	//修改方法
            	DWORD address = 0x53130F;
            	if (this->m_kill.GetCheck()) {
            		//勾选
            		//AfxMessageBox(CString("需要秒杀僵尸"));
            		//修改方法
            		 BYTE value[] = { 0x2B, 0xFF, 0x90, 0x90 };
            		 WriteMemory(value, sizeof(value), address);
            	}
            	else {
            		//没有勾选
            		//AfxMessageBox(CString("不需要秒杀僵尸"));
            		BYTE value[] = { 0x2B, 0x7C, 0x24, 0x20 };
            		WriteMemory(value, sizeof(value), address);
            	}
            }
            ```
        
     
        


