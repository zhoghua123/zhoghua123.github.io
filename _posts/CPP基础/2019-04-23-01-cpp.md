---
layout: post
title: CPP应用-外挂开发(一)
category: CPP基础
tags: CPP基础
description: CPP基础
---    

1. 开发一个外挂程序的步骤
    1. 外挂界面
    2. 事件处理
        1. 监听外挂界面上面的按钮事件等
    3. 跨进程访问
        1. 用于控制实际的应用

## 外挂界面
1. Windows平台的桌面开发
    1. 使用C++开发
        1. MFC、Qt
    2. 使用C#开发
        1. WinForm、WPF
2. 我们课程选用最古老的MFC，不用引入其他外部的框架
3. 要先安装好MFC组件
4. 创建MFC项目
    1. 打开vs新建项目->visual C++  -> MFC应用程序 ->选择路径、命名->下一步
    2. 应用程序类型选择：基于对话框 ，然后点击完成即可
    3. 此时点击f5运行程序就出现一个简单的弹框界面应用程序
5. 搭建界面
    1. 找到界面(就相当于iOS的xib界面)
        1. 顶部工具栏->视图->其他窗口->资源视图->项目名文件夹下->dialog->IDD_项目名大写_DIALOG双击打开
    2. 修改左上角的logo
        1. 右击项目文件->打开文件夹->res->换掉里面的ico图片就行了
    3. 修改窗口标题
        1. 右击界面->属性->外观->caption（输入标题即可）
    4. 增删界面控件
        1. 删除：点击控件，点击delete即可
        2. 添加：
            1. 视图->工具箱->里面有很多控件
            2. 拖拽到界面即可
            3. 右击控件属性，选择外观，可以设置样式
    5. 监听事件（相当于iOS中的xib脱线成方法）
        1. 事件注册 – 手动
            1. 给控件设置唯一ID
                1. 右击控件属性->杂项->ID->右边重命名（ID_COURSE）
                2. 点击原来项目->头文件->Resource.h
                    1. 在这文件中可以看到一堆宏定义，其中就有（ID_COURSE）
            2. 声明、实现事件函数
                1. 凡是DIALOG界面的空间，绑定代码都在源文件的：项目名Dlg.cpp中写
                2. 首先在：”项目名Dlg.h“ 中新增函数声明
                3. 在”项目名Dlg.cpp“中新增函数实现
            3. 将控件与事件函数通过控件ID绑定
                
                ```
                //消息映射开始
                BEGIN_MESSAGE_MAP(CPVZCheaperDlg, CDialogEx)
                	ON_WM_SYSCOMMAND()
                	ON_WM_PAINT()
                	ON_WM_QUERYDRAGICON()
                	//ON_BN_CLICKED:按钮单击，参数：id按钮的，对应的函数
                	ON_BN_CLICKED(ID_COURSE, CPVZCheaperDlg::OnBnClickedCourse)
                	//消息隐射结束
                END_MESSAGE_MAP()
                ```
            4. 如下图：
                ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/cpp31.png)
                
        2. 事件注册 – 自动(也可以直接双击控件)
            1. 给控件设置唯一ID（同手动）
            2. 声明、实现事件函数/将控件与事件函数通过控件ID绑定--自动方式生成
                1. 右击控件-> 添加事件处理程序->选择消息类型（点击、长按等)/修改函数处理程序名称->点击添加编辑即可 （直接双击控件等价于当前所有操作）  
                2. 注意：手动监听控件的第2、3步，都在这里自动实现了 
6. 绑定成员变量（相当于iOS中XIB中的控件脱线成成员变量）
    1. 绑定成员变量 – 手动
        1. 给控件设置唯一ID（同监听事件）
        2. 声明成员变量
            1. 项目名Dlg.h中声明一个成员变量`CButton m_kill;`
        3. 将成员变量与控件通过ID绑定
            2. 项目名Dlg.cpp中DoDataExchange函数中进行绑定
                
                ```
                DDX_Control(pDX, IDC_KILL, m_kill);
                ```
    2. 绑定成员变量 – 自动
        1. 给控件设置唯一ID（同手动）
        2. 右击控件->添加变量->设置控件的属性(名称、权限等)->点击下一步即可（手动绑定成员变量的第2、3步，都在这里自动实现了） 
7. MFC开发中的打印
    1. TRACE函数:类似于C语言的printf，只能在DEBUG调试模式下看到打印信息(F5启动)
        
        ```
        TRACE("age is %d\n",20);
        ```
    2. AfxMessageBox函数(弹框提示)
        
        ```
        CString str;
        	str.Format(CString("age is %d"),20);
        	AfxMessageBox(str);
        ```
    3. MessageBox函数:只在CWnd的子类中使用，功能比AfxMessageBox多
        
        ```
        CString str;
        	str.Format(CString("age is %d"),20);
        MessageBox(str);
        MessageBox(str,CString("错误")，MB_YESNO|MB_ICONERROR);
        ```
    4. 自定义log宏，简化打印
        
        ```
        # define log(fmt,...)\
        CString str; \
        str.Format(CString(fmt),_VA_ARGS_);\
        AfxMessageBox(str);
        
        
        //使用
        log("age is %d\n",20);
        ```
8. 常用方法
    1. 打开URL
    
        ```
        ShellExecute(NULL, CString("open"), CString("www.baidu.com"), NULL, NULL, SW_SHOWNORMAL);
        ```
    2. 单选框的状态读取和修改 
        1. 方法1：
            
            ```
            //读取，参数为单选框控件的ID
            BOOL state = IsDlgButtonChecked(IDC_CHOSE1)
            //修改
            CheckDlgButton(IDC_CHOSE1, true);
            ```
        2. 方法2；
            
            ```
            CButton *button = (CButton *)GetDlgItem(IDC_CHOSE1);
            //读取
            BOOL state = button->GetCheck();
            //修改
            button->SetCheck(true);
            ```
        3. 方法3:
            1. 将按钮设置为成员变量,然后通过成员变量获取/设置
            
            ```
            //读取
            BOOL state = this->m_kill.GetCheck();
            //修改
            this->m_kill.SetCheck(true);
            ```
  
## 软件破解 
1. 请查看汇编部分最后一节：软件破解

        
 


