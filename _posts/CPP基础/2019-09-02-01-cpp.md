---
layout: post
title: C/CPP与数据结构-第一节 线性表（三）
category: CPP基础
tags: CPP基础
description: CPP基础
--- 

### 循环链表
1. 定义： 将单链表中最后一个数据元素的next指针指向第一个元素
2. 特点：
    1. 循环链表拥有单链表的所有操作
        1. 销毁链表、获取链表长度、清空链表、获取第pos个元素操作、插入元素到位置pos、删除位置pos处的元素
    2. 新增功能：
        1. 游标的定义: 在循环链表中可以定义一个“当前”指针，这个指针通常称为**游标**，可以通过这个游标来遍历链表中的所有元素。
        
        ![图4](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/cpp41.png)  
3. 循环链表新的操作：
    
    ```
    //将游标重置指向链表中的第一个数据元素
    CircleListNode* CircleList_Reset(CircleList* list);
    
    //获取当前游标指向的数据元素
    CircleListNode* CircleList_Current(CircleList* list);
    
    //将游标移动指向到链表中的下一个数据元素
    CircleListNode* CircleList_Next(CircleList* list);
    
    //直接指定删除链表中的某个数据元素 
    CircleListNode* CircleList_DeleteNode(CircleList* list, CircleListNode* node);  
    // 根据元素的值 删除 元素 pk根据元素的位置 删除 元素
    ```
4. 如何确定一个链表是循环链表？ 
    1. 将这个链表遍历打印2次
5. 设计与实现
    1. 插入分析：
        2. 普通插入元素（和单链表是一样的）
        3. 尾插法（和单链表是一样的，单链表的写法支持尾插法；因：辅助指针向后跳length次，指向最后面那个元素）
        4. 头插法（要进行头插法，需要求出尾结点，和单链表不一样的地方，保证是循环链表）第一次插入元素时，让游标指向0号结点
        5. 第一次插入元素
                
        ![图4](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/cpp42.png) 
    2. 删除分析：
        1. 删除普通结点
        2. 删除头结点（删除0号位置处元素），需要求出尾结点
        
        ![图4](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/cpp43.png)
    
    3. 代码实现 
        
        ```
        //CircleList.h
        #ifndef _CIRCLELIST_H_
        #define _CIRCLELIST_H_
        
        typedef void CircleList;
        
        typedef struct _tag_CircleListNode
        {
        	struct _tag_CircleListNode * next;
        }CircleListNode;
        
        CircleList* CircleList_Create();
        
        void List_Destroy(CircleList* list);
        
        void CircleList_Clear(CircleList* list);
        
        int CircleList_Length(CircleList* list);
        
        int CircleList_Insert(CircleList* list, CircleListNode* node, int pos);
        
        CircleListNode* CircleList_Get(CircleList* list, int pos);
        
        CircleListNode* CircleList_Delete(CircleList* list, int pos);
        
        //add
        
        //根据结点的值 进行数据的删除
        CircleListNode* CircleList_DeleteNode(CircleList* list, CircleListNode* node);
        
        CircleListNode* CircleList_Reset(CircleList* list);
        
        CircleListNode* CircleList_Current(CircleList* list);
        
        //游标指向2号位置 
        //把2号位置返回出来,同时让游标下移到3号位置
        CircleListNode* CircleList_Next(CircleList* list);
        
        #endif
        
        //CircleList.c
        #include <stdio.h>
        #include <malloc.h>
        #include "CircleList.h"
        
        typedef struct _tag_CircleList
        {
        	CircleListNode header;
        	CircleListNode* slider; //新增了一个游标功能
        	int length;
        } TCircleList;
        
        CircleList* CircleList_Create() // O(1)
        {
        	TCircleList* ret = (TCircleList*)malloc(sizeof(TCircleList));
        	if (ret == NULL)
        	{
        		return NULL;
        	}
        	
        	ret->length = 0;
        	ret->header.next = NULL;
        	ret->slider = NULL;
        	return ret;
        }
        
        void CircleList_Destroy(CircleList* list) // O(1)
        {
        	if (list == NULL)
        	{
        		return ;
        	}
        	free(list);
        }
        
        void CircleList_Clear(CircleList* list) // O(1)
        {
        	TCircleList* sList = (TCircleList*)list;
        	if (sList == NULL)
        	{
        		return ;
        	}
        	sList->length = 0;
        	sList->header.next = NULL;
        	sList->slider = NULL;
        }
        
        int CircleList_Length(CircleList* list) // O(1)
        {
        	TCircleList* sList = (TCircleList*)list;
        	int ret = -1;
        	if (list == NULL)
        	{
        		return ret;
        	}
        	ret = sList->length;
        	return ret;
        }
        
        int CircleList_Insert(CircleList* list, CircleListNode* node, int pos) // O(n)
        { 
        	int ret = 0, i=0;
        	TCircleList* sList = (TCircleList*)list;
        
        	if (list == NULL || node== NULL || pos<0)
        	{
        		return -1;
        	}
        	//if( ret )
        	{
        		//仍然需要引入富足指针变量
        		CircleListNode* current = (CircleListNode*)sList;
        
        		for(i=0; (i<pos) && (current->next != NULL); i++)
        		{
        			current = current->next;
        		}
        
        		//current->next 0号节点的地址
        		node->next = current->next; //1
        		current->next = node; //2
        
        		//若第一次插入节点
        		if( sList->length == 0 )
        		{
        			sList->slider = node;
        		}
        		sList->length++;
        
        		//注意点：
        		//若头插法 current仍然指向头部
        		//（原因是：跳0步，没有跳走）
        		if( current == (CircleListNode*)sList )
        		{
        			//获取最后一个元素，让最后一个元素指向新插入的节点
        			CircleListNode* last = CircleList_Get(sList, sList->length - 1); 
        			last->next = current->next; //3
        		}
        	}
        
        	return ret;
        }
        
        CircleListNode* CircleList_Get(CircleList* list, int pos) // O(n)
        {
        	TCircleList* sList = (TCircleList*)list;
        	CircleListNode* ret = NULL;
        	int i = 0;
        
        	if (list==NULL || pos<0)
        	{
        		return NULL;
        	}
        	//if( (sList != NULL) && (pos >= 0) && (sList->length > 0) )
        	{
        		CircleListNode* current = (CircleListNode*)sList;
        
        		for(i=0; i<pos; i++)
        		{
        			current = current->next;
        		}
        
        		ret = current->next;
        	}
        
        	return ret;
        }
        
        CircleListNode* CircleList_Delete(CircleList* list, int pos) // O(n)
        {
        	TCircleList* sList = (TCircleList*)list;
        	CircleListNode* ret = NULL;
        	int i = 0;
        
        	if( (sList != NULL) && (pos >= 0) && (sList->length > 0) )
        	{
        		CircleListNode* current = (CircleListNode*)sList;
        		CircleListNode* last = NULL;
        
        		for(i=0; i<pos; i++)
        		{
        			current = current->next;
        		}
        
        		//若删除第一个元素（头结点）
        		if( current == (CircleListNode*)sList )
        		{
        			last = (CircleListNode*)CircleList_Get(sList, sList->length - 1);
        		}
        
        		//求要删除的元素
        		ret = current->next;
        		current->next = ret->next;
        
        		sList->length--;
        
        		//判断链表是否为空
        		if( last != NULL )
        		{
        			sList->header.next = ret->next;
        			last->next = ret->next;
        		}
        
        		//若删除的元素为游标所指的元素
        		if( sList->slider == ret )
        		{
        			sList->slider = ret->next;
        		}
        
        		//若删除元素后，链表长度为0
        		if( sList->length == 0 )
        		{
        			sList->header.next = NULL;
        			sList->slider = NULL;
        		}
        	}
        
        	return ret;
        }
        
        CircleListNode* CircleList_DeleteNode(CircleList* list, CircleListNode* node) // O(n)
        {
        	TCircleList* sList = (TCircleList*)list;
        	CircleListNode* ret = NULL;
        	int i = 0;
        
        	if( sList != NULL )
        	{
        		CircleListNode* current = (CircleListNode*)sList;
        		
        		//查找node在循环链表中的位置i
        		for(i=0; i<sList->length; i++)
        		{
        			if( current->next == node )
        			{
        				ret = current->next;
        				break;
        			}
        
        			current = current->next;
        		}
        		
        		//如果ret找到，根据i去删除	
        		if( ret != NULL )
        		{ 
        			CircleList_Delete(sList, i); //根据结点的值 求出结点的位置 ,根据位置删除元素
        		}
        	}
        
        	return ret;
        }
        
        CircleListNode* CircleList_Reset(CircleList* list) // O(1)
        {
        	TCircleList* sList = (TCircleList*)list;
        	CircleListNode* ret = NULL;
        
        	if( sList != NULL )
        	{
        		sList->slider = sList->header.next;
        		ret = sList->slider;
        	}
        
        	return ret;
        }
        
        CircleListNode* CircleList_Current(CircleList* list) // O(1)
        {
        	TCircleList* sList = (TCircleList*)list;
        	CircleListNode* ret = NULL;
        
        	if( sList != NULL )
        	{
        		ret = sList->slider;
        	}
        
        	return ret;
        }
        
        //把当前位置返回，并且游标下移
        //把当前游标所指的位置的元素返回出去
        //游标下移
        CircleListNode* CircleList_Next(CircleList* list) // O(1)
        {
        	TCircleList* sList = (TCircleList*)list;
        	CircleListNode* ret = NULL;
        
        	if( (sList != NULL) && (sList->slider != NULL) )
        	{
        		ret = sList->slider;
        		sList->slider = ret->next;
        	}
        
        	return ret;
        }
        
        //应用main.c
        #include <stdio.h>
        #include <stdlib.h>
        #include "CircleList.h"
        
        struct Value
        {
        	CircleListNode circlenode;
        	int v;
        };
        
        int main11()
        {
        	CircleList* list = CircleList_Create();
        
        	struct Value v1;
        	struct Value v2;
        	struct Value v3;
        	struct Value v4;
        	struct Value v5;
        	struct Value v6;
        	struct Value v7;
        	struct Value v8;
        
        	int i = 0;
        	v1.v = 1;
        	v2.v = 2;
        	v3.v = 3;
        	v4.v = 4;
        	v5.v = 5;
        	v6.v = 6;
        	v7.v = 7;
        	v8.v = 8;
        
        	CircleList_Insert(list, (CircleListNode*)&v1, 0);
        	CircleList_Insert(list, (CircleListNode*)&v2, 0);
        	CircleList_Insert(list, (CircleListNode*)&v3, 0);
        	CircleList_Insert(list, (CircleListNode*)&v4, 0);
        
        	for(i=0; i<2*CircleList_Length(list); i++) //怎么样证明是循环链表
        	{
        		struct Value* pv = (struct Value*)CircleList_Get(list, i);
        
        		printf("%d\n", pv->v);
        	}
        
        	while( CircleList_Length(list) > 0 )
        	{
        		CircleList_Delete(list, 0);
        	}
        
        	printf("\n");
        
        	CircleList_Destroy(list);
        
        	system("pause");
        
        	return 0;
        }
        ```
        
### 双向链表

