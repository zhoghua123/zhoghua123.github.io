---
layout: post
title: 第十四章 STL第二节 Vector、Deque容器
category: CPP基础
tags: CPP基础
description: CPP基础
---   

### Vector容器  
1. Vector容器简介
    1. vector是将元素置于一个动态**数组**中加以管理的容器。
    2. vector可以随机存取元素（支持索引值直接存取， 用[]操作符或at()方法）。
    3. vector尾部添加或移除元素非常快速。但是在中部或头部插入元素或移除元素比较费时
2. vector对象的默认构造 
    1. vector采用模板类实现，vector对象的默认构造形式 `vector<T> vecT;`
    2. 常用函数如下；
        
        ```
        vector<int> vecInt;
        //一个存放int的vector容器。
        vector<float> vecFloat; 
        //一个存放float的vector容器。
        vector<string> vecString;
        //一个存放string的vector容器。
        ...				    
        //尖括号内还可以设置指针类型或自定义类型。
        Class CA{};
        vector<CA*> vecpCA;
        //用于存放CA对象的指针的vector容器。
        vector<CA> vecCA;
        //用于存放CA对象的vector容器。由于容器元素的存放是按值复制的方式进行的，所以此时CA必须提供CA的拷贝构造函数，以保证CA对象间拷贝正常。
        ```
3. vector对象的带参数构造
    1. 理论知识
        
        ```
        vector(beg,end);    //构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。
        vector(n,elem);   //构造函数将n个elem拷贝给本身。
        vector(const vector &vec);  //拷贝构造函数
        ```
    2. 代码举例：
        
        ```
        int  iArray[] = {0,1,2,3,4};
        vector<int>  vecIntA( iArray,  iArray+5 );
        vector<int> vecIntB (vecIntA.begin() , vecIntA.end());   //用构造函数初始化容器vecIntB 
        vector<int> vecIntB (vecIntA.begin() , vecIntA.begin()+3); 
        vector<int> vecIntC(3,9); //此代码运行后，容器vecIntB就存放3个元素，每个元素的值是9。
        vector<int> vecIntD(vecIntA);
        ```
4. vector的赋值
    1. 理论知识
        
        ```
        vector.assign(beg,end);    //将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。
        vector.assign(n,elem);  //将n个elem拷贝赋值给本身。
        vector& operator=(const vector  &vec);	//重载等号操作符
        vector.swap(vec);  // 将vec与本身的元素互换。
        ```
    2. 代码举例：
        
        ```
        vector<int> vecIntA, vecIntB, vecIntC, vecIntD;
        int  iArray[] = {0,1,2,3,4};
        vecIntA.assign(iArray,iArray+5);
        vecIntB.assign( vecIntA.begin(),  vecIntA.end() );    //用其它容器的迭代器作参数。
        vecIntC.assign(3,9);
        vector<int> vecIntD;
        vecIntD = vecIntA;
        vecIntA.swap(vecIntD);
        ```
5. vector的大小
    1. 理论知识
        
        ```
        vector.size();	   //返回容器中元素的个数
        vector.empty();	   //判断容器是否为空
        vector.resize(num);   //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。
        vector.resize(num, elem);  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。
        ```
    2. 例子
        
        ```
        例如   vecInt是vector<int>  声明的容器，现已包含1,2,3元素。
        int iSize = vecInt.size();
        //iSize == 3;
        bool bEmpty = vecInt.empty();
        // bEmpty == false;
        执行vecInt.resize(5);  //此时里面包含1,2,3,0,0元素。
        再执行vecInt.resize(8,3);  //此时里面包含1,2,3,0,0,3,3,3元素。
        再执行vecInt.resize(2);  //此时里面包含1,2元素。
        ```
6. vector末尾的添加移除操作  
    1. 举例
        
        ```
        vector<int> vecInt;
        vecInt.push_back(1);  //在容器尾部加入一个元素
        vecInt.push_back(3);  //移除容器中最后一个元素
        vecInt.push_back(5);  
        vecInt.push_back(7); 
        vecInt.push_back(9); 
        vecInt.pop_back();    
        vecInt.pop_back();
        //{5 ,7 ,9}  
        ```
    2. 举例：
        
        ```
        void test1() {

        	vector<int> v1;
        	cout << "length=" << v1.size() << endl;
        	//在尾部插人元素
        	v1.push_back(1);
        	v1.push_back(2);
        	v1.push_back(3);
        	cout << "length=" << v1.size() << endl;
        	//获取头部元素
        	cout << "头部元素=" << v1.front() << endl;
        
        	//修改头部元素的值	
        	//front函数返回值当作左值，应该返回一个引用
        	v1.front() = 11;
        
        	//修改尾值
        	v1.back() = 55;
        	while (v1.size()>0){
        		//获取尾部元素
        		cout << "获取尾部元素" << v1.back() << endl;
        		v1.pop_back();//删除尾部元素
        	}
        	
        }
        ```
7. vector的数据存取 
    1. 理论知识
        
        ```
        vec.at(idx);  	//返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。
        vec[idx];  	//返回索引idx所指的数据，越界时，运行直接报错
        ```
    2. 示例：
        
        ```
        vector<int> vecInt;    //假设包含1 ,3 ,5 ,7 ,9
        vecInt.at(2) == vecInt[2];
        //5
        vecInt.at(2) = 8;  或  vecInt[2] = 8;
        vecInt 就包含 1, 3, 8, 7, 9值
        
        int iF = vector.front();
        //iF==1
        int iB = vector.back();
        //iB==9
        vector.front() = 11;	//vecInt包含{11,3,8,7,9}
        vector.back() = 19;	//vecInt包含{11,3,8,7,19}
        ```
    3. 代码示例：
        
        ```
        //vector的遍历
        void test2(){
        	//vector<int> v1;
        	//明确元素个数，提前分配好内存，否则无法赋值
        	vector<int> v1(10);
        	for (int i = 0; i < 10; i++){
        		//注意，这么赋值的话v1[i]必须实际的内存，因此初始化V1时必须确定元素个数！！！
        		v1[i] = i;
        	}
        	for (int  i = 0; i < 10; i++){
        		cout << "===" << v1[i] << endl;
        	}
        }
        ```
8. 迭代器基本原理
    1. 迭代器是一个**可遍历STL容器内全部或部分元素**的对象。
    2. 迭代器指出容器中的一个特定位置。
    3. 迭代器就如同一个指针。
    4. 迭代器提供对一个容器中的对象的访问方法，并且可以定义了容器中对象的范围。
    5. 这里大概介绍一下迭代器的类别。
        1. 输入迭代器：也有叫法称之为**只读迭代器**，它从容器中读取元素，只能一次读入一个元素向前移动，只支持一遍算法，同一个输入迭代器不能两遍遍历一个序列。
        2. 输出迭代器：也有叫法称之为**只写迭代器**，它往容器中写入元素，只能一次写入一个元素向前移动，只支持一遍算法，同一个输出迭代器不能两遍遍历一个序列。
        3. 正向迭代器：组合输入迭代器和输出迭代器的功能，还可以多次解析一个迭代器指定的位置，可以对一个值进行多次读/写。
        4. 双向迭代器：组合正向迭代器的功能，还可以通过--操作符向后移动位置。
        5. 随机访问迭代器：组合双向迭代器的功能，还可以向前向后跳过任意个位置，可以直接访问容器中任何位置的元素。
    6. 目前本系列教程所用到的容器，都支持双向迭代器或随机访问迭代器，下面将会详细介绍这两个类别的迭代器。
    



