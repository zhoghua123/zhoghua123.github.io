---
layout: post
title: C/CPP与数据结构-第一节 
category: CPP基础
tags: CPP基础
description: CPP基础
---  

## 数据结构的概念
1. 数据结构相关概念（**注意理解**）
    1. 数据结构主要**研究**非数值计算程序问题中的**操作对象**以及它们**之间的关系**，不是研究复杂的算法
    2. 数据
        1. 定义：程序的操作对象，用于描述客观事物
        2. 数据的特点：
            1. 可以输入到计算机
            2. 可以被计算机程序处理
        3. 数据是一个抽象的概念，将其进行分类后得到程序设计语言中的类型。如：int，float，char等等
    3. **数据对象：是**性质相同的数据元素的**集合**
        1. 比如：数组，链表等等
    4. **数据元素：** 组成数据对象的基本单位
        1. 就相当于数组元素，一个一个的节点。
    5. **数据项：** 一个数据元素由若干数据项组成
        1. 比如：数组的每个元素都是对象类型，也就是数据元素，每个对象个各个属性组成了这个对象，这个对象的每个属性也叫**数据项**。
    6. 总结：**数据结构是研究数据元素之间关系的一门学科**，即节点与节点之间的关系。
        1. 数据元素之间不是独立的，存在特定的关系，这些关系即结构
        2. 比如：数组中各个元素之间存在固定的线性关系，一个一个按顺序排列
    7. 数据的逻辑结构
        1. 指数据元素之间的逻辑关系。
        2. 即从逻辑关系上描述数据，它与数据的存储无关，是独立于计算机的。
        3. 逻辑结构可细分为4类：
            1. 集合：数据元素间除**同属于一个集合外**，无其他关系
            2. 线性结构：一个对一个，如线性表、栈、队列
            3. 树型结构：一个对多个，如树
            4. 图状结构：多个对多个，如图

            ![图4](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/cpp34.png)
    8. 数据的物理结构
        1. 物理结构也叫**存储结构**，是数据的**逻辑结构**在计算机存储器内的表示(或映像)。它依赖于计算机。说白了就是数据的逻辑结构在计算机怎么存储的。
        2. 存储结构可以分为4大类：
            1. 顺序
            2. 链式
            3. 索引：内存寻址很像，n楼层+m房间，编号为m+n
            4. 散列：将一个大的数据，通过单向散列函数生成一个值去存储
        3. 最常用的存储结构为：
            1. 顺序存储结构：
                1. 借助元素在存储器中的相对应位置来表示数据间的逻辑关系
            2. 链式存储结构：
                1. 借助指示元素的存储地址的指针表示数据元素间的逻辑关系。
    9. 数据的运算
        1. 在数据的**逻辑结构上定义**的操作，它在**数据的存储结构上实现**
        2. 最常用的数据运算有5种：
            1. 插入、删除、修改、查找、排序
2. 算法
    1. 概念
        1. 算法是**特定问题求解步骤的描述**
        2. 在计算机中表现为指令的有限序列
        3. 算法是独立存在的一种解决问题的方法和思想。
        4. 对于算法而言，语言并不重要，重要的是思想。
    2. 算法和数据结构区别
        1. 数据结构只是静态的描述了数据元素之间的关系
        2. 高效的程序需要在数据结构的基础上设计和选择算法
        3. 程序=数据结构+算法  
        4. 总结：
            1. 算法是为了解决实际问题而设计的
            2. 数据结构是算法需要处理的问题载体
            3. 数据结构与算法相辅相成
    3. 算法特性
        1. 输入
            1. 算法具有0个或多个输入
        2. 输出
            1. 算法至少有1个或多个输出
        3. 有穷性
            1. 算法在有限的步骤之后会自动结束而不会无限循环
        4. 确定性
            1. 算法中的每一步都有确定的含义，不会出现二义性
        5. 可行性
            1. 算法的每一步都是可行的
    4. 算法的时间复杂度
        1. 代码最终都会转化为一条一条指令
        2. 同一台计算机上执行每一条指令的时间是相同的
        3. 假设每条语句相当于一条指令（**这里只是假设，本质上不会跟语言相关**），那么确定一个算法的时间复杂度就是这个代码语句的数量
        4. 举例下面的算法
            
            ```
            long sum1(int n)
            {
                long ret = 0;                         
                int* array = (int*)malloc(n * sizeof(int)); 
                int i = 0;  
                
                for(i=0; i<n; i++)   
                {
                    array[i] = i + 1;
                }
                
                for(i=0; i<n; i++) 
                {
                    ret += array[i];
                }
                
                free(array); 
                
                return ret; 
            }
            
            long sum2(int n)
            {
                long ret = 0;
                int i = 0;
                
                for(i=1; i<=n; i++)
                {
                    ret += i;
                }
                
                return ret;
            } 
            long sum3(int n)
            {
                long ret = 0;
                
                if( n > 0 )
                {
                    ret = (1 + n) * n / 2; 
                }
                
                return ret;
            }
            ```
            
            1. 这3个算法的语句数量(时间复杂度)分别为：2n+5、n+3、3
        5. 大O表示法：
            1. 一个算法的时间复杂度用程序的语句数量表达式来表达，当n很大时，常量可以忽略不计
                1. 上面上个用大O表示法为：O(n),O(n),O(1)
            2. 判断一个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略。
            3. 在没有特殊说明时，我们所分析的算法的时间复杂度都是指最坏时间复杂度。
            4. 特点：
                1. 法效率严重依赖于操作(Operation)数量
                2. 在判断时首先关注操作数量的最高次项
                3. 操作数量的估算可以作为时间复杂度的估算
            5. 常见的时间复杂度
                
                ![图4](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/cpp35.png)
    5. 算法的空间复杂度
        1. 算法的空间复杂度通过计算算法分配的存储空间实现
            1. `S(n) = O(f(n))`
                1. 其中，n为问题规模，f(n)为在问题规模为n时所占用存储空间的函数
        2. 大O表示法同样适用于算法的空间复杂度
        3. 当算法执行时所需要的空间是常数时，空间复杂度为O(1)
        4. 空间与时间的策略
            1. 多数情况下，算法执行时所用的时间更令人关注
            2. 如果有必要，可以通过增加空间复杂度来降低时间复杂度
            3. 同理，也可以通过增加时间复杂度来降低空间复杂度
        5. 例如：
            1. 上面的sum1、sum2、sum3的空间复杂度为：4n+8、8、4
            2. 用大O表示法为：O(n)，O（1），O（1）
        6. 时间换空间举例：
            1. 问题： 在一个由自然数1-1000中某些数字所组成的数组中，每个数字可能出现零次或者多次。设计一个算法，找出出现次数最多的数字。
            2. 实现方法
                1. 方法1：排序，然后找出出现次数最多的数字
                2. 方法2：时间换空间
                    
                    ```
                    void search(int a[], int len)
                    {
                        int sp[1000] = {0};
                        int i = 0;
                        int max = 0;
                        
                        for(i=0; i<len; i++)
                        {
                            int index = a[i] - 1;
                            
                            sp[index]++;
                        }
                        
                        for(i=0; i<1000; i++)
                        {
                            if( max < sp[i] )
                    	    {
                                max = sp[i];
                            }
                        }
                        
                        for(i=0; i<1000; i++)
                        {
                            if( max == sp[i] )
                            {
                                printf("%d\n", i+1);
                            }
                        }
                    }
                    int main()
                    {
                        int array[] = {1, 1, 3, 4, 5, 6, 6, 6, 2, 3};
                        
                        search(array, sizeof(array)/sizeof(*array));
                        
                        return 0;
                    }
                    ```
                

    
        



