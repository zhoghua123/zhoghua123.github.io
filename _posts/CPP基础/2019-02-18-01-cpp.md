---
layout: post
title: 第四章 封装、内存布局、malloc、free、new、delete、构造函数
category: CPP基础
tags: CPP基础
description: CPP基础
--- 

## 封装
1. 引例
    
    ```
    struct Person
    {
    	int m_age;
    };
    
    //使用
    Person person;
    person.m_age = -4;
    ```
    
    1. 年龄设置为-4很显然是现实中是不可能的，但是由于m_age这个成员变量是暴露出来的，可以在外部任意修改
    2. 为了防止这种情况，就出现了**封装**这个概念。
    3. 封装就是为了让外部不能直接访问对象的成员变量，仅仅通过我们封装后的方法才能访问。
    4. 我们可以在封装方法中设置一些过滤，防止非正常数据的出现。
2. 封装的本质：
    1. 成员变量私有化，提供公共的getter和setter给外界去访问成员变量 
        
        ```
        struct Person
        {	
        private:
        	int m_age;
        
        public:
        	//封装
        	void setAge(int age) {
        		if (age<=0)
        		{
        			cout << "设置的值不合理" << endl;
        			return;
        		}
        		this->m_age = age;
        	}
        
        	int getAge() {
        		return this->m_age;
        	}
        };
        
        int main() {
        	Person person;
        	person.setAge(20);
        	cout << "age=" << person.getAge() << endl;
        	person.setAge(-20);
        
        	getchar();
        	return 0;
        }
        ```
    
## 内存空间的布局
1. 每个应用都有自己**独立**的内存空间，其内存空间一般都有以下几大区域 
    1. 代码段(代码区)
        1. 用于存放代码 
    2. 数据段(全局区) 
        1. 用于存放全局变量等 
    3. 栈空间
        1. 每调用一个函数就会给它分配一段连续的栈空间，等函数调用完毕后会自动回收这段栈空间 
        2. 自动分配和回收 
    4. 堆空间
        1. 需要主动去申请和释放  
    
### 堆空间
1. 为什么需要堆空间？ 堆空间存在的意义？
    1. 我们知道栈空间分配的内存，一旦函数调用完毕就会被释放
    2. 但是如果我们需要在B函数中使用A函数定义的变量，怎么办呢？ 这就需要延长A函数中变量的生命周期
        1. 设置为全局变量：但是一旦成为全局变量，整个应用关闭之前这段内存就一直存在，无法释放，设置多了就消耗内存，因此，不现实
        2. 能不能有一种方法：自己管理内存，使用前延长内存的生命周期，使用后手动释放掉？ ---堆区就是这种功能
2. 在程序运行过程，为了能够自由控制内存的生命周期、大小，会经常使用堆空间的内存 
3. 堆空间的申请\释放
    1. malloc \ free 
    2. new \ delete
    3. new [] \ delete []  
4. 注意 
    1. 申请堆空间成功后，会返回那一段内存空间的地址 
    2. 申请和释放必须是1对1的关系，不然可能会存在内存泄露 
5. 现在的很多高级编程语言不需要开发人员去管理内存(比如Java)，屏蔽了很多内存细节，利弊同时存在 
    1. 利:提高开发效率，避免内存使用不当或泄露 
    2. 弊:不利于开发人员了解本质，永远停留在API调用和表层语法糖，对性能优化无从下手
    
    ```
    //c语言
    void test() {
    	//申请4个字节的堆空间
    	int *p = (int *)malloc(4);
    	//上面的p在栈空间，分配一段内存用于存储堆空间的地址
    	//堆中分配4个字节的内存
    	free(p);
    }
    
    //c++语言
    void test2() {
    	//申请4个字节内存
    	int *p = new int;
    	//释放
    	delete p;
    
    	//申请40个字节
    	int *p2 = new int[10];
    	//释放
    	delete[] p2;
    }
    ```
    
### 堆空间的初始化
1. 案例如下：
    
    ```
    //c语言初始化
    void test3(){
    	int *P1 = (int *)malloc(sizeof(int));//未初始化
    	int *P2 = (int *)malloc(sizeof(int));
    	//将p2指向的4个字节的堆空间都初始化为0；
    	memset(P2, 0, sizeof(int));
    	cout << *P2 << endl;
    	
    	free(P1);
    	free(P2);
    }
    //c++语言初始化
    void test4() {
    	int *p1 = new int; //*p1 未初始化
    	int *p2 = new int(); // *p2 初始化为0
    	int *p3 = new int(5); // *p3 初始化为5
    	int *p4 = new int[3];//*p4 数组元素未被初始化
    	int *P5 = new int[3]();//3个数组元素都被初始化为0
    	int *p6 = new int[3]{};//3个数组元素都被初始化为0
    	int *p7 = new int[3]{ 5 };//数组首元素被初始化为5，其他元素被初始化为0
    }
    ```
    



