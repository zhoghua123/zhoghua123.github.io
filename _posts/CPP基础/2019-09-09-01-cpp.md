---
layout: post
title: C/CPP与数据结构-第三节 树（二）
category: CPP基础
tags: CPP基础
description: CPP基础
--- 

### 二叉树的创建

#### 中序和先序创建树
1. 根据中序遍历的结果能确定一棵树吗？
    1. 中序遍历：结果为：“12345”，但是这个树有多种情况
2. 如何才能确定一棵树？
    1. 结论：
        1. 通过中序遍历结果和先序遍历结果可以确定一个树
        2. 通过中序遍历和后续遍历可以确定一个树
        3. 通过先序遍历和后序遍历确定不了一个树。
    2. 单独先序遍历：能求解根，但不能求解左子树什么时候结束、右子树什么时候开始。
3. 根据先序和中序结果画树
    1. 算法：
        1. 通过先序遍历找到根结点A，再通过A在中序遍历的位置找出左子树，右子树
        2. 在A的左子树中，找左子树的根结点（在先序中找），转步骤1
        3. 在A的右子树中，找右子树的根结点（在先序中找），转步骤1
    2. 举例：
        1. 先序遍历结果：ADEBCF 中序遍历结果：DEACFB
        2. 根据算法分析：
            1. 通过线序遍历结果可知，A为整棵树的根
            2. 在中序遍历结果中找到A，则A的左边DE为左子树，A的右边CFB为右子树
            3. 左子树：DE在先序中找，D在E的前面，则D为左子树的根
            4. 在中序遍历结果中找D，发现D在E的前面，说明E不是D的左子树，一定是D的右子树，则A的左树确定完成
            5. 右子树： CFB在线序中找，B在最前面，则B为右子树的根
            6. 在中序中找到B,则B的左边CF为B的左子树，B的右子树没有
            7. CF在先序中找，C在前面，则C为B的左子树的根
            8. 在中序中找到C，F在C的右边，说明C没有左子树，F为C的右子树，则A的右树确定完成
            9. 结果：`A(D(,E),B(C(,F),))`
         
#### `#`法创建树
1. 什么是`#`号法创建树
    1. `#`创建树，让树的每一个节点都变成度数为2的树，子树没有就用`#`代替
    2. 这样线序遍历就可以唯一确定一棵树
    3. 特点：叶子的的左子树和右子树，一定是2个`#`
2. `#`号法画出树关键点
    1. 要清楚的确定左子树什么结束，右子树什么时候开始。
3. 示例分析：
    1. 先序遍历：`ABDH#K###E##CFI###G#J##`,请画出树的形状
    2. 分析：
        1. A一定是整棵树的根
        2. B一定是A的左子树的根
        3. D一定是B的左子树的根
        4. H一定是D的左子树的根
        5. H有后面是`#K`，说明H的左子树没有，右子树为K
        6. K的后面是`##`则说明，K就是叶子了
        7. 此时到D的右子树了，K后面的第3个为`#`，说明D的右子树没有
        8. 此时到B的右子树了，上面的`#`后面为E，说明B的右子树为E
        9. E后面2个`##`说明E是叶子了
        10. 则此时A的左子树完成
        11. C为A的右子树
        12. F为C的左子树根，I为F的左子树根
        13. I的右边有2个`##`说明I是叶子
        14. 此时到F的右子树，I后面的第三个`#`说明F的右子树没有
        15. 此时到C的右子树，则C的右子树为G
        16. G后面为`#`则G的左子树没有
        17. 则G的右子树为J
        18. J后面为2个`##`,说明J是叶子
        19. 此时A的右子树完成
4. 代码实战
    
    ```
    Bintree createBTpre( )
    {      
    Bintree T; 
    char ch;
            scanf(“%c”,&ch);
            if(ch==’#’) 
    T=NULL; 
            else
            {   T=( Bintree )malloc(sizeof(BinTNode));
                T->data=ch;
                T->lchild=createBTpre(); 
                T->rchild=createBTpre();
            }        
            return T;
    }
    
    //后序遍历销毁一个树
    void  BiTree_Free(BiTNode* T)
    {
    	BiTNode *tmp = NULL;
    	if (T!= NULL)
    	{
    		if (T->rchild != NULL) BiTree_Free(T->rchild);
    		if (T->lchild != NULL) BiTree_Free(T->lchild);
    		if (T != NULL)
    		{
    			free(T); 
    			T = NULL;
    		}
    	}
    }
    ```


