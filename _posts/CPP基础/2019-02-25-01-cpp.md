---
layout: post
title: 第八章 static成员、单例模式
category: CPP基础
tags: CPP基础
description: CPP基础
--- 

## 静态成员(static)
1. 静态成员:被static修饰的成员变量\函数
    1. 可以通过对象(对象.静态成员)、对象指针(对象指针->静态成员)、类访问(类名::静态成员)
2. 静态成员变量
    1. 存储在数据段(**全局区**，类似于全局变量)，**整个程序运行过程中只有一份内存**
    2. 对比全局变量，它可以设定访问权限(public、protected、private)，达到局部共享的目的
    3. 必须初始化，必须在类外面初始化，初始化时不能带static，如果类的声明和实现分离(在实现.cpp中初始化)
        1. 示例1：
            
            ```
            #include<iostream>
            using namespace std;
            
            class Car {
            public:
            	//static int ms_count = 0;//不能直接初始化,编译报错
            	static int ms_count;
            	//构造函数中直接初始化，也不行，编译报错。
            	/*Car() {
            		ms_count = 0;
            	}*/
            };
            //必须在类外面初始化静态成员变量
            int Car::ms_count = 0;
            
            int main() {
            	//静态成员变量的3种访问方式
            	Car car;
            	car.ms_count = 10;
            
            	Car *car2 = new Car();
            	car2->ms_count = 20;
            //静态成员变量独有
            	Car::ms_count = 30;
    
            	cout << car3.ms_count << endl;
            
            	getchar();
            	return 0;
            }    
            ```
        2. 示例2：(统计车创建的次数)
            
            ```
            #include<iostream>
            using namespace std;
            
            class Car {
            	static int ms_count;
            public:
            
            	int getCount() {
            		return ms_count;
            	}
            	Car() {
            		ms_count ++;
            	}
            	~Car()
            	{
            		ms_count--;
            	}
            };
            //必须在类外面初始化静态成员变量
            int Car::ms_count = 0;
            
            int main() {
            	Car car;
            	Car *car2 = new Car();
            	Car car3;
            	cout << car3.getCount() << endl;
            	getchar();
            	return 0;
            }
            ```
3. 静态成员函数
    1. 从上面示例代码可以看出，如果要访问私有静态成员函数，必须通过对象去访问`car3.getCount()`
    2. 但是静态成员函数存放在全局区，并不依赖于类，那么可不可以直接通过类来访问静态成员函数呢？
    3. 一般情况下，**静态成员变量**要通过**静态成员函数**来访问
        
        ```
        #include<iostream>
        using namespace std;
        
        class Car {
        	static int ms_count;
        public:
        
        	//静态成员函数
           static int getCount() {
        		return ms_count;
        	}
        	Car() {
        		ms_count ++;
        	}
        	~Car()
        	{
        		ms_count--;
        	}
        };
        //必须在类外面初始化静态成员变量
        int Car::ms_count = 0;
        
        int main() {
        	Car car;
        	Car *car2 = new Car();
        	Car car3;
        	cout << car3.getCount() << endl;
        	//静态成员函数getCount可以直接通过类名来访问
        	cout << Car :: getCount() << endl;
        	getchar();
        	return 0;
        }
        ```
    4. 内部不能使用this指针(this指针只能用在**非静态成员函数**内部)
    5. 不能是虚函数(虚函数只能是非静态成员函数)
        1. 因为虚函数是用来实现多态的
        2. 而且虚函数一定是通过对象来调用的
        3. 而静态成员函数可以不通过指针调用，所以错误。
    6. 内部不能访问非静态成员变量\函数，只能访问静态成员变量\函数
    7. 非静态成员函数内部可以访问静态成员变量\函数
    8. 构造函数、析构函数不能是静态
    9. 当声明和实现分离时，实现部分不能带static，只能放在声明中。
        
        ```
        #include<iostream>
        using namespace std;
        
        //Person声明与实现分开实现
        class Person
        {
        	//类的声明，可以加static
        	static void test();
        };
        
        //实现不能加static
        // static void Person:: test() {
        void Person:: test() {
        }
        
        class Car {
        public:
        	static int ms_count;
        	int m_price;
        
        	//普通成员变量在对象中，所以创建了对象才可以访问他，this 就是这个对象的指针
        	void  test() {
        		this->m_price = 10;
        	}
        
        	//静态成员函数
        	//静态成员变量可以通过类名来访问Car::test2();此时没有对象，因此这时用this访问肯定错误
        	static void  test2() {
        		//不能用this
        		//this->m_price = 10;
        		//不能访问非静态成员变量，跟上面一个意思
        		//m_price = 10;
        		//不能调用非静态成员函数
        		//test();
        		//只能访问静态成员变量\函数
        		ms_count = 10;
        	}
        
        	//非静态成员函数内部可以访问静态成员变量\函数
        	void run() {
        		ms_count = 20;
        		m_price = 10;
        		test();
        		test2();
        	}
        	//不能修饰虚函数
        	//static virtual void test3(){}
        
        	//构造函数、析构函数不能是静态
        	/*static Car() {
        	}
        	static ~Car()
        	{
        	}*/
        };
        //必须在类外面初始化静态成员变量
        int Car::ms_count = 0;
        
        int main() {
        	Car car;
        
        	Car::test2();
        	getchar();
        	return 0;
        }
        ```

### 静态成员经典应用 – 单例模式
1. 

