---
layout: post
title: 第二章 内联函数、引用、const
category: CPP基础
tags: CPP基础
description: CPP基础
---  

## 内联函数(inline function) 
1. 使用inline修饰函数的声明或者实现，可以使其变成内联函数
    1. 建议声明和实现都增加inline修饰
    2. 但是注意：有默认参数的函数，只能加在声明上，不能加载实现上。
2. 特点
    1. 编译器会将函数调用直接展开为函数体代码 
        1. 将VS设置为release
        2. 点击项目属性->属性->C/C++->优化设置为“已禁用”，而且内联函数扩展设置为“任何适用项”
        3. 编译，然后将.exe拖入到IDA可以看到，main函数中的汇编代码
        4. sum函数没有添加inline时，有调用： call sum
        5. 没有inline修饰时，没有调用call sum 语句。
    2. 可以减少函数调用的开销
    3. 会增大代码体积 
        
        ```
        //内联函数声明
        inline int sum(int a, int b);
        
        int main() {
        
        	//内联函数
        	cout << sum(10, 20) << endl;
        	//上面的本质就是：
        	//cout << 10 +20 << endl;
        
        	getchar();
        	return 0;
        }
        //内联函数实现
        inline int sum(int a, int b) {
        	return a + b;
        }
        ```
3. 注意
    1. 尽量不要内联超过10行代码的函数
    2. 有些函数即使声明为inline，也不一定会被编译器内联，比如**递归函数**
        1. inline仅仅是建议编译器内联，但是如果代码很多编译器不一定内联。
        2. 递归是没办法内联的。
4. 内联函数使用场合
    1. 函数代码不是很多
    2. 函数的调用频率较高

### 内联函数与宏 
1. 内联函数与宏都是替换，那么他们有什么区别呢？
    1. 内联函数和宏，都可以减少函数调用的开销
    2. 都在编译阶段替换掉
    3. 对比宏，内联函数多了语法检测和函数特性 
2. 思考以下代码的区别
    
    ```
    #define sum(x) (x + x)
    inline int sum(int x) { return x + x; } 
    int a = 10; sum(a++);
    
    //宏:简单的替换
    a++ + a++
    
    //内联函数,只有一次++
    int x = a++;
    sum(x);
    ```
    
## `#`pragma once 
1. 我们用VS新建一个.h文件，这个头文件内部会默认一个`#pragma once`,那么它是什么作用呢？
2. 我们经常使用`#ifndef、#define、#endif`来防止头文件的内容被重复包含
3. `#pragma once`可以防止整个文件的内容被重复包含
4. 区别
    1. `#ifndef、#define、#endif`受C\C++标准的支持，不受编译器的任何限制
    2. 有些编译器不支持#pragma once(较老编译器不支持，如GCC 3.4版本之前)，兼容性不够好
    3. `#ifndef、#define、#endif`可以针对一个文件中的部分代码，而#pragma once只能针对整个文件

## 引用(Reference) 
1. 在C语言中，使用指针(Pointer)可以间接获取、修改某个变量的值
2. 在C++中，使用引用(Reference)可以起到跟指针**类似**的功能 
3. 注意点 
    1. 引用相当于是变量的别名(基本数据类型、枚举、结构体、类、指针、数组等，都可以有引用) 
    2. 对引用做计算，就是对引用所指向的变量做计算 
    3. 在定义的时候就**必须**初始化，一旦指向了某个变量，就**不可以**再改变，“从一而终”
    4. 可以利用引用初始化另一个引用，相当于某个变量的多个别名 
    5. 不存在【引用的引用、指向引用的指针、引用数组】 
    
    ```
    //定义一个枚举
    enum Season
    {	
    	spring,
    	summer,
    	fall,
    	winner
    };
    //定义一个结构体
    struct Student
    {
    	int age;
    
    };
    
    int main() {
    	//指针
    	int a = 10;
    	int *age = &a;
    	*age = 20;
    	cout << "a=" << a << endl;
    
    	//引用
    	//定义了一个引用，相当于score的别名
    	int score = 80;
    	int &rscore = score;
    	rscore = 90;
    	cout << "score = " << score << endl;
    
    	//枚举引用
    	Season season;
    	Season &rseason = season;
    	rseason = winner;
    	cout << "season = " << season << endl;
    
    	//结构体引用
    	Student student;
    	Student &rstudent = student;
    	rstudent.age = 25;
    	cout << "student.age = " << student.age << endl;
    
    	//指针引用
    	int x;
    	int y;
    	int *p = &x;
    	//给指针变量p取一个别名rp，rp就相当于p
    	int *&rp = p;
    	*rp = 20;
    	cout << "x = " << x << endl;
    
    	//数组引用
    	int array[] = { 10,20,30 };
    	//数组的引用必须用()，而且[]内的元素必须确定
    	int (&rarray)[3] = array;
    	//这么写就相当于一个“引用数组：一个数组中有3个元素，每个元素是一个整形引用，但是数组中是不允许放引用的”
    	//int &array[3] 
    	cout << "rarray[2]=" << rarray[2] << endl;
    
    	//这么是错的，定义的时候必须初始化
    	//int &rxx;
    
    	//一旦指向了某个变量就不能改变
    	int m = 10;
    	int &rm = m;
    	int n = 9;
    	//这仅仅是将n的值赋值给rm，即m = n，并没有改变rm的指向
    	rm = n;
    	//这么写就不对了，&rm单独写，就是取地址的意思，只有在定义的时候才是引用
    	//&rm = n;
    	cout << "rm= " << rm << endl;
    	cout << "m= " << m << endl;
    	cout << "n= " << n << endl;
    
    	//用一个引用，初始化另一个引用
    	int o = 10;
    	int  &ro = o;
    	int &rro = ro;
    	rro = 20;
    	cout << "o= " << o << endl;
    
    	//不存在指向引用的引用
    	int ss = 10;
    	int &rss = ss;
    	//错误
    	//int &&rss = rss;
    
    	//不存在指向引用的指针
    	//(int &)*pp;
    
    	//不存在引用数组
    	//int &array[3] = { 0 };
    
    	getchar();
    	return 0;
    }
    ```
4. 引用存在的价值之一:比指针更安全、函数返回值可以被赋值
    1. 安全：只能指向一个变量
    
    ```
    //函数返回值赋值
    int func() {
    
    	return 6;
    }
    int &func2(){
    	int a = 10;
    	return a;
    }
    
    //交换2个数的值
    //使用指针
    void swap(int *a,int *b){
    	int temp = *a;
    	*a = *b;
    	*b = temp;
    }
    //使用引用
    void swaps(int &a, int &b) {
    	int temp = a;
    	a = b;
    	b = temp;
    }
    
    //主函数调用
    int main() {

    	int v1 = 10;
    	int v2 = 20;
    	//swap(&v1, &v2);
    	swaps(v1, v2);
    	cout << "v1=" << v1 << endl;
    	cout << "v2=" << v2 << endl;
    
    
    	//很显然是错误的
    	//func() = 6;
    	//函数返回的是一个引用，可以被赋值.不过这样写没有意义，函数中的a并不会改变，函数调用完a被销毁。
    	func2() = 20;
    }
    ```
    
    ### 



