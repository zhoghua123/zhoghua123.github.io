---
layout: post
title: 第九章 拷贝构造函数、深拷贝、浅拷贝
category: CPP基础
tags: CPP基础
description: CPP基础
---  

## 拷贝构造函数(Copy Constructor)
1. 拷贝构造函数是构造函数的一种
2. 当利用已存在的对象创建一个新对象时(类似于拷贝)，就会调用新对象的拷贝构造函数进行初始化
3. 拷贝构造函数的格式是固定的，接收一个const引用作为参数
4. 默认拷贝的本质
    
    ```
    class Car {
	
    public:
    	int m_price;
    	int m_length;
    	Car( int price = 0,int length =0) :m_price(price),m_length(length) {
    		cout << "Car( int price = 0,int length =0)" << endl;
    	}
    	void display() {
		cout << "void display()"<<"-m_price-"<<m_price<<"-m_length-"<<m_length << endl;
	}
    	}
    	int main() {
    	Car car1;
    	Car car2(100);
    	Car car3(100, 5);
    	
    	//利用已经存在的car3对象创建了一个car4新对象
    	//car4初始化时会调用拷贝构造函数
    	//没有手动实现拷贝函数的话，默认也会拷贝操作
    	Car car4(car3);
    	//打印拷贝成功void display() - m_price - 100 - m_length - 5
    	car4.display();
     getchar();
    	return 0;
    }
    ```
    
    1. 将`Car car4(car3);`反汇编本质如下：
        
        ```
        mov         eax,dword ptr [ebp-30h]
        mov         dword ptr [ebp-40h],eax
        mov         ecx,dword ptr [ebp-2Ch]
        mov         dword ptr [ebp-3Ch],ecx
        ```
        
        1. ebp-30h是car3的首地址，也是car3第一个成员变量的地址;ebp-2Ch是car3的第二个成员变量的地址
        2. ebp-40h是car4的首地址，也是car4第一个成员变量的地址；ebp-3Ch是car4的第二个成员变量的地址
        3. 上面默认的本质是
            
            ```
            car4.m_length = car3.m_length;
            car4.m_price = car3.m_price;
            ```
5. 手动实现拷贝函数
    
    ```
    class Car {
	
    public:
    	int m_price;
    	int m_length;
    	Car( int price = 0,int length =0) :m_price(price),m_length(length) {
    		cout << "Car( int price = 0,int length =0)" << endl;
    	}
    	//手动实现拷贝构造函数
    	//需要手动实现拷贝操作
    	Car(const Car &car) :m_price(car.m_price),m_length(car.m_length){
    		/*m_price = car.m_price;
    		m_length = car.m_length;*/
    		cout << "Car(const Car &car) " << endl;
    	}
    	void display() {
    		cout << "void display()"<<"-m_price-"<<m_price<<"-m_length-"<<m_length << endl;
    	}
    };
    
    int main() {
    	Car car3(100, 5);
    
    	//利用已经存在的car3对象创建了一个car4新对象
    	//car4初始化时会调用拷贝构造函数
    	//手动实现拷贝构造函数
    	Car car4(car3);
    	//打印的值是乱码：void display() - m_price--858993460 - m_length--858993460
    	//因此，一旦手动实现拷贝函数，那么就需要自己手动完成拷贝操作
    	car4.display();
    	getchar();
    	return 0;
    }
    ```
6. 总结：
    1. C++默认就有拷贝函数，而且默认拷贝就是将旧对象的成员变量赋值给新的成员变量
    2. 一旦手动实现拷贝构造函数，那么默认就无效，需要手动实现拷贝
    3. 但是我们发现上述的手动实现拷贝构造好像多此一举，因此，当对象的成员变量是**基本数据类型**时，不需要手动实现构造函数。

### 调用父类的拷贝构造函数

```
class Person {
public:
	int m_age;
	Person(int age = 0):m_age(age){}
	//拷贝构造
	Person(const Person &person):m_age(person.m_age){}
};

class Student : public Person {
public:
	int m_score;
	Student(int age = 0,int score = 0):Person(age),m_score(score){}
	//拷贝构造
	//初始化列表中直接调用父类的拷贝构造函数Person(student)，来拷贝父类的成员变量
	Student(const Student &student) :Person(student), m_score(student.m_score) {}
};

//使用
Student student(18, 100);
Student student2(student);
cout << student.m_age << endl;
cout << student2.m_age << endl;
```

1. 如何拷贝父类的成员？如何调用父类的拷贝构造函数?
    1. 在子类拷贝构造的初始化列表中直接调用父类的拷贝构造函数。

### 深拷贝、浅拷贝
1. 成员变量为字符串的写法
    1. strcpy过期问题解决
        1. 项目右击属性->C/C++->命令行->输入：·/D "_CRT_SECURE_NO_WARNINGS" 保存即可
    2. C++中字符串常量必须用const修饰
    3. 函数的形参接收字符串时，必须也用const修饰，否则实参为字符串常量传入时会报错
    4. 代码示例：
        
        ```
        class Car {
        	int m_price;
        	char *m_name;
        public:
        	//这里形参必须用const修饰，否则外部创建直接传入字符串常量，会报错不匹配，而且const形参也可以接收字符串变量
        	Car(int price = 0, const char *name = NULL) :m_price(price) {
        		//但是name是const，而成员m_name是非const，很显然不能直接赋值，怎么办呢？
        		//m_name = name;
        		if (name == NULL)return;
        		//申请堆空间存储字符串的内容
        		this->m_name = new char[strlen(name) + 1]{};
        		//拷贝字符串内容到堆空间
        		strcpy(this->m_name, name);
        		cout << "Car(int price = 0, char *name = NULL)" << endl;
        	}
        	~Car(){
        		if (this->m_name == NULL) return;
        		delete[] this->m_name;
        		this->m_name = NULL;
        	}
        	void display() {
        		cout  << "price-" << m_price << "name-" << m_name << endl;
        	}
        };
        
        int main() {
        	//定义字符串
        	//数组方法定义
        	char name[] = { 'b','m','w','\0' };
        	//因为“bmw”是一个字符串常量，因此在C++中必须用const修饰
        	const char *name2 = "bmw";
        	cout << name << endl;
        	//strlen函数不包含\0字符
        	cout << strlen(name) << endl;
        	
        	Car *car = new Car(100, "bwm");
        	car->display();
        	}
        ```
2. 
    
        


