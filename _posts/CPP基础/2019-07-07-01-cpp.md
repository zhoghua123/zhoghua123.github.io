---
layout: post
title: 第十四章 STL算法第二节 
category: CPP基础
tags: CPP基础
description: CPP基础
---  

## 常用的算法
1. 常用的查找算法：
    
    ```
    adjacent_find()（ adjacent 是邻近的意思）,binary_search(),count(),count_if(),equal_range(),find(),find_if()。
    ```
2. 常用的排序算法：
    
    ```
    merge(),sort(),random_shuffle()（shuffle是洗牌的意思） ,reverse()
    ```
3. 常用的拷贝和替换算法：
    
    ```
    copy(), replace(),replace_if(),swap()
    ```
4. 常用的算术和生成算法：
    
    ```
    accumulate()（ accumulate 是求和的意思）,fill()
    ```
5. 常用的集合算法：
    
    ```
    set_union(),set_intersection(),set_difference()。
    ```
6. 常用的遍历算法：
    
    ```
    for_each(), transform()（ transform 是变换的意思）
    ```

### 常用的遍历算法 
1. **for_each()**
    1. 作用：用指定函数依次对指定范围内所有元素进行迭代访问。
    2. 函数定义。For_each(begin, end, func);
        
        ```
        template<class _InIt,class _Fn> 
        	inline _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func)
        	{	// perform function for each element [_First, _Last)
        	_Adl_verify_range(_First, _Last);
        	auto _UFirst = _Get_unwrapped(_First);
        	const auto _ULast = _Get_unwrapped(_Last);
        	for (; _UFirst != _ULast; ++_UFirst)
        		{
        		_Func(*_UFirst);
        		}
        
        	return (_Func);
        	}
        ```
        
        1. 有3个参数
        2. _Func：可以是函数地址，或者函数对象
            1. 函数对象可以记录当前的调用状态，这是函数对象特有的功能
        3. 返回值是_Func，即返回值是传入的函数地址或者函数对象
    3. 代码举例：
        
        ```
        void printVection(vector<int>&vx) {
            	for (vector<int>::iterator it=vx.begin(); it != vx.end(); it++) {
            		cout << *it << " ";
            	}
        }
        
        void showv1test(const int &n) {
        	   cout << n << endl;
        }
        
        class ShowVector {
        public:
        	ShowVector() {
        		//初始化成员变量
        		callcount = 0;
        	}
        	void operator()(const int &x) {
        		cout << x << " ";
        		callcount++;
        	}
        	void printCallCount() {
        		cout <<"调用次数---"<< callcount << endl;
        	}
        private:
            	//记录当前函数对象，调用的次数
            	int callcount;
        };
        void tests1() {
            	vector<int> v1;
            	v1.push_back(1);
            	v1.push_back(3);
            	v1.push_back(5);
            	//for循环
            	//printVection(v1);
            	//第三个参数传函数地址
            	//for_each(v1.begin(), v1.end(), showv1test);
            	//第三个函数传函数匿名对象
            	//for_each(v1.begin(), v1.end(), ShowVector());
            
            	ShowVector shovx;
            	//这么调用打印次数为0,为什么呢？ 
            	//for_each(v1.begin(), v1.end(), shovx);
            	//这么调用才会打印实际的值3
            	shovx = for_each(v1.begin(), v1.end(), shovx);
            	shovx.printCallCount();
        }
        ```
        
        1. 疑问：下面有什么不同呢？
            
            ```
            //这么调用打印次数为0,为什么呢？ 
            //for_each(v1.begin(), v1.end(), shovx);
            //这么调用才会打印实际的值
            shovx = for_each(v1.begin(), v1.end(), shovx);
            ```
        2. 因为for_each函数参数传入shovx函数对象时，函数内部并非直接用的是外部的对象shovx，而是通过shovx拷贝一个新的函数对象，在函数内部使用
        3. 因此，外部的shovx对象仍然没有变化，真正变化的是内部拷贝的那个函数对象，而此时，内部拷贝的对象有作为函数返回值，返回出来了
        4. 所以要想拿到真正的调用结果，必须接收函数调用结果，才能获取到真正调用的值
        5. 总结：**函数对象做参数：实参初始化形参本质会调用形参对应类的拷贝构造函数，初始化一个形参变量**

2. **transform()**
    1. 作用： 与for_each类似，遍历所有元素，但可对容器的元素进行修改
    2. transform()算法有两种形式: 
        1. `transform(b1, e1, b2, op)`
        2. `transform(b1, e1, b2, b3, op)`
    3. 声明：
        
        ```
        template<class _InIt,class _OutIt,class _Fn1> 
        inline _OutIt transform(_InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func)
        template<class _InIt1,class _InIt2,class _OutIt,class _Fn> 
        inline _OutIt transform(const _InIt1 _First1, const _InIt1 _Last1,
		const _InIt2 _First2, _OutIt _Dest, _Fn _Func)
        ```
    3. 使用情况：
        1. 例如：可以一个容器的元素，通过op(函数地址，或者函数对象)，变换到另一个容器中(同一个容器中),也可以把两个容器的元素，通过op，变换到另一个容器中
    4. 使用注意：
        1. 如果目标与源相同，transform()就和for_each()一样
        2. 如果想以某值替换符合规则的元素，应使用replace()算法更高效
    5. 举例使用
        
        ```
        void printlist(list<int> &listx) {
            	for (list<int>::iterator it = listx.begin(); it != listx.end(); it++) {
            		cout << *it << endl;
            	}
        }
        
        int increase(int &x) {
        	   return x + 100;
        }
        void test2() {
            	vector<int> v1;
            	v1.push_back(1);
            	v1.push_back(3);
            	v1.push_back(5);
            	//1. 同一个容器
            	//transform(v1.begin(), v1.end(), v1.begin(), increase);
            	//printVection(v1);
            	//使用预定义函数对象：negate：将元素变为负数
            	/*transform(v1.begin(), v1.end(), v1.begin(), negate<int>());
            	printVection(v1);*/
            
            	//2. 不同的容器
            	//使用函数适配器
            	//list<int> list1;
            	//list1.resize(v1.size());
            	////将v1中的每个元素都乘以10，放到容器list1中
            	//transform(v1.begin(), v1.end(), list1.begin(), bind2nd(multiplies<int>(),10));
            	//printlist(list1);
            
            	//transform:也可以把运算结果放到屏幕上
            	//ostream_iterator需要包含：#include<iterator>
            	transform(v1.begin(), v1.end(), ostream_iterator<int>(cout, " "), negate<int>());
        
        }
        ```
        
        
3. **for_each()和transform（）算法比较**
    1. 

        


