---
layout: post
title: 第十四章 STL算法第一节 
category: CPP基础
tags: CPP基础
description: CPP基础
---  

## 算法简介
1. 算法概述
    1. 算法部分主要由头文件`<algorithm>`，`<numeric>`和`<functional>`组成。
    2. `<algorithm>`是所有STL头文件中最大的一个，其中常用到的功能范围涉及到:比较、交换、查找、遍历操作、复制、修改、反转、排序、合并等等
    3. `<numeric>`体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。
    4. `<functional>`中则定义了一些模板类，用以声明**函数对象**。
    5. STL提供了大量实现算法的模版函数，只要我们熟悉了STL之后，许多代码可以被大大的化简，只需要通过调用一两个算法模板，就可以完成所需要的功能，从而大大地提升效率。
2. STL中算法分类
    1. 按操作对象分类
        1. 直接改变容器的内容
        2. 将原容器的内容复制一份,修改其副本,然后传回该副本
    2. 功能: 
        1. 非可变序列算法: 指不直接修改其所操作的容器内容的算法
            1. 计数算法: count、count_if
            2. 搜索算法: search、find、find_if、find_first_of、…
            3. 比较算法: equal、mismatch、lexicographical_compare
        2. 可变序列算法: 指可以修改它们所操作的容器内容的算法
            1. 删除算法: remove、remove_if、remove_copy、…
            2. 修改算法: for_each、transform
            3. 排序算法: sort、stable_sort、partial_sort、
        3. 排序算法: 包括对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作
        4. 数值算法: 对容器内容进行数值计算


### 算法中函数对象和谓词
1. 函数对象和谓词定义
    1. **函数对象**:(就是前面讲的仿函数)
        1. 重载**函数调用操作符**的类（一个类重载了它的函数调用操作符，即"()"操作符），其对象常称为**函数对象**（function object），即它们是行为类似函数的对象
        2. 一个类对象，表现出一个函数的特征，就是通过`对象名+(参数列表)`的方式使用一个类对象，如果没有上下文，完全可以把它看作一个函数对待。
        2. 这是通过重载类的`operator()`来实现的。
        3. **在标准库中，函数对象被广泛地使用以获得弹性**，标准库中的很多算法都可以使用函数对象或者函数来作为自定的回调行为;
    2. 谓词：
        1. 一元函数对象：函数参数1个；
        2. 二元函数对象：函数参数2个；
        3. 一元谓词: 函数参数1个，函数返回值是bool类型，可以作为一个判断式
            1. 谓词可以使一个仿函数，也可以是一个回调函数。
        4. 二元谓词: 函数参数2个，函数返回值是bool类型
2. 函数对象
    1. 实现：
        ```
        #include<iostream>
        #include<vector>
        #include<algorithm>
        using namespace std;
        
        //函数模板
        template<typename T>
            void FuncShowElemt(const T &t) {
            cout << t << endl;
        }
        
        //函数对象：某个类重载了 ()
        //类模板
        template<typename T>
        class ShowElemt {
        private:
            	int n; //用于记录当前成员函数调用的次数
        public:
            	//构造函数
            	ShowElemt() {
            		n = 0;
            	}
            	//重载函数调用操作符
            	//加一个const，既可以传常量，也可以传变量，否则只能传常量
            	void operator()(const T &t) {
            		n++;
            		cout << t << endl;
            	}
            
            	//成员函数
            	void printCount() {
            		cout << "函数的调用次数：" << n << endl;
            	}
        };
        ```
    1. 函数对象与函数
        
        ```
        void test1() {
        	/****对象函数***/
        	//创建一个对象
        	ShowElemt<int> showElemt;
        	//调用对象的成员函数,看起来很像一个函数的调用，因此也叫做仿函数
        	showElemt(5);
        	//等价
        	//showElemt.operator()(5);
        
        	/****函数调用***/
        	FuncShowElemt<int>(8);
        	FuncShowElemt(8);
        }
        ```
    2. 函数对象的优点：可以保持一些状态
        
        ```
        void test2() {
            	//数组
            	vector<int> v1;
            	v1.push_back(1);
            	v1.push_back(2);
            	v1.push_back(3);
            
            	//for_each:用于遍历容器中的所有元素
            	//1. 传参为匿名函数对象
            	//ShowElemt<int>()： 匿名函数对象
            	for_each(v1.begin(), v1.end(), ShowElemt<int>());
            	
            	//2. 也可以传函数的地址，回调函数
            	for_each(v1.begin(), v1.end(), FuncShowElemt<int>);
            
            	//3. 查看函数的调用次数
            	ShowElemt<int> elemt;
            	//for_each算法：当函数对象做函数参数时，必须接收一下
            	elemt = for_each(v1.begin(), v1.end(), elemt);
            	elemt.printCount();
        }
        ```
        
        1. `for_each`算法：当函数对象做函数参数时，函数对象必须接收一下，为什么呢？ 
            1. 如果不接收，会发现`elemt.printCount();`打印为0,为何呢？
        2. 查看`for_each`的源码
            
            ```
            template<class _InIt,class _Fn> 
            inline _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func)
            {	
                _Adl_verify_range(_First, _Last);
                auto _UFirst = _Get_unwrapped(_First);
                const auto _ULast = _Get_unwrapped(_Last);
                for (; _UFirst != _ULast; ++_UFirst)
                {
                _Func(*_UFirst);
                }
                return (_Func);
            }
            ```
            
            1. 参数都是值传递，非引用（指针）传递，因此，内部修改调用与外部无关
            2. 因此，当函数对象当做参数传入时，函数内部本质是调用浅拷贝，拷贝一个新的函数对象接收
            3. 所以外面的函数对象elemt任然不变
            4. 但是该函数的返回值却返回了内部拷贝的那个信函上对象值
            5. 因此，只要在外部接收一下该函数的返回值，既可以拿到函数内部的拷贝值
            6. 这就是为何外部的函数对象要接收该函数的返回值，然后打印才会有值的原因。
        


