---
layout: post
title: 第十一章 模板
category: CPP基础
tags: CPP基础
description: CPP基础
---  

## 模板(template)
1. 泛型，是一种将**类型**参数化以达到代码复用的技术，C++中使用模板来实现泛型
2. 模板的使用格式如下
    1. `template <typename\class T>`
    2. typename和class是等价的
    3. 代码举例：
        
        ```
        /*
        void swapValues(int &v1, int &v2) {
        	int tem = v1;
        	v1 = v2;
        	v2 = tem;
        }
        
        void swapValues(double &v1, double &v2) {
        	double tem = v1;
        	v1 = v2;
        	v2 = tem;
        }
        */
        
        //从上面可看出除了数据的类型之外其他都一样，那么我们可不可以将这个类型抽出来,作为可变参数简化代码呢?
        //typename也可以是class ,T是TYPE的简称，当然也可以写其他任意字符，比如A等
        //这么写，类型也成为可变参数了
        //外面只要指定T的类型，函数中所有的T都会成这种类型。
        //<>中可以有n个类型，即<typename T,typename T2,typename T3..>
        template <typename T> void swapValues(T &v1, T &v2) {
        	T tem = v1;
        	v1 = v2;
        	v2 = tem;
        }
        
        int main() {
        	int a = 10;
        	int b = 20;
        	swapValues(a, b);
        	cout << "a=" << a << "b=" << b << endl;
        
        	double c = 10.3;
        	double d = 20.5;
        	//调用时指定类型<double>
        	//swapValues<double>(c, d);
        	//即使不传<double>,他也可以自动识别类型
        	swapValues(c, d);
        	cout << "c=" << c << "d=" << d << endl;
        
        	getchar();
        	return 0;
        }
        ```
    4. 泛型的本质：
        1. 编译器会根据你调用这个泛型时用的实际类型生成相应的函数，比如上面代码，编译器会生成类型为int、double的2个函数。而其他类型的不会生成，因为没有实际使用
3. 模板没有被使用时，是不会被实例化出来的
4. 模板的声明和实现如果分离到.h和.cpp中，会导致链接错误
    1. 原因分析如下：
        1. 如果分开后，编译器会将main.cpp，与swap.cpp（包含模板实现的cpp文件）单独编译
        2. 但是模板只会在使用的时候编译器才会生成相应的实现
        3. 上面main.cpp,swap.cpp是2个互不相干的文件分别编译，所以编译器根本不会自动生成swap.cpp中的函数实现。
        4. 因此链接的时候，找不到相应的模板实现，报错
        5. 因此：模板不能单独存放到cpp中，可以直接将实现放在.h文件中或者放到.hpp中
5. 一般将模板的声明和实现统一放到一个.hpp文件（C++专门提供存放模板的头文件）中
    1. 新建一个.hpp文件
        
        ```
        //.hpp文件
        template <typename T> void swapValues(T &v1, T &v2) {
        	T tem = v1;
        	v1 = v2;
        	v2 = tem;
        }
        ```
6. 多参数模板
   
   ```
   template <class T1,class T2> 
    void display(const T1 &v1,const T2 &v2) {
    cout << v1 << endl;
    cout << v2 << endl;
    }
    
    display(20,1.7);
   ```
   
### 类模板     


### 类模板中的友元函数
 


