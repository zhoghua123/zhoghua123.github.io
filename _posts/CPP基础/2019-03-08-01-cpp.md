---
layout: post
title: 第十一章 模板
category: CPP基础
tags: CPP基础
description: CPP基础
---  

## 模板(template)
1. 泛型，是一种将**类型**参数化以达到代码复用的技术，C++中使用模板来实现泛型
2. 模板的使用格式如下
    1. `template <typename\class T>`
    2. typename和class是等价的
    3. 代码举例：
        
        ```
        /*
        void swapValues(int &v1, int &v2) {
        	int tem = v1;
        	v1 = v2;
        	v2 = tem;
        }
        
        void swapValues(double &v1, double &v2) {
        	double tem = v1;
        	v1 = v2;
        	v2 = tem;
        }
        */
        
        //从上面可看出除了数据的类型之外其他都一样，那么我们可不可以将这个类型抽出来,作为可变参数简化代码呢?
        //typename也可以是class ,T是TYPE的简称，当然也可以写其他任意字符，比如A等
        //这么写，类型也成为可变参数了
        //外面只要指定T的类型，函数中所有的T都会成这种类型。
        //<>中可以有n个类型，即<typename T,typename T2,typename T3..>
        template <typename T> void swapValues(T &v1, T &v2) {
        	T tem = v1;
        	v1 = v2;
        	v2 = tem;
        }
        
        int main() {
        	int a = 10;
        	int b = 20;
        	swapValues(a, b);
        	cout << "a=" << a << "b=" << b << endl;
        
        	double c = 10.3;
        	double d = 20.5;
        	//调用时指定类型<double>
        	//swapValues<double>(c, d);
        	//即使不传<double>,他也可以自动识别类型
        	swapValues(c, d);
        	cout << "c=" << c << "d=" << d << endl;
        
        	getchar();
        	return 0;
        }
        ```
    4. 泛型的本质：
        1. 编译器会根据你调用这个泛型时用的实际类型生成相应的函数，比如上面代码，编译器会生成类型为int、double的2个函数。而其他类型的不会生成，因为没有实际使用
3. 模板没有被使用时，是不会被实例化出来的
4. 模板的声明和实现如果分离到.h和.cpp中，会导致链接错误
    1. 原因分析如下：
        1. 如果分开后，编译器会将main.cpp，与swap.cpp（包含模板实现的cpp文件）单独编译
        2. 但是模板只会在使用的时候编译器才会生成相应的实现
        3. 上面main.cpp,swap.cpp是2个互不相干的文件分别编译，所以编译器根本不会自动生成swap.cpp中的函数实现。
        4. 因此链接的时候，找不到相应的模板实现，报错
        5. 因此：模板不能单独存放到cpp中，可以直接将实现放在.h文件中或者放到.hpp中
5. 一般将模板的声明和实现统一放到一个.hpp文件（C++专门提供存放模板的头文件）中
    1. 新建一个.hpp文件
        
        ```
        //.hpp文件
        template <typename T> void swapValues(T &v1, T &v2) {
        	T tem = v1;
        	v1 = v2;
        	v2 = tem;
        }
        ```
6. 多参数模板
   
   ```
   template <class T1,class T2> 
    void display(const T1 &v1,const T2 &v2) {
    cout << v1 << endl;
    cout << v2 << endl;
    }
    
    display(20,1.7);
   ```
   
### 类模板     
1. 模仿一个数组Aarray
2. 动态数组的实现原理：
    1. 先申请一块足够大的堆空间，用于存放数组元素-容量
    2. 当不断的动态添加数组元素，知道开始申请的容量不够时
    3. 重新申请一块更大的堆空间，将之前的堆空间数据迁移到这个新的堆空间
    4. 释放掉原来的堆空间
3. 举例：
    
    ```
    //Item.hpp文件
    
    //定义一个数组
    //声明
    template <class Item>
    class Array {
    	int m_size = 0;
    	int m_capacity = 0; //容量
    	Item *m_data = NULL;
    public:
    	Array(int capacity);
    	~Array();
    	void add(Item value);
    	Item get(int index);
    	int size();
    	Item operator[](int index);
    };
    
    
    //实现：
    //1. 每一个实现前都得加：template <class Item>
    //2. 命名空间后面加类模板：Array<Item>::
    template <class Item>
    Array<Item>:: Array(int capacity) {
    	if (capacity <= 0) return;
    	this->m_data = new Item[capacity]{};
    	this->m_capacity = capacity;
    }
    template <class Item>
    Array<Item>:: ~Array() {
    	if (!this->m_data) return;
    	delete[] this->m_data;
    	this->m_data = NULL;
    }
    template <class Item>
    void Array<Item>::add(Item value) {
    	if (this->m_size == this->m_capacity) {
    
    		cout << "数组已满，需要扩容" << endl;
    		return;
    	}
    	this->m_data[this->m_size++] = value;
    }
    template <class Item>
    Item Array<Item>:: get(int index) {
    	return (*this)[index];
    }
    template <class Item>
    int Array<Item>:: size() {
    	return this->m_size;
    }
    template <class Item>
    Item Array<Item>:: operator[](int index) {
    	if (index < 0 || index >= this->m_size) return 0;
    	return this->m_data[index];
    }
    ```

### 类模板中的友元函数
 ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/cpp15.png)


