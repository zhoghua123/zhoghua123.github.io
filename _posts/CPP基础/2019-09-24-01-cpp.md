---
layout: post
title: QT-第五节 Qt消息机制和事件
category: CPP基础
tags: CPP基础
description: CPP基础
--- 

## 消息机制和事件

### 事件
1. 事件（event）是由系统或者 Qt 本身在不同的时刻发出的。当用户按下鼠标、敲下键盘，或者是窗口需要重新绘制的时候，都会发出一个相应的事件。一些事件在对用户操作做出响应时发出，如键盘事件等；另一些事件则是由系统自动发出，如计时器事件。
2. 在前面我们也曾经简单提到，Qt 程序需要在main()函数创建一个QApplication对象，然后调用它的exec()函数。这个函数就是开始 Qt 的事件循环。在执行exec()函数之后，程序将进入事件循环来监听应用程序的事件。
    1. 当事件发生时，Qt 将创建一个事件对象。**Qt 中所有事件类都继承于QEvent**
    2. 在事件对象创建完毕后，Qt 将这个事件对象传递给QObject的event()函数。
    3. event()函数**并不直接处理事件，而是按照事件对象的类型分派给特定的事件处理函数**（event handler），关于这一点，会在后边详细说明。
3. 在所有组件的父类QWidget中，定义了很多事件处理的回调函数，如
    
    ```
    keyPressEvent()
    keyReleaseEvent()
    mouseDoubleClickEvent()
    mouseMoveEvent()
    mousePressEvent()
    mouseReleaseEvent() 等。
    ```
4. 这些函数都是 protected virtual 的，也就是说，我们可以在子类中重新实现这些函数。下面来看一个例子：
5. 监听QLabel的一些事件
    1. 分析：要想监听QLabel的事件那么就必须自定义QLabel了
    2. 右击项目->Add New...->选择C++->C++ class 输入类名： MYLabel ；基类名为：QWidget（因为没有QLabel这个类，因此先选择这个），点击下一步、完成
    3. 打开MYLabel.h，修改基类为QLabel,注意修改的地方，有些地方不能改，必须仍然是QWidget
    4. 重写事件，cpp中实现监听，代码如下
    5. 在主UI中使用
        1. 拖一个QLabel，提升为MYLabel类既可
        2. 给改label添加一个边框，便于显示：
            1. 属性QFrame->frameshape ->box
        2. 运行demo就可以监听了
    6. 代码：
        
        ```
        //mylabel.h文件
        #ifndef MYLABEL_H
        #define MYLABEL_H
        #include <QLabel>
        class MYLabel : public QLabel
        {
            Q_OBJECT
        public:
            //注意这个地方不能改QWidget
            explicit MYLabel(QWidget *parent = nullptr);
        
            //捕获事件
            //鼠标进入
            void enterEvent(QEvent*);
            //鼠标离开
            void leaveEvent(QEvent *);
            //鼠标移动
            void mouseMoveEvent(QMouseEvent *ev);
            //鼠标按下
            void mousePressEvent(QMouseEvent *ev);
            //鼠标松开
            void mouseReleaseEvent(QMouseEvent *ev);
        
        };
        
        #endif // MYLABEL_H
        
        //mylabel.cpp
        #include "mylabel.h"
        #include<QDebug>
        #include<QMouseEvent>
        MYLabel::MYLabel(QWidget *parent) : QLabel(parent)
        {
            //设置鼠标的追踪
            //这么一设置下面的移动监听方法，本来是鼠标必须按下移动才会监听得到
            //现在不按下，移动也能监听到了
            this->setMouseTracking(true);
        }
        
        void MYLabel:: enterEvent(QEvent *){
        
           qDebug()<<"鼠标进入";
        }
        
        void MYLabel:: leaveEvent(QEvent *){
             qDebug()<<"鼠标离开";
        }
        
        //鼠标移动
        void MYLabel:: mouseMoveEvent(QMouseEvent *ev){
            //注意在移动内是无法用ev->button()==Qt::LeftButton判断左键和右键的了
            if(ev->buttons() & Qt::LeftButton){
                qDebug()<<"鼠标左键按下滑动";
            }
             QString str = QString("鼠标移动  x= %1,y = %2").arg(ev->x()).arg(ev->y());
             qDebug()<<str;
        }
        //鼠标按下
        void MYLabel :: mousePressEvent(QMouseEvent *ev){
            //判断鼠标按得是左键还是右键
            if(ev->button()==Qt::LeftButton){
                qDebug()<<"点击了左键";
            }
             //按下的位置
             QString str = QString("鼠标按下  x= %1,y = %2").arg(ev->x()).arg(ev->y());
             qDebug()<<str;
        
        }
        //鼠标松开
        void  MYLabel :: mouseReleaseEvent(QMouseEvent *ev){
             QString str = QString("鼠标松开  x= %1,y = %2").arg(ev->x()).arg(ev->y());
             qDebug()<<str;
        }
        ```

#### 定时器事件
1. 第一种使用方式，通过监听QtimerEvent事件
    1. 在主窗口中重写监听事件，在.cpp中实现事件
    2. 代码如下:
        
        ```
        //Widget.h
        #ifndef WIDGET_H
        #define WIDGET_H
        #include <QWidget>
        namespace Ui {
        class Widget;
        }
        class Widget : public QWidget
        {
            Q_OBJECT
        
        public:
            explicit Widget(QWidget *parent = nullptr);
            ~Widget();
        
        private:
            Ui::Widget *ui;
        
            //定时器事件
           void timerEvent(QTimerEvent *);
           //定时器的标识号
           int id1;
           int id2;
        };
        
        #endif // WIDGET_H
        
        //Widget.cpp
        #include "widget.h"
            #include "ui_widget.h"
            
            Widget::Widget(QWidget *parent) :
                QWidget(parent),
                ui(new Ui::Widget)
            {
                ui->setupUi(this);
                //启动定时器
                //每1000ms调用一次timerEent事件
               id1 = startTimer(1000);
               //每个2s...
               id2 = startTimer(2000);
            }
            
            Widget::~Widget()
            {
                delete ui;
            }
            
            void Widget:: timerEvent(QTimerEvent *e){
                if(e->timerId() == id1){
                    static int num = 0;
                    ui->label_2->setText(QString::number(num++));
                }else if (e->timerId() == id2) {
                    static int num2 = 0;
                    ui->label_3->setText(QString::number(num2++));
                }
        }

        ```

2. 定时器的第二种方式：(常用)
    1. 使用QTimer对象
    2. 代码示例：
        
        ```
        //定时器的第二种方式
        QTimer *timer1 = new QTimer(this);
        //启动,每个0.5s发送一次信号
        timer1->start(500);
        connect(timer1,&QTimer::timeout,[=](){
            static int num = 0;
            ui->label_4->setText(QString::number(num++));
        });
        //暂停定时器
        connect(ui->pushButton,&QPushButton::clicked,[=](){
            timer1->stop();
        });
        ```


