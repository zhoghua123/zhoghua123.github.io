---
layout: post
title: 第五章 析构函数、命名空间、继承、成员访问权限、初始化列表
category: CPP基础
tags: CPP基础
description: CPP基础
--- 

## 析构函数(Destructor) 
1. 析构函数(也叫析构器)，在对象销毁的时候自动调用，一般用于完成对象的清理工作 
2. 特点 
    1. 函数名以~开头，与类同名，无返回值(void都不能写)，无参，不可以重载，**有且只有**一个析构函数 
3. 注意 
    1. 通过malloc分配的对象free的时候不会调用构造函数
4. 构造函数、析构函数要声明为public，才能被外界正常使用
    
    ```
    struct Person
    {
    	int m_age;
    	//对象创建完毕的时候调用
    	Person() {
    		cout << "Person()" << endl;
    		this->m_age = 0;
    	}
    	//对象被销毁的时候调用
    	~Person() {
    		cout << "~Person()" << endl;
    	}
    };
    
    
    int main() {
    	//堆
    	{
    		Person person;
    	}
    	//栈
    	Person *p = new Person;
    	delete p;
    
    	getchar();
    	return 0;
    }
    ```

## 对象的内存管理 
1. 对象内部申请的堆空间，由对象内部回收 
2. 多注意setter和析构的内存管理
    1. 注意点1：类类型的成员函数是指针与是类的区别
        
        ```
        struct Car
        {
            	Car() {
            		cout << "car()" << endl;
            	}
            	~Car()
            	{
            		cout << "~Car()" << endl;
            	}
        
        };
        
        struct Person
        {
            	int m_age;
            	//Car m_car;//这么写，在创建person对象的时候会创建一个Car对象
            	Car *m_car;//这么写，在创建person对象的时候只会创建一个指针变量，占4个字节，不会创建Car对象
            	Person() {
            		cout << "Person()" << endl;
            	}
            
            	//内存回收、清理工作
            	~Person() {
            		cout << "~Person()" << endl;
            	}
        };
        
        int main(){
            	Person *p = new Person;
              delete p;
            	getchar();
            	return 0;
        }
        ```
    2. 在构造函数内部分配内存，需要在析构函数内部释放
        
        ```
        struct Car
        {
            	int m_price;
            	Car() {
            		cout << "car()" << endl;
            	}
            	~Car()
            	{
            		cout << "~Car()" << endl;
            	}
        };
        
        struct Person
        {
            	int m_age;
            	Car *m_car;
            	Person() {
            		cout << "Person()" << endl;
            		this->m_car = new Car();
            	}
            
            	//内存回收、清理工作
            	~Person() {
            		cout << "~Person()" << endl;
            		delete this->m_car;
              }
        };
        
        //使用
        Person *p = new Person();
        delete p;
        ```
    3. 在setter方法内部分配内存，同时在setter方法内部释放，但是调用释放在析构函数中
    
 
## 声明和实现分离 
1. 类的声明写到.h文件，类的实现写到.cpp；当然也可以都写在一个文件中
    
    ```
    //Person.h
    
    #pragma once
    class Person
    {
    public:
    	Person();
    	~Person();
    	void setAge(int age);
    	int getAge();
    
    private:
    	int m_age;
    }
    
    //Person.cpp
    #include<iostream>
    #include"Person.h"
    using namespace std;
    
    Person::Person()
    {
    	cout << "person()" << endl;
    }
    
    Person::~Person()
    {
    	cout << "~Person()" << endl;
    }
    
    void Person::setAge(int age) {
    	this->m_age = age;
    	cout << "setAge" << endl;
    }
    
    int  Person::getAge() {
    	cout << "getAge" << endl;
    	return this->m_age;
    }
    
    int main() {
    	Person person;
    	person.setAge(10);
    	cout << person.getAge() << endl;
    	getchar();
    	return 0;
    }
    ```
    
## 命名空间
1. 命名空间可以用来避免命名冲突 
    
    ```
    class Person
    {
    public:
    	int m_age;
    };
    //全局变量
    int g_no;
    
    //函数
    void test() {
    
    }
    
    //命名空间
    namespace ZH {
    	//全局变量
    	int g_no;
    	//函数
    	void test() {
    
    	}
    
    	class Person
    	{	
    	public:
    		int m_age;
    	};
    }
    
    int main() {

    	Person person;
    	person.m_age = 10;
    
    	ZH::Person person2;
    	person2.m_age = 20;
    
    	g_no = 30;
    	ZH::g_no = 40;
    
    	test();
    	ZH::test();
    	
    	cout << "person.m_age=" << person.m_age << endl;
    	cout << "person2.m_age=" << person2.m_age << endl;
    
    	getchar();
    	return 0;
    }
    ```
2. `using namespace 空间名;`
    1. 声明我要用“空间名”中的东西，统一声明，不用在使用的时候还要每次写
    
    ```
    //命名空间
    namespace ZH {
    	//全局变量
    	int g_no;
    	//函数
    	void test() {
    
    	}
    
    	class Person
    	{	
    	public:
    		int m_age;
    	};
    }
    
    //统一使用
    using namespace ZH;
    g_no = 10;
    Person person;
    test();
    
    //指定用命名空间的哪一个
    using ZH::g_no;
    g_no = 10;
    ```
3. 命名空间不影响内存布局
  
  
### 命名空间的嵌套
1. 举例：
    
    ```
    namespace ZH {
    	 namespace SS {
    		 int g_age;
    	 }
    }
    
    int main() {
    
    	ZH::SS::g_age = 10;
    
    	using namespace ZH::SS;
    	g_age = 20;
    
    	using ZH::SS::g_age;
    	g_age = 30;
    }
    ```
2. 有个默认的全局命名空间，我们创建的命名空间默认都嵌套在它里面
    
    ```
    int g_no;

     namespace ZH {
    	 namespace SS {
    		 int g_age;
    	 }
    }
    
    int main() {
    	//下面2个等价
    	g_no = 10;
    	//默认命名空间::,全局命名空间
    	::g_no = 10;
    
    	using namespace ZH::SS;
    	g_age = 20;
    }
    ```
    
    
### 命名空间的合并
1. 以下2种写法是等价的
    
    ```
    //写法1
    namespace ZH {
    	int g_age;
    }
    
    namespace ZH {
    	int g_no;
    }
    
    //等价于写法2
    namespace ZH {
     int g_age;
    	int g_no;
    }
    ```
2. 命名空间用在类中
    
    ```
    //Person.h
    #pragma once
    namespace ZH {
    	class Person
    	{
    	public:
    		Person();
    		~Person();
    	};
    }
    
    //Person.cpp
    #include "Person.h"

    namespace ZH {
    	Person::Person()
    	{
    	}
    
    
    	Person::~Person()
    	{
    	}
    }
    
    //main函数使用
    #include<iostream>
    #include"Person.h"
    using namespace ZH;
    using namespace std;
    
    int main() {
        Person = person;
        return 0;
    }
    ```
    
## 继承
1. 继承，可以让子类拥有父类的所有成员(变量\函数)
    
    ```
    struct Person
    {
    	int m_age;
    	void run() {
    		cout << "run()" << endl;
    
    	}
    };
    
    //继承Person
    struct Student : Person
    {	
    	int m_no;
    	void study() {
    		cout << "study()" << endl;
    	}
    };
    
    int main() {
    
    	Student student;
    	student.m_age = 10;
    	student.m_no = 22;
    	student.run();
    	student.study();
    
    	getchar();
    	return 0;
    }
    ```
    
    1. 关系描述
        1. Student是子类(subclass，派生类) 
        2. Person是父类(superclass，超类)
    2. C++中没有像Java、Objective-C的基类
        1. Java:java.lang.Object
        2. Objective-C:NSObject
        
### 对象的内存布局

![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/cpp08.png)   

### 成员访问权限
1. 成员：成员变量、成员函数
2. 成员访问权限、**继承方式**有3种
    1. public:公共的，任何地方都可以访问(struct默认)
    2. protected:子类内部、当前类内部可以访问
    3. prvate:私有的，只有当前类内部可以访问(class默认)
    
    ```
    struct Person
    {
    //public:
    protected:
    //private:
    	int m_age;
    	void run() {
    		cout << "run()" << endl;
    		//当前类的成员由public或者protected或者private修饰，在当前类内部可以访问成员。
    		this->m_age = 0;
    	}
    };
    struct Student : Person
    {	
    	int m_no;
    	void study() {
    		//当父类的成员为public或者protected时，子类可以访问父类的成员
    		//如果父类成员为private，子类不可以访问
    		this->m_age = 20;
    		this->run();
    	}
    };
    
    int main() {
    	Person person;
    	//当前类的成员被protected或private修饰时，外部不可以访问。
    	person.m_age = 10;
    
    	//当父类的子成员被修饰为protected或private，外部不可以访问。
    	Student student;
    	student.m_age = 10;
    
    	getchar();
    	return 0;
    }
    ```
3. 从上面说明继承也有三种方式public、protected、private
    1. 默认不写是public
4. 子类内部访问父类成员的权限，是以下2项中权限最小的那个
    1. 2项指：
        1. 成员本身的访问权限
        2. 上一级父类的继承方式
    2. 即：2项指同时有成员权限、继承权限
        
        ```
        struct Person
        {
        public:
        	int m_age;
        	void run() {
        		cout << "run()" << endl;
        		this->m_age = 0;
        	}
        };
        struct Student : private Person
        {	
        	int m_no;
        	void study() {
        	   //但是子类内部仍然可以访问父类的成员
        	   this->m_age = 20;
        		this->run();
        	}
        };
        struct GoodStudent :Student
        {
        	int m_money;
        	void test() {
        		//不能调用
        		//this->m_age = 30;
        		//this->run();
        		this->study();
        		this->m_no = 55;
        	}
        };
        //尽管父类的成员是public，但是有与子类继承是private，那么二者取最小权限private
        	Student student;
        	不能访问
        	//student.m_age = 10;
        	//可以访问
        	student.study();
        	student.m_no = 66;
        ```
        
        1. 从上面的3个类中我们可以看出
            1. Person成员为public
            2. Student的继承方式为private，但是
                1. Student内部可以访问父类Person的成员
                2. 外部不能通过Student访问其父类成员
                3. 外部可以通过Student 访问当前类的成员，说明当前类的权限仍然是默认的public
            3. GoodStudent的内部不能访问Person的成员
            4. 结论：**继承权限本质就是将父类的成员拿到子类，并全部把父类的成员权限设置为同继承权限一样的权限，但是不会影响当前类的成员权限**
5. 开发中用的最多的继承方式是public，这样能保留父类原来的成员访问权限
6. 访问权限不影响对象的内存布局
 
    
    
    


