---
layout: post
title: 第五章 析构函数、命名空间、继承、成员访问权限、初始化列表
category: CPP基础
tags: CPP基础
description: CPP基础
--- 

## 析构函数(Destructor) 
1. 析构函数(也叫析构器)，在对象销毁的时候自动调用，一般用于完成对象的清理工作 
2. 特点 
    1. 函数名以~开头，与类同名，无返回值(void都不能写)，无参，不可以重载，**有且只有**一个析构函数 
3. 注意 
    1. 通过malloc分配的对象free的时候不会调用构造函数
4. 构造函数、析构函数要声明为public，才能被外界正常使用
    
    ```
    struct Person
    {
    	int m_age;
    	//对象创建完毕的时候调用
    	Person() {
    		cout << "Person()" << endl;
    		this->m_age = 0;
    	}
    	//对象被销毁的时候调用
    	~Person() {
    		cout << "~Person()" << endl;
    	}
    };
    
    
    int main() {
    	//堆
    	{
    		Person person;
    	}
    	//栈
    	Person *p = new Person;
    	delete p;
    
    	getchar();
    	return 0;
    }
    ```

## 对象的内存管理 
1. 对象内部申请的堆空间，由对象内部回收 
2. 多注意setter和析构的内存管理
    1. 注意点1：对象的成员函数是指针与是类的区别
        
        ```
        struct Car
        {
            	Car() {
            		cout << "car()" << endl;
            	}
            	~Car()
            	{
            		cout << "~Car()" << endl;
            	}
        
        };
        
        struct Person
        {
            	int m_age;
            	//Car m_car;//这么写，在创建person对象的时候会创建一个Car对象
            	Car *m_car;//这么写，在创建person对象的时候只会创建一个指针变量，占4个字节，不会创建Car对象
            	Person() {
            		cout << "Person()" << endl;
            	}
            
            	//内存回收、清理工作
            	~Person() {
            		cout << "~Person()" << endl;
            	}
        };
        
        int main(){
            	Person *p = new Person;
              delete p;
            	getchar();
            	return 0;
        }
        ```
    2. 在构造函数内部分配内存，需要在析构函数内部释放
        
        ```
        struct Car
        {
            	int m_price;
            	Car() {
            		cout << "car()" << endl;
            	}
            	~Car()
            	{
            		cout << "~Car()" << endl;
            	}
        };
        
        struct Person
        {
            	int m_age;
            	Car *m_car;
            	Person() {
            		cout << "Person()" << endl;
            		this->m_car = new Car();
            	}
            
            	//内存回收、清理工作
            	~Person() {
            		cout << "~Person()" << endl;
            		delete this->m_car;
              }
        };
        
        //使用
        Person *p = new Person();
        delete p;
        ```
    3. 在setter方法内部分配内存，同时在setter方法内部释放，但是调用释放在析构函数中
    
 
## 声明和实现分离 
1. 类的声明写到.h文件，类的实现写到.cpp；当然也可以都写在一个文件中
    
    ```
    //Person.h
    
    #pragma once
    class Person
    {
    public:
    	Person();
    	~Person();
    	void setAge(int age);
    	int getAge();
    
    private:
    	int m_age;
    }
    
    //Person.cpp
    #include<iostream>
    #include"Person.h"
    using namespace std;
    
    Person::Person()
    {
    	cout << "person()" << endl;
    }
    
    Person::~Person()
    {
    	cout << "~Person()" << endl;
    }
    
    void Person::setAge(int age) {
    	this->m_age = age;
    	cout << "setAge" << endl;
    }
    
    int  Person::getAge() {
    	cout << "getAge" << endl;
    	return this->m_age;
    }
    
    int main() {
    	Person person;
    	person.setAge(10);
    	cout << person.getAge() << endl;
    	getchar();
    	return 0;
    }
    ```
    
## 命名空间
1. 命名空间可以用来避免命名冲突 
    
    ```
    class Person
    {
    public:
    	int m_age;
    };
    //全局变量
    int g_no;
    
    //函数
    void test() {
    
    }
    
    //命名空间
    namespace ZH {
    	//全局变量
    	int g_no;
    	//函数
    	void test() {
    
    	}
    
    	class Person
    	{	
    	public:
    		int m_age;
    	};
    }
    
    int main() {

    	Person person;
    	person.m_age = 10;
    
    	ZH::Person person2;
    	person2.m_age = 20;
    
    	g_no = 30;
    	ZH::g_no = 40;
    
    	test();
    	ZH::test();
    	
    	cout << "person.m_age=" << person.m_age << endl;
    	cout << "person2.m_age=" << person2.m_age << endl;
    
    	getchar();
    	return 0;
    }
    ```
2. `using namespace 空间名;`
    1. 声明我要用“空间名”中的东西，统一声明，不用在使用的时候还要每次写
    
    ```
    //命名空间
    namespace ZH {
    	//全局变量
    	int g_no;
    	//函数
    	void test() {
    
    	}
    
    	class Person
    	{	
    	public:
    		int m_age;
    	};
    }
    
    //统一使用
    using namespace ZH;
    g_no = 10;
    Person person;
    test();
    
    //指定用命名空间的哪一个
    using ZH::g_no;
    g_no = 10;
    ```
3. 命名空间不影响内存布局
  
  
### 命名空间的嵌套
1. 举例：
    
    ```
    namespace ZH {
    	 namespace SS {
    		 int g_age;
    	 }
    }
    
    int main() {
    
    	ZH::SS::g_age = 10;
    
    	using namespace ZH::SS;
    	g_age = 20;
    
    	using ZH::SS::g_age;
    	g_age = 30;
    }
    ```
2. 有个默认的全局命名空间，我们创建的命名空间默认都嵌套在它里面
    
    ```
    int g_no;

     namespace ZH {
    	 namespace SS {
    		 int g_age;
    	 }
    }
    
    int main() {
    	//下面2个等价
    	g_no = 10;
    	//默认命名空间::,全局命名空间
    	::g_no = 10;
    
    	using namespace ZH::SS;
    	g_age = 20;
    }
    ```
    
    
### 命名空间的合并
1. 以下2种写法是等价的
    
    ```
    //写法1
    namespace ZH {
    	int g_age;
    }
    
    namespace ZH {
    	int g_no;
    }
    
    //等价于写法2
    namespace ZH {
     int g_age;
    	int g_no;
    }
    ```
2. 命名空间用在类中
    
    ```
    //Person.h
    #pragma once
    namespace ZH {
    	class Person
    	{
    	public:
    		Person();
    		~Person();
    	};
    }
    
    //Person.cpp
    #include "Person.h"

    namespace ZH {
    	Person::Person()
    	{
    	}
    
    
    	Person::~Person()
    	{
    	}
    }
    
    //main函数使用
    #include<iostream>
    #include"Person.h"
    using namespace ZH;
    using namespace std;
    
    int main() {
        Person = person;
        return 0;
    }
    ```
    
    
    


