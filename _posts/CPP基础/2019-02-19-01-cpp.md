---
layout: post
title: 第五章 析构函数、命名空间、继承、成员访问权限、初始化列表
category: CPP基础
tags: CPP基础
description: CPP基础
--- 

## 析构函数(Destructor) 
1. 析构函数(也叫析构器)，在对象销毁的时候自动调用，一般用于完成对象的清理工作 
2. 特点 
    1. 函数名以~开头，与类同名，无返回值(void都不能写)，无参，不可以重载，**有且只有**一个析构函数 
3. 注意 
    1. 通过malloc分配的对象free的时候不会调用构造函数
4. 构造函数、析构函数要声明为public，才能被外界正常使用
    
    ```
    struct Person
    {
    	int m_age;
    	//对象创建完毕的时候调用
    	Person() {
    		cout << "Person()" << endl;
    		this->m_age = 0;
    	}
    	//对象被销毁的时候调用
    	~Person() {
    		cout << "~Person()" << endl;
    	}
    };
    
    
    int main() {
    	//堆
    	{
    		Person person;
    	}
    	//栈
    	Person *p = new Person;
    	delete p;
    
    	getchar();
    	return 0;
    }
    ```

## 对象的内存管理 
1. 对象内部申请的堆空间，由对象内部回收 
2. 多注意setter和析构的内存管理
    1. 注意点1：对象的成员函数是指针与是类的区别
        
        ```
        struct Car
        {
            	Car() {
            		cout << "car()" << endl;
            	}
            	~Car()
            	{
            		cout << "~Car()" << endl;
            	}
        
        };
        
        struct Person
        {
            	int m_age;
            	//Car m_car;//这么写，在创建person对象的时候会创建一个Car对象
            	Car *m_car;//这么写，在创建person对象的时候只会创建一个指针变量，占4个字节，不会创建Car对象
            	Person() {
            		cout << "Person()" << endl;
            	}
            
            	//内存回收、清理工作
            	~Person() {
            		cout << "~Person()" << endl;
            	}
        };
        
        int main(){
            	Person *p = new Person;
              delete p;
            	getchar();
            	return 0;
        }
        ```
    2. 在构造函数内部分配内存，需要在析构函数内部释放
        
        ```
        struct Car
        {
            	int m_price;
            	Car() {
            		cout << "car()" << endl;
            	}
            	~Car()
            	{
            		cout << "~Car()" << endl;
            	}
        };
        
        struct Person
        {
            	int m_age;
            	Car *m_car;
            	Person() {
            		cout << "Person()" << endl;
            		this->m_car = new Car();
            	}
            
            	//内存回收、清理工作
            	~Person() {
            		cout << "~Person()" << endl;
            		delete this->m_car;
              }
        };
        
        //使用
        Person *p = new Person();
        delete p;
        ```
    3. 在setter方法内部分配内存，同时在setter方法内部释放，但是调用释放在析构函数中
    
 
## 声明和实现分离 
1. 类的声明写到.h文件，类的实现写到.cpp；当然也可以都写在一个文件中
    
    ```
    //Person.h
    
    #pragma once
    class Person
    {
    public:
    	Person();
    	~Person();
    	void setAge(int age);
    	int getAge();
    
    private:
    	int m_age;
    }
    
    //Person.cpp
    #include<iostream>
    #include"Person.h"
    using namespace std;
    
    Person::Person()
    {
    	cout << "person()" << endl;
    }
    
    Person::~Person()
    {
    	cout << "~Person()" << endl;
    }
    
    void Person::setAge(int age) {
    	this->m_age = age;
    	cout << "setAge" << endl;
    }
    
    int  Person::getAge() {
    	cout << "getAge" << endl;
    	return this->m_age;
    }
    
    int main() {
    	Person person;
    	person.setAge(10);
    	cout << person.getAge() << endl;
    	getchar();
    	return 0;
    }
    ```
    
    


