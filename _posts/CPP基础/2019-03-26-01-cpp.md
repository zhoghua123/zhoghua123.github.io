---
layout: post
title: 第十四章 STL第四节 Set和multiset、Map和multimap容器
category: CPP基础
tags: CPP基础
description: CPP基础
---    

### Set和multiset容器
1. Set和multiset简介
    1. set是一个集合容器，其中所包含的元素是**唯一**的，集合中的元素**按一定的顺序自动排列**。元素插入过程是**按排序规则**插入，所以不能指定插入位置。
    2. set采用红黑树变体的数据结构实现，红黑树属于平衡二叉树。在插入操作和删除操作上比vector快。
    3. set不可以直接存取元素。（不可以使用at.(pos)与[]操作符）。
    4. multiset与set的区别：set支持唯一键值，每个元素值只能出现一次；而multiset中**同一值可以出现多次**。
    5. 不可以直接修改set或multiset容器中的元素值，因为该类容器是**自动排序**的。如果希望修改一个元素值，必须先删除原有的元素，再插入新的元素。
    6. `#include <set>`
2. set的插入与迭代器
    1. 函数：
        
        ```
        set.insert(elem);     //在容器中插入元素。
        set.begin();  //返回容器中第一个数据的迭代器。
        set.end();  //返回容器中最后一个数据之后的迭代器。
        set.rbegin();  //返回容器中倒数第一个元素的迭代器。
        set.rend();   //返回容器中倒数最后一个元素的后面的迭代器。
        ```
    2. 举例：
        
        ```
        set<int> setInt;
        setInt.insert(3); setInt.insert(1);setInt.insert(5);setInt.insert(2);
        for(set<int>::iterator it=setInt.begin(); it!=setInt.end(); ++it)
        {
              int iItem = *it;
              cout << iItem;    //或直接使用cout << *it
        }
        //这样子便顺序输出  1 2 3 5。
        ```
3. Set集合的元素排序 
    1. 示例：
        
        ```
        set<int,less<int> >  setIntA;  //该容器是按升序方式排列元素。
        set<int,greater<int>> setIntB;   //该容器是按降序方式排列元素。
        ```
        
        1. `set<int>` 相当于 `set<int,less<int>>`。
        2. `less<int>`与`greater<int>`中的int可以改成其它类型，该类型主要要跟set容纳的数据类型一致。
    2. 疑问1：less<>与greater<>是什么？
    3. 疑问2：如果set<>不包含int类型，而是包含自定义类型，set容器如何排序？
    4. 要解决如上两个问题，需要了解容器的函数对象，也叫伪函数，英文名叫`functor`。
    5. 举例使用
        
        ```
        set<int,greater<int>> setIntB;   
        setIntB.insert(3);
        setIntB.insert(1);
        setIntB.insert(5);
        setIntB.insert(2);
        //此时容器setIntB就包含了按顺序的5,3,2,1元素
        ```
4. 函数对象functor的用法 
    1. 尽管函数指针被广泛用于实现函数回调，但C++还提供了一个重要的实现回调函数的方法，那就是函数对象。
    2. functor，翻译成函数对象，伪函数，算符，是重载了“()”操作符的普通类对象。从语法上讲，它与普通函数行为类似。
    3. greater<>与less<>就是函数对象。
    4. 下面举出greater<int>的简易实现原理。
        
        ```
        template <class Item>
        struct greater{
        //重载()运算符
        bool operator() (const Item& iLeft, const Item& iRight){
               return (iLeft>iRight);    //如果是实现less<int>的话，这边是写return (iLeft<iRight);
        }
        }
        //容器就是调用函数对象的operator()方法去比较两个值的大小。
        ```
    5. 从上面greater实现可以看出，要想实现复杂数据类型的的排序必须满足一下条件
        1. 实现自定义类的函数对象
        2. 在函数对象中重载（）方法，指明按照自定义类的那个属性排序
        3. 声明容器时说明
        4. 示例代码：
            
            ```
            //题目：学生包含学号，姓名属性，现要求任意插入几个学生对象到set容器中，使得容器中的学生按学号的升序排序。
            //1. 学生类
            class CStudent
            {
            	public:
            		CStudent(int iID, string strName)
            		{
            			m_iID = iID;
            			m_strName = strName;
            		}
                 int m_iID;	//学号
                 string m_strName;  //姓名
            }
            //为保持主题鲜明，本类不写拷贝构造函数，不类也不需要写拷贝构造函数。但大家仍要有考虑拷贝构造函数的习惯。
            
            //2. 创建函数对象
            //函数对象：因为这是特定类型，所以就不需要类模板了
            struct StuFunctor{
                //3. 重载()操作符
            		bool operator()  (const CStudent &stu1, const CStudent &stu2){
            			return (stu1.m_iID<stu2.m_iID);
            		}
            }
            
            //3. 使用
            //main函数
            void main(){
            		set<CStudent, StuFunctor> setStu;
            		setStu.insert(CStudent(3,"小张"));
            		setStu.insert(CStudent(1,"小李"));
            		setStu.insert(CStudent(5,"小王"));
            		setStu.insert(CStudent(2,"小刘"));
            		//此时容器setStu包含了四个学生对象，分别是按姓名顺序的“小李”，“小刘”，“小张”，“小王” 
            }
            ```
5. pair的使用
    1. pair也是一个容器，译为对组，这个容器只能存放2个元素
    2. pair<T1,T2>:表示存放的两个值的类型，可以不一样，如T1为int，T2为float。T1,T2也可以是自定义类型。即**T1,T2代表pair存放的两个元素的类型**
    3. pair.first是pair里面的第一个值，是T1类型。
    4. pair.second是pair里面的第二个值，是T2类型。
    5. **就相当于OC中RAC框架中的元组RACTuple**
    6. 举例使用：
        
        ```
        /*
        1. 如何判断一个数据是否插入成功？
        2. insert函数的返回值是_Pairib类型
        3. using _Pairib = pair<iterator, bool>;
        即_Pairib  是 pair<iterator, bool>类型
        注意： iterator要指出具体迭代器的类型
        */
        void test11() {
        	Teacher t1("t1", 30);
        	Teacher t2("t1", 22);
        	Teacher t3("t1", 34);
        	Teacher t4("t1", 44);
        	Teacher t5("t1", 30);
        
        	set<Teacher,FuncTeacher> ss1;
        
        	ss1.insert(t1);
        	ss1.insert(t2);
        	ss1.insert(t3);
        	//接收insert函数的返回值
        	//此时pair1，内部有2个元素，一个是迭代器，一个是bool值
        	pair<set<Teacher,FuncTeacher>::iterator, bool> pair1 = ss1.insert(t4);
        	if (pair1.second){
        		cout << "插入成功" << endl;
        	}else{
        		cout << "插入失败" << endl;
        	}
        	//这个会插入失败，因为有2个30
        	pair<set<Teacher, FuncTeacher>::iterator, bool> pair2 =ss1.insert(t5);
        	if (pair2.second) {
        		cout << "插入成功" << endl;
        	}
        	else {
        		cout << "插入失败" << endl;
        	}
        
        	for (set<Teacher, FuncTeacher>::iterator it = ss1.begin(); it != ss1.end(); it++) {
        		cout << it->m_age << ":" << it->name << endl;
        	}
        }
        ```
6. 赋值、大小：
    
    ```
    set<int> setIntA;
    setIntA.insert(3);
    setIntA.insert(1);
    setIntA.insert(7);
    setIntA.insert(5);
    setIntA.insert(9);
    
    set<int> setIntB(setIntA);  //1 3 5 7 9
    	
    set<int> setIntC;
    setIntC = setIntA;		//1 3 5 7 9
    
    setIntC.insert(6);
    setIntC.swap(setIntA);	  //交换
    
    setIntC.empty();//判断容器是否为空
    setIntC.size();	//返回容器中元素的数目
    ```
7. set的删除
    
    ```
    set.clear();		//清除所有元素
    set.erase(pos);	//删除pos迭代器所指的元素，返回下一个元素的迭代器。
    set.erase(beg,end);	    //删除区间[beg,end)的所有元素	，返回下一个元素的迭代器。
    set.erase(elem);     //删除容器中值为elem的元素。

    //删除区间内的元素
    //setInt是用set<int>声明的容器，现已包含按顺序的1,3,5,6,9,11元素。
    set<int>::iterator itBegin=setInt.begin();
    ++ itBegin;
    set<int>::iterator itEnd=setInt.begin();
    ++ itEnd;
    ++ itEnd;
    ++ itEnd;
    setInt.erase(itBegin,itEnd);
    //此时容器setInt包含按顺序的1,6,9,11四个元素。
    
    //删除容器中第一个元素
    setInt.erase(setInt.begin());		//6,9,11
    
    //删除容器中值为9的元素
    set.erase(9);    

    //删除setInt的所有元素
    setInt.clear();			//容器为空
    ```
8. set的查找
    1. 函数
        
        ```
        set.find(elem);   //查找elem元素，返回指向elem元素的迭代器。
        set.count(elem);   //返回容器中值为elem的元素个数。对set来说，要么是0，要么是1。对multiset来说，值不可能大于1。
        set.lower_bound(elem);  //返回第一个>=elem元素的迭代器。
        set.upper_bound(elem);//  返回第一个>elem元素的迭代器。
        set.equal_range(elem); //返回容器中与elem相等的上下限的两个迭代器。上限是闭区间，下限是开区间，如[beg,end)。
        //以上函数返回两个迭代器，而这两个迭代器被封装在pair中。
        
        set<int> setInt;
        setInt.insert(3);
        setInt.insert(1);
        setInt.insert(7);
        setInt.insert(5);
        setInt.insert(9);
        
        set<int>::iterator itA = setInt.find(5);
        int iA = *itA;		//iA == 5
        int iCount = setInt.count(5); //iCount == 1
        
        set<int>::iterator itB = setInt.lower_bound(5);
        set<int>::iterator itC = setInt.upper_bound(5);
        int iB = *itB;	//iB == 5
        int iC = *itC; //iC == 7
        
        pair< set<int>::iterator, set<int>::iterator > pairIt = setInt.equal_range(5);  //pair是什么？
        set<int>::iterator itBeg = pairIt.first;
        set<int>::iterator itEnd = pairIt.second;
        //此时 *itBeg==5  而  *itEnd == 7
        ```
    
### Map和multimap容器
    
            
            
            
    



