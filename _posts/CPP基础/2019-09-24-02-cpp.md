---
layout: post
title: QT-第六节 绘图和绘图设备
category: CPP基础
tags: CPP基础
description: CPP基础
--- 

## 绘图和绘图设备
1. Qt 的绘图系统允许使用相同的 API 在屏幕和其它打印设备上进行绘制。整个绘图系统基于QPainter，QPainterDevice和QPaintEngine三个类。
    1. QPainter用来执行绘制的操作；
    2. QPaintDevice是一个二维空间的抽象，这个二维空间允许QPainter在其上面进行绘制，也就是QPainter工作的空间；
    3. QPaintEngine提供了画笔（QPainter）在不同的设备上进行绘制的统一的接口。QPaintEngine类应用于QPainter和QPaintDevice之间，通常对开发人员是透明的。除非你需要自定义一个设备，否则你是不需要关心QPaintEngine这个类的。
2. **我们可以把QPainter理解成画笔；把QPaintDevice理解成使用画笔的地方，比如纸张、屏幕等；而对于纸张、屏幕而言，肯定要使用不同的画笔绘制，为了统一使用一种画笔，我们设计了QPaintEngine类，这个类让不同的纸张、屏幕都能使用一种画笔。**
3. **Qt 的绘图系统实际上是，使用QPainter在QPainterDevice上进行绘制，它们之间使用QPaintEngine进行通讯（也就是翻译QPainter的指令）。**

### QPainter
1. 重写QWidget的paintEvent()函数。接下来就是PaintedWidget的源代码：
    
    ```
    #include "widget.h"
    #include "ui_widget.h"
    #include<QPainter>
    
    Widget::Widget(QWidget *parent) :
        QWidget(parent),
        ui(new Ui::Widget)
    {
        ui->setupUi(this);
    }
    
    Widget::~Widget()
    {
        delete ui;
    }
    //绘图事件
    //调用时刻，系统自动调用，相当于iOS 的drawract
    void Widget:: paintEvent(QPaintEvent *){
        //创建画家
        //构造函数需要制定一个画板QPaintDevice，把this作为画板
        //因为QWidget继承自QObject/QPaintDevice,因此可以做画板
        QPainter painter(this);
    
        //设置画笔属性
        //画笔颜色
    //    painter.setPen(Qt::blue);
        QPen pen(QColor(255,0,0));
        //设置线宽
        pen.setWidth(10);
        //设置风格(虚线)
        pen.setStyle(Qt::DotLine);
        painter.setPen(pen);
    
        //填充封闭图形的颜色
        QBrush bursh(Qt::green);
        //设置风格
        bursh.setStyle(Qt::Dense1Pattern);
        painter.setBrush(bursh);
    
        //画家画画
        //划线
        painter.drawLine(QPoint(0,0),QPoint(100,100));
        //画圆
        painter.drawEllipse(QPoint(100,100),50,50);
        //矩形
        painter.drawRect(QRect(200,200,100,50));
        //画一个字
        painter.drawText(QRect(100,200,100,50),"好好学习");
    }

    ```
2. 高级设置
    
    ```
    QPainter painter(this);
    //    painter.drawEllipse(QPoint(100,100),50,50);
    //    //高级设置
    //    //设置抗锯齿能力,圆会更好，但是效率低
    //    painter.setRenderHint(QPainter:: Antialiasing);
    //    painter.drawEllipse(QPoint(200,100),50,50);
    
    //矩形
    painter.drawRect(QRect(20,20,50,50));
    //移动(本来应该是重合的，但是移动就不会重合了)
    painter.translate(100,0);
    //保存状态
    painter.save();
    painter.drawRect(QRect(20,20,50,50));
        
    //这个移动将失效
    painter.translate(100,0);
    //取出状态,此时第三个矩形，就不会移动了，就会和第二个矩形重合
    //因为此时拿到第二个矩形保存的状态，之前的移动就没用了
    painter.restore();
    painter.drawRect(QRect(20,20,50,50));
    
    ```
3. 画图
    
    ```
    Widget::Widget(QWidget *parent) :QWidget(parent), ui(new Ui::Widget)
    {
        ui->setupUi(this);
        //点击按钮移动图片
        pointx = 10;
        connect(ui->pushButton,&QPushButton::clicked,[=](){
            pointx+=10;
            //!!!不能手动调用paintEvent
            //需要通过update,会自动调用paintEvent
            update();
        });
    }
    
    Widget::~Widget()
    {
        delete ui;
    }
    void Widget:: paintEvent(QPaintEvent *){
        //创建画家
        //构造函数需要制定一个画板QPaintDevice，把this作为画板
        //因为QWidget继承自QObject/QPaintDevice,因此可以做画板
        QPainter painter(this);
        //如果出屏幕，则返回原位置
        if(pointx> this->width()){
            pointx = 10;
        }
        painter.drawPixmap(pointx,10,QPixmap(":/Image/Luffy.png"));
    }
    ```
    
### 绘图设备
1. 绘图设备是指继承QPainterDevice的子类。Qt一共提供了四个这样的类，分别是QPixmap、QBitmap、QImage和 QPicture。
    
    ```
    QPixmap专门为图像在屏幕上的显示做了优化
    QBitmap是QPixmap的一个子类，它的色深限定为1，可以使用 QPixmap的isQBitmap()函数来确定这个QPixmap是不是一个QBitmap。
    QImage专门为图像的像素级访问做了优化。 
    QPicture则可以记录和重现QPainter的各条命令。
    ```

#### QPixmap、QBitmap、QImage
1. QPixmap:
    1. 继承了QPaintDevice，因此，你可以使用QPainter直接在上面绘制图形。
    2. QPixmap也可以接受一个字符串作为一个文件的路径来显示这个文件，比如你想在程序之中打开png、jpeg之类的文件，就可以使用 QPixmap。
    3. 使用QPainter的drawPixmap()函数可以把这个文件绘制到一个QLabel、QPushButton或者其他的设备上面。
    4. QPixmap是针对屏幕进行特殊优化的，因此，它与实际的底层显示设备息息相关。
    5. 注意，这里说的显示设备并不是硬件，而是操作系统提供的原生的绘图引擎。所以，在不同的操作系统平台下，QPixmap的显示可能会有所差别。
2. QBitmap
    1. 继承自QPixmap，因此具有QPixmap的所有特性，提供单色图像。
    2. QBitmap的色深始终为1. 色深这个概念来自计算机图形学，是指用于表现颜色的二进制的位数。我们知道，计算机里面的数据都是使用二进制表示的。为了表示一种颜色，我们也会使用二进制。比如我们要表示8种颜色，需要用3个二进制位，这时我们就说色深是3. 因此，所谓色深为1，也就是使用1个二进制位表示颜色。1个位只有两种状态：0和1，因此它所表示的颜色就有两种，黑和白。所以说，QBitmap实际上是只有黑白两色的图像数据。
    3. 由于QBitmap色深小，因此只占用很少的存储空间，所以适合做光标文件和笔刷。
3. QImage
    1. QPixmap使用底层平台的绘制系统进行绘制，无法提供像素级别的操作，**而QImage则是使用独立于硬件的绘制系统，实际上是自己绘制自己，因此提供了像素级别的操作，并且能够在不同系统之上提供一个一致的显示形式。**
    2. 代码示例
        
        ```
        void Widget:: paintEvent(QPaintEvent *){
            QImage img;
            img.load(":/Image/Luffy.png");
        
            //img可以修改像素点
            //把这张图片的某一块像素点给设置成红色
            for (int i= 50;i<100;i++) {
                for (int j = 50;j<100;j++) {
                    QRgb value = qRgb(255,0,0);
                    img.setPixel(i,j,value);
                }
            }
            QPainter painter(this);
            painter.drawImage(QPoint(50,50),img);
        }
        ```
4. QImage与QPixmap的区别
    1. QPixmap主要是用于绘图，针对屏幕显示而最佳化设计，QImage主要是为图像I/O、图片访问和像素修改而设计的
    2. QPixmap依赖于所在的平台的绘图引擎，故例如反锯齿等一些效果在不同的平台上可能会有不同的显示效果，QImage使用Qt自身的绘图引擎，可在不同平台上具有相同的显示效果
    3. 由于QImage是独立于硬件的，也是一种QPaintDevice，因此我们可以在另一个线程中对其进行绘制，而不需要在GUI线程中处理，使用这一方式可以很大幅度提高UI响应速度。
    4. QImage可通过setPixpel()和pixel()等方法直接存取指定的像素。
    5. QImage与QPixmap之间的转换:
        1. QImage转QPixmap：使用QPixmap的静态成员函数: fromImage()
            
            ```
            QPixmap	fromImage(const QImage & image, 
            Qt::ImageConversionFlags flags = Qt::AutoColor)
            ```
        2. QPixmap转QImage:使用QPixmap类的成员函数: toImage()
            
            ```
            QImage toImage() const
            ```
    6. 代码示例：
        
        ```
        Widget::Widget(QWidget *parent) :QWidget(parent),ui(new Ui::Widget)
        {
            ui->setupUi(this);

            //QPixmap 做绘图设备
            //对不同平台进行了优化
            QPixmap pix(300,300);
            //设置pix，默认填充色，即画面的背景色
            pix.fill(Qt::white);
            QPainter painter(&pix);
            painter.setPen(QPen(Qt::red));
            painter.drawEllipse(QPoint(150,150),50,50);
            //保存这张图片
            pix.save("C:\\pix.png");
            
            //QImage 做绘图设备
            //QImage没有直接设置宽高的构造函数
            //对像素进行了优化
            QImage img(300,300,QImage::Format_RGB32);
            img.fill(Qt::white);
            QPainter painter(&img);
            painter.setPen(QPen(Qt::blue));
            painter.drawEllipse(QPoint(150,150),50,50);
            //保存这张图片
            img.save("C:\\img.png");
            
            //上面这么做运行程序是什么也看不到的，因为并没有在Widget窗口上画画
            //打开C盘目录下找到pix.png打开，可以看见
        }
        ```

#### QPicture
1. QPicture是一个可以记录和重现QPainter命令的绘图设备。
   1. 不是用来画图的，是用来记录画图指令，然后重现画图指令的
2.  QPicture将QPainter的命令序列化到一个IO设备，保存为一个平台独立的文件格式。这种格式有时候会是“元文件(meta- files)”。
3. Qt的这种格式是二进制的，不同于某些本地的元文件，Qt的pictures文件没有内容上的限制，只要是能够被QPainter绘制的元素，不论是字体还是pixmap，或者是变换，都可以保存进一个picture中。
4. QPicture是平台无关的，因此它可以使用在多种设备之上，比如svg、pdf、ps、打印机或者屏幕。回忆下我们这里所说的QPaintDevice，实际上是说可以有QPainter绘制的对象。QPicture使用系统的分辨率，并且可以调整 QPainter来消除不同设备之间的显示差异。
5. 如果我们要记录下QPainter的命令，首先要使用QPainter::begin()函数，将QPicture实例作为参数传递进去，以便告诉系统开始记录，记录完毕后使用QPainter::end()命令终止。代码示例如下：
    
    ```
    Widget::Widget(QWidget *parent) :QWidget(parent), ui(new Ui::Widget)
    {
        ui->setupUi(this);
    
        //QPicture 绘图设备
        //不是用来画图的，是用来记录画图指令，然后重现画图指令的
        //1. 记录画图指令
        QPicture pic; //用于重新记录绘图指令
        QPainter painter;
        //开始记录指令
        painter.begin(&pic);
        painter.setPen(QPen(Qt::green));
        painter.drawEllipse(QPoint(150,150),50,50);
        //结束指令
        painter.end();
        //保存指令
        pic.save("C:\\pic.zt");
    }
    
    void Widget:: paintEvent(QPaintEvent *){
        //2、重现绘图指令
        QPicture pic;
        pic.load("c:\\pic.zt");
        QPainter painter(this);
        painter.drawPicture(0,0,pic);
    }
    ```



