---
layout: post
title: QT-第六节 绘图和绘图设备
category: CPP基础
tags: CPP基础
description: CPP基础
--- 

## 绘图和绘图设备
1. Qt 的绘图系统允许使用相同的 API 在屏幕和其它打印设备上进行绘制。整个绘图系统基于QPainter，QPainterDevice和QPaintEngine三个类。
    1. QPainter用来执行绘制的操作；
    2. QPaintDevice是一个二维空间的抽象，这个二维空间允许QPainter在其上面进行绘制，也就是QPainter工作的空间；
    3. QPaintEngine提供了画笔（QPainter）在不同的设备上进行绘制的统一的接口。QPaintEngine类应用于QPainter和QPaintDevice之间，通常对开发人员是透明的。除非你需要自定义一个设备，否则你是不需要关心QPaintEngine这个类的。
2. **我们可以把QPainter理解成画笔；把QPaintDevice理解成使用画笔的地方，比如纸张、屏幕等；而对于纸张、屏幕而言，肯定要使用不同的画笔绘制，为了统一使用一种画笔，我们设计了QPaintEngine类，这个类让不同的纸张、屏幕都能使用一种画笔。**
3. **Qt 的绘图系统实际上是，使用QPainter在QPainterDevice上进行绘制，它们之间使用QPaintEngine进行通讯（也就是翻译QPainter的指令）。**

### QPainter
1. 重写QWidget的paintEvent()函数。接下来就是PaintedWidget的源代码：
    
    ```
    #include "widget.h"
    #include "ui_widget.h"
    #include<QPainter>
    
    Widget::Widget(QWidget *parent) :
        QWidget(parent),
        ui(new Ui::Widget)
    {
        ui->setupUi(this);
    }
    
    Widget::~Widget()
    {
        delete ui;
    }
    //绘图事件
    //调用时刻，系统自动调用，相当于iOS 的drawract
    void Widget:: paintEvent(QPaintEvent *){
        //创建画家
        //构造函数需要制定一个画板QPaintDevice，把this作为画板
        //因为QWidget继承自QObject/QPaintDevice,因此可以做画板
        QPainter painter(this);
    
        //设置画笔属性
        //画笔颜色
    //    painter.setPen(Qt::blue);
        QPen pen(QColor(255,0,0));
        //设置线宽
        pen.setWidth(10);
        //设置风格(虚线)
        pen.setStyle(Qt::DotLine);
        painter.setPen(pen);
    
        //填充封闭图形的颜色
        QBrush bursh(Qt::green);
        //设置风格
        bursh.setStyle(Qt::Dense1Pattern);
        painter.setBrush(bursh);
    
        //画家画画
        //划线
        painter.drawLine(QPoint(0,0),QPoint(100,100));
        //画圆
        painter.drawEllipse(QPoint(100,100),50,50);
        //矩形
        painter.drawRect(QRect(200,200,100,50));
        //画一个字
        painter.drawText(QRect(100,200,100,50),"好好学习");
    }

    ```
2. 高级设置
    
    ```
    QPainter painter(this);
    //    painter.drawEllipse(QPoint(100,100),50,50);
    //    //高级设置
    //    //设置抗锯齿能力,圆会更好，但是效率低
    //    painter.setRenderHint(QPainter:: Antialiasing);
    //    painter.drawEllipse(QPoint(200,100),50,50);
    
    //矩形
    painter.drawRect(QRect(20,20,50,50));
    //移动(本来应该是重合的，但是移动就不会重合了)
    painter.translate(100,0);
    //保存状态
    painter.save();
    painter.drawRect(QRect(20,20,50,50));
        
    //这个移动将失效
    painter.translate(100,0);
    //取出状态,此时第三个矩形，就不会移动了，就会和第二个矩形重合
    //因为此时拿到第二个矩形保存的状态，之前的移动就没用了
    painter.restore();
    painter.drawRect(QRect(20,20,50,50));
    
    ```
3. 画图
    
    ```
    Widget::Widget(QWidget *parent) :QWidget(parent), ui(new Ui::Widget)
    {
        ui->setupUi(this);
        //点击按钮移动图片
        pointx = 10;
        connect(ui->pushButton,&QPushButton::clicked,[=](){
            pointx+=10;
            //!!!不能手动调用paintEvent
            //需要通过update,会自动调用paintEvent
            update();
        });
    }
    
    Widget::~Widget()
    {
        delete ui;
    }
    void Widget:: paintEvent(QPaintEvent *){
        //创建画家
        //构造函数需要制定一个画板QPaintDevice，把this作为画板
        //因为QWidget继承自QObject/QPaintDevice,因此可以做画板
        QPainter painter(this);
        //如果出屏幕，则返回原位置
        if(pointx> this->width()){
            pointx = 10;
        }
        painter.drawPixmap(pointx,10,QPixmap(":/Image/Luffy.png"));
    }
    ```



