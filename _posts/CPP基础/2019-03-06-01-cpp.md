---
layout: post
title: 第十章 友元、内部类、局部类、运算符重载
category: CPP基础
tags: CPP基础
description: CPP基础
---  

## 友元
1. 友元包括友元函数和友元类
2. 如果将函数A(非成员函数)声明为类C的友元函数，那么函数A就能直接访问类C对象的所有成员
3. 如果将类A声明为类C的友元类，那么类A的所有成员函数都能直接访问类C对象的所有成员
4. 友元破坏了面向对象的封装性，但在某些频繁访问成员变量的地方可以提高性能
    
    ```
    class Point {
    	//友元函数：让add函数成为当前类的朋友，然后add函数就可以直接访问当前类的成员了
    	//这句话可以放在这个类的任何地方
    	friend Point add(const Point &, const Point &);
    
    	//友元类,Math成为当前类的友元类，那么在Math内部就可以直接访问当前类的所有成员
    	friend  class Math;
    	int m_x;
    	int m_y;
    public:
    	int getX() const { return this->m_x; }
    	int getY() const { return this->m_y; }
    	Point(int x, int y) :m_x(x), m_y(y) {
    
    	}
    };
    
    Point add(const Point &point1, const Point &point2) {
    
    	/*return Point(point1.getX()+point2.getX(),point1.getY()+point2.getY());*/
    	//直接访问Point类的所有成员
    	return Point(point1.m_x + point2.m_x, point1.m_y + point2.m_y);
    }
    
    class Math {
    	Point dele(const Point &point1, const Point &point2) {
    		/*return Point(point1.getX()-point2.getX(),point1.getY()-point2.getY());*/
    		//直接访问Point类的所有成员
    		return Point(point1.m_x - point2.m_x, point1.m_y - point2.m_y);
    	}
    };
    
    int main() {
    	Point point(10, 20);
    	Point point2(20, 30);
    	Point point3 = add(point, point2);
    
    	cout << endl;
    	getchar();
    	return 0;
    }
    ```

## 内部类
1. 如果将类A定义在类C的内部，那么类A就是一个内部类(嵌套类)
2. 内部类的特点
    1. 支持public、protected、private权限
    2. 成员函数可以直接访问其外部类对象的所有成员(反过来则不行)
    3. 成员函数可以直接不带类名、对象名访问其外部类的static成员
    4. 不会影响外部类的内存布局
    5. 可以在外部类内部声明，在外部类外面进行定义
    
    ```
    class Person {
    	int m_age;
    	static int ms_legs;
    	static void test(){}
    
    public:
    	Person() {
    		cout << "Person()" << endl;
    	}
    //1.支持public、protected、private权限
    //Car内只能在Person内部使用
    //private:  
    	//car
    	class Car {
    		int m_price;
    	public:
    		Car() {
    			cout << "Car()" << endl;
    		}
    		void run() {
    			//2. 成员函数可以直接访问其外部类对象的所有成员(反过来则不行)
    			Person perosn;
    			perosn.m_age = 10;
    
    			//3. 成员函数可以直接不带类名、对象名访问其外部类的static成员
    			ms_legs = 10;	
    			test();
    		}
    	};
    };
    int Person::ms_legs = 2;
    
    //5. 可以在外部类内部声明，在外部类外面进行定义
    class Point {
    	class Math {
    		void test();
    	};
    };
    
    void Point::Math::test() {
    
    }
    
    int main() {
    	//使用
    	Person person;
    	Person::Car car;
    
    	getchar();
    	return 0;
    }
    ```
3. 内部类 – 声明和实现分离
    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/cpp14.png)
4. 内部类的使用场合
    1. 某个类仅仅在一个类中使用

## 局部类
1. 在一个函数内部定义的类，称为局部类
2. 局部类的特点
    1. 作用域仅限于所在的函数内部
    2. 其所有的成员必须定义在类内部，不能类内部声明外部定义了，不允许定义static成员变量
    3. 成员函数不能直接访问函数的局部变量(static变量除外)
    
    ```
    int g_age = 10;
    void test() {
    	int age = 10;
    	static int s_age = 20;
    	//局部类
    	class Person {
    	public:
    		static void test() {
    		//成员函数不能直接访问函数的局部变量(static变量除外)
    		//age;
    		//全局变量可以
    		g_age = 20;
    		//静态变量可以
    		s_age;
    
    		}
    	};
    
    	Person person;
    	person.test();
    }
    
    int main() {
    	//注意：并不是每调一次都会定义一次类，类是在编译时候就完成了，没事调用只是调用函数
    	test();
    
    	getchar();
    	return 0;
    }
    ```
    
## 运算符重载(operator overload)
1. 运算符重载(操作符重载):可以为已存在的运算符增加一些新的功能
2. 全局函数、成员函数都支持运算符重载
    
    ```
    #include<iostream>
    using namespace std;
    
    class Point {
    	friend Point operator+(Point & , Point &);
    	int m_x;
    	int m_y;
    public:
    	Point(int x,int y):m_x(x),m_y(y) {}
    	
    	//成员函数 运算符重载
    	Point operator-(Point &P) {
    		return Point(this->m_x - P.m_x, this->m_y - P.m_y);
    	}    	
    	void display() {
    		cout << "x = " << this->m_x << "-y = " << this->m_y << endl;
    	}
    };
    
    //全局函数
    //运算符(操作符)重载：operator运算符
    Point operator+(Point &P1, Point &p2) {
    
    	return Point(P1.m_x + p2.m_x, P1.m_y + p2.m_y);
    }
    int main() {
    	Point p1(20, 30);
    	Point p2(30, 40);
    
    	//如果想这么做肯定是不行的，但是如果把“+”重载就可以了
    	Point p3 = p1 + p2;
    	//等价
    	//Point p3 = operator+(p1, p2);
    	p3.display();
    
    	//成员函数
    	Point p4 = p1 - p2;
    	//等价
    	//Point p4 = p1.operator-(p2);
    	p4.display();
    
    	getchar();
    	return 0;
    }
    ```
3. 操作符重载实战
    
    ```
    //Point.h
    #pragma once
    #include <iostream>
    using namespace std;
    
    class Point {
    //ostream是cout这个对象的类型
    	friend ostream &operator<<(ostream &, const Point &);
    	int m_x;
    	int m_y;
    public:
    	Point(int x, int y);
    	// 运算符（操作符）重载
    	Point operator+(const Point &point) const;
    	Point operator-(const Point &point) const;
    	const Point operator-() const;
    	Point &operator+=(const Point &point);
    	Point &operator-=(const Point &point);
    	bool operator==(const Point &point);
    	bool operator!=(const Point &point);
    	// 前++
    	Point &operator++();
    	// 后++
    	const Point operator++(int);
    };
    
    //Point.m
    #include "Point.h"

    Point::Point(int x, int y) :m_x(x), m_y(y) { }
    
    // 运算符（操作符）重载
    Point Point::operator+(const Point &point) const {
    	return Point(this->m_x + point.m_x, this->m_y + point.m_y);
    }
    
    Point Point::operator-(const Point &point) const {
    	return Point(this->m_x - point.m_x, this->m_y - point.m_y);
    }
    
    const Point Point::operator-() const {
    	return Point(-this->m_x, -this->m_y);
    }
    
    Point &Point::operator+=(const Point &point) {
    	this->m_x += point.m_x;
    	this->m_y += point.m_y;
    	return *this;
    }
    
    Point &Point::operator-=(const Point &point) {
    	this->m_x -= point.m_x;
    	this->m_y -= point.m_y;
    	return *this;
    }
    
    bool Point::operator==(const Point &point) {
    	// 1 YES true
    	// 0 NO false
    	/*if (this->m_x == point.m_x && this->m_y == point.m_y) {
    		return 1;
    	}
    	else {
    		return 0;
    	}*/
    	return (this->m_x == point.m_x) && (this->m_y == point.m_y);
    }
    
    bool Point::operator!=(const Point &point) {
    	return (this->m_x != point.m_x) || (this->m_y != point.m_y);
    }
    
    // 前++
    Point &Point::operator++() {
    	this->m_x++;
    	this->m_y++;
    	return *this;
    }
    
    // 后++
    const Point Point::operator++(int) {
    	Point point(this->m_x, this->m_y);
    	this->m_x++;
    	this->m_y++;
    	return point;
    }
    
    //cout
    //ostream是cout这个对象的类型
    ostream &operator<<(ostream &cout, const Point &point) {
    	return cout << "(" << point.m_x << ", " << point.m_y <<")";
    }
    ```
4. 模仿C++标准库函数string（**好好研究研究！！！！**）
    1. 封装1：
        
        ```
        //String.h 文件
        #pragma once
        #include<iostream>
        using namespace std;
        class String
        {
        	//搞定字符串的打印
        	friend ostream &operator<<(ostream &, String &);
        private:
        	char *m_cstring;
        public:
        	//搞定字符串的赋值（隐式构造）
        	String(const char *cstring);
        	//拷贝构造
        	String(const String &string);
        	~String();
        	//搞定字符串的修改(=右边接收c字符串)
        	String &operator=(const char *cstring);
        	//搞定String的赋值(= 右边接收c字符串接收String)
        	String &operator=(const String &string);
        };
        
        //String.cpp文件
        #include "String.h"

        String::String(const char *cstring)
        {
        	if (!cstring) return;
        	cout << "String(const char *) - new[] - " << cstring << endl;
        	this->m_cstring = new char[strlen(cstring) + 1]{};
        	strcpy(this->m_cstring, cstring);
        
        }
        
        String::String(const String &string) {
        	 *this = string.m_cstring;
        	 //等价
        	 //(*this).operator=(string.m_cstring);
        }
        
        String::~String()
        {
        	
        	cout << "~String() - delete[] - " << this->m_cstring << endl;
        	/*
        	if (!this->m_cstring) return;
        	delete[] this->m_cstring;
        	this->m_cstring = NULL;*/
        	//上面3句等价于这一句，这句会调用下面的String &String ::operator=(const char *）函数
        	//本质是一样的
        	operator=(NULL);
        
        	//下面都等价
        	// *this = NULL;
        	/*
        	(*this).operator=(NULL);
        	this->operator=(NULL);
        	operator=(NULL);
        	*/
        }
        
        
        ostream &operator<<(ostream &cout, String &string) {
        	if (!string.m_cstring) return cout;
        	return cout << string.m_cstring;
        }
        
        //搞定字符串的修改
        String &String ::operator=(const char *cstring) {
        	//防止“自己= 自己”
        	if (this->m_cstring == cstring)  return *this;
        
        	//释放旧的字符串
        	if (this->m_cstring){
        		cout << "delete[] - " << this->m_cstring << endl;
        		delete[] this->m_cstring;
        		this->m_cstring = NULL;
        	}
        	//指向新的字符串
        	if (cstring){
        		cout << "new[] - " << cstring << endl;
        		this->m_cstring = new char[strlen(cstring) + 1]{};
        		strcpy(this->m_cstring, cstring);
        	}
        	cout << "String &String ::operator=(const char *)" << endl;
        	return *this;
         }
        
        String &String:: operator=(const String &string) {
        	return operator=(string.m_cstring);
        }
        
        ```
    2. 抽出一个函数
        
        ```
        //String.h文件
        #pragma once
        #include<iostream>
        using namespace std;
        class String
        {
        	//搞定字符串的打印
        	friend ostream &operator<<(ostream &, String &);
        private:
        	char *m_cstring;
        	//内部代码抽取
        	String &assign(const char *cstring);
        public:
        	//搞定字符串的赋值（隐式构造）
        	String(const char *cstring);
        	//拷贝构造
        	String(const String &string);
        	~String();
        	//搞定字符串的修改(=右边接收c字符串)
        	String &operator=(const char *cstring);
        	//搞定String的赋值(= 右边接收c字符串接收String)
        	String &operator=(const String &string);
        };
        
        //String.cpp文件
        #include "String.h"

        String::String(const char *cstring){

        	assign(cstring);
        }
        
        String::String(const String &string) {
        
        	 assign(string.m_cstring);
        }
        
        String::~String()
        {
        	assign(NULL);
        }
        
        
        //搞定字符串的修改
        String &String ::operator=(const char *cstring) {        
        	return assign(cstring);
         }
        
        String &String:: operator=(const String &string) {
        	//return operator=(string.m_cstring);
        	return assign(string.m_cstring);
        }
        
        String &String::assign(const char *cstring) {
        	// 指向一样的堆空间
        	if (this->m_cstring == cstring) return *this;
        
        	// 释放旧的字符串
        	if (this->m_cstring) {
        		cout << "delete[] - " << this->m_cstring << endl;
        
        		delete[] this->m_cstring;
        		this->m_cstring = NULL;
        	}
        
        	// 指向新的字符串
        	if (cstring) {
        		cout << "new[] - " << cstring << endl;
        
        		this->m_cstring = new char[strlen(cstring) + 1]{};
        		strcpy(this->m_cstring, cstring);
        	}
        
        	return *this;
        }
        
         ostream &operator<<(ostream &cout, String &string) {
        	if (!string.m_cstring) return cout;
        	return cout << string.m_cstring;
        }  
        ```
    3. 使用：
        
        ```
        int main() {
        	//1. C语言字符串
        	const char *name1 = "111";
        	const char *name2 = "222";
        	//这么写肯定不对的，字符串不支持拼接
        	//const char *name3 = name1 + name2;
        
        	//2. C++标准库带的字符串处理类 string（首字母小写）
        	string str1 = "xxx";
        	string str2 = "yyy";
        	string str3 = str1 + str2 + "zzz";
        
        	//下面我们通过string模仿一个相同功能的String
        
        	//1. 实现等于（通过隐式构造创建一个对象）
        	String strr = "123";
        	//等价于(隐式构造，前面讲过)
        	//String strr("123");
        	char name[] = "111";
        	String strr2 = name;
        	String strr3("222");
        
        	//2. 实现修改
        	String strr4 = "333";
        	//这句话等价于：String strr4r("333");  这个是隐式构造
        	//修改字符串（已存在对象 = （浅拷贝）匿名对象）
        	strr4 = "444";
        	//这句话有错误，因为“=”是浅拷贝，String("444")这个临时对象赋值给strr4，然后这个临时对象会释放
        	//那么此时strr4指向的是一个已经释放的堆空间内存,很危险，同时原来指向的那个对空间“333”，没有回收掉
        	//解决办法，重载=运算符
        
        	//3. 实现String的赋值
        	String strrr1 = "111";
        	String strrr2 = "222";
        	//这么写肯定错误，因为=右边不是字符串了，而是一个String对象，那第2步重载的=(字符串)，不能使用
        	//因此也需要重载 =(String)
        	strrr1 = strrr2;
        
        	//4. 拷贝构造
        	String strrr3 = "111";
        	//这个是拷贝构造！！！！（注意区分！！！）
        	String strrr4 = strr3;
        
        	//实现打印
        	cout << strr2<<strr3<<strr4 << endl;
        
        	getchar();
        	return 0;
        }
        ```
    
### 调用父类的运算符重载函数



