---
layout: post
title: 第十章 友元、内部类、局部类、运算符重载
category: CPP基础
tags: CPP基础
description: CPP基础
---  

## 友元
1. 友元包括友元函数和友元类
2. 如果将函数A(非成员函数)声明为类C的友元函数，那么函数A就能直接访问类C对象的所有成员
3. 如果将类A声明为类C的友元类，那么类A的所有成员函数都能直接访问类C对象的所有成员
4. 友元破坏了面向对象的封装性，但在某些频繁访问成员变量的地方可以提高性能
    
    ```
    class Point {
    	//友元函数：让add函数成为当前类的朋友，然后add函数就可以直接访问当前类的成员了
    	//这句话可以放在这个类的任何地方
    	friend Point add(const Point &, const Point &);
    
    	//友元类,Math成为当前类的友元类，那么在Math内部就可以直接访问当前类的所有成员
    	friend  class Math;
    	int m_x;
    	int m_y;
    public:
    	int getX() const { return this->m_x; }
    	int getY() const { return this->m_y; }
    	Point(int x, int y) :m_x(x), m_y(y) {
    
    	}
    };
    
    Point add(const Point &point1, const Point &point2) {
    
    	/*return Point(point1.getX()+point2.getX(),point1.getY()+point2.getY());*/
    	//直接访问Point类的所有成员
    	return Point(point1.m_x + point2.m_x, point1.m_y + point2.m_y);
    }
    
    class Math {
    	Point dele(const Point &point1, const Point &point2) {
    		/*return Point(point1.getX()-point2.getX(),point1.getY()-point2.getY());*/
    		//直接访问Point类的所有成员
    		return Point(point1.m_x - point2.m_x, point1.m_y - point2.m_y);
    	}
    };
    
    int main() {
    	Point point(10, 20);
    	Point point2(20, 30);
    	Point point3 = add(point, point2);
    
    	cout << endl;
    	getchar();
    	return 0;
    }
    ```

## 内部类
1. 如果将类A定义在类C的内部，那么类A就是一个内部类(嵌套类)
2. 内部类的特点
    1. 支持public、protected、private权限
    2. 成员函数可以直接访问其外部类对象的所有成员(反过来则不行)
    3. 成员函数可以直接不带类名、对象名访问其外部类的static成员
    4. 不会影响外部类的内存布局
    5. 可以在外部类内部声明，在外部类外面进行定义
    
    ```
    class Person {
    	int m_age;
    	static int ms_legs;
    	static void test(){}
    
    public:
    	Person() {
    		cout << "Person()" << endl;
    	}
    //1.支持public、protected、private权限
    //Car内只能在Person内部使用
    //private:  
    	//car
    	class Car {
    		int m_price;
    	public:
    		Car() {
    			cout << "Car()" << endl;
    		}
    		void run() {
    			//2. 成员函数可以直接访问其外部类对象的所有成员(反过来则不行)
    			Person perosn;
    			perosn.m_age = 10;
    
    			//3. 成员函数可以直接不带类名、对象名访问其外部类的static成员
    			ms_legs = 10;	
    			test();
    		}
    	};
    };
    int Person::ms_legs = 2;
    
    //5. 可以在外部类内部声明，在外部类外面进行定义
    class Point {
    	class Math {
    		void test();
    	};
    };
    
    void Point::Math::test() {
    
    }
    
    int main() {
    	//使用
    	Person person;
    	Person::Car car;
    
    	getchar();
    	return 0;
    }
    ```
3. 内部类 – 声明和实现分离
    ![图1](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/cpp14.png)
4. 内部类的使用场合
    1. 某个类仅仅在一个类中使用

## 局部类
1. 在一个函数内部定义的类，称为局部类
2. 局部类的特点
    1. 作用域仅限于所在的函数内部
    2. 其所有的成员必须定义在类内部，不能类内部声明外部定义了，不允许定义static成员变量
    3. 成员函数不能直接访问函数的局部变量(static变量除外)
    
    ```
    int g_age = 10;
    void test() {
    	int age = 10;
    	static int s_age = 20;
    	//局部类
    	class Person {
    	public:
    		static void test() {
    		//成员函数不能直接访问函数的局部变量(static变量除外)
    		//age;
    		//全局变量可以
    		g_age = 20;
    		//静态变量可以
    		s_age;
    
    		}
    	};
    
    	Person person;
    	person.test();
    }
    
    int main() {
    	//注意：并不是每调一次都会定义一次类，类是在编译时候就完成了，没事调用只是调用函数
    	test();
    
    	getchar();
    	return 0;
    }
    ```
## 运算符重载(operator overload)
1. 运算符重载(操作符重载):可以为已存在的运算符增加一些新的功能
2. 全局函数、成员函数都支持运算符重载
    
    ```
    #include<iostream>
    using namespace std;
    
    class Point {
    	friend Point operator+(Point & , Point &);
    	int m_x;
    	int m_y;
    public:
    	Point(int x,int y):m_x(x),m_y(y) {}
    	
    	//成员函数 运算符重载
    	Point operator-(Point &P) {
    		return Point(this->m_x - P.m_x, this->m_y - P.m_y);
    	}
    
    	void display() {
    		cout << "x = " << this->m_x << "-y = " << this->m_y << endl;
    	}
    };
    
    //局部函数
    //运算符(操作符)重载：operator运算符
    Point operator+(Point &P1, Point &p2) {
    
    	return Point(P1.m_x + p2.m_x, P1.m_y + p2.m_y);
    }
    int main() {
    	Point p1(20, 30);
    	Point p2(30, 40);
    
    	//如果想这么做肯定是不行的，但是如果把“+”重载就可以了
    	Point p3 = p1 + p2;
    	//等价
    	//Point p3 = operator+(p1, p2);
    	p3.display();
    
    	//成员函数
    	Point p4 = p1 - p2;
    	//等价
    	//Point p4 = p1.operator-(p2);
    	p4.display();
    
    	getchar();
    	return 0;
    }
    ```



