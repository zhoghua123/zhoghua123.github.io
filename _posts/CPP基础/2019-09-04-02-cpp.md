---
layout: post
title: C/CPP与数据结构-第三节 树（一）
category: CPP基础
tags: CPP基础
description: CPP基础
--- 

## 树
1. 树的基本知识
    1. 树的定义：
        1. 由一个或多个（n>=0）节点组成的有限集合T，有且仅有一个结点称为**根（root）**，当n>1时，其余的结点分为m（m>=0）个**互不相交**的有限集合T1,T2,...,Tm。每个集合本身又是一棵树，被称作这个根的**子树**。
        2. 注意：过去许多书籍中都定义n>=1,曾经有**空树不是树**的说法，但现在定义已改。
        3. 树的定义具有递归性，即树中还有数。
    2. 常见的术语：

        ```
        根： 即根结点(没有前驱)
        叶子： 即终端结点(没有后继)
        森林： 指m棵不相交的树的集合(例如删除A后的子树个数)
        有序树： 结点各子树从左至右有序，不能互换（左为第一）
        无序树： 结点各子树可互换位置。
        双亲： 即上层的那个结点(直接前驱) parent
        孩子： 即下层结点的子树 (直接后继) child
        兄弟： 同一双亲下的同层结点（孩子之间互称兄弟）sibling
        堂兄弟：即双亲位于同一层的结点（但并非同一双亲）cousin 
        祖先： 即从根到该结点所经分支的所有结点
        子孙： 即该结点下层子树中的任一结点
        结点： 即树的数据元素
        结点的度： 结点挂接的子树数（有几个直接后继就是几度，亦称“次数”）
        结点的层次： 从根到该结点的层数（根结点算第一层）
        终端结点： 即度为0的结点，即叶子
        分支结点： 除树根以外的结点（也称为内部结点）
        树的度： 所有结点度中的最大值（Max{各结点的度}）
        树的深度(或高度)： 指所有结点中最大的层数（Max{各结点的层次}）
        ```
    3. 树的表示法有几种：
        1. 图形表示法
        2. 嵌套集合表示法
        3. 广义表表示法 : `( A ( B ( E ( K, L ), F ), C ( G ), D ( H ( M ), I, J ) ) )`
        4. 目录表示法
        5. 左孩子－右兄弟表示法
            1. 就是将一棵树转化为二叉树
            
            ![图4](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/cpp48.png)
    
    4. 树的逻辑结构 
        1. (特点)： 一对多（1:n），有多个直接后继（如家谱树、目录树等等），但只有一个根结点，且子树之间互不相交。 
    5. 树的存储结构 
        1. 树是非线性结构，该怎样存储？
            1. 仍然有顺序存储、链式存储等方式。 
        2. 树的顺序存储方案应该怎样制定？
            1. 可规定为：从上至下、从左至右将树的结点依次存入内存。
            2. 重大缺陷：复原困难（不能唯一复原就没有实用价值）。
        3. 树的链式存储方案应该怎样制定？ 
            1. 可用多重链表：一个前趋指针，n个后继指针。
                1. 细节问题：树中结点的结构类型样式该如何设计？
                2. 即应该设计成“等长”还是“不等长”？
            2. 缺点：等长结构太浪费（每个结点的度不一定相同）；不等长结构太复杂（要定义好多种结构类型）。
        4. 计算机如何实现各种不同进制的运算？
            1. 实现思路：先研究最简单、最有规律的二进制运算规律，然后设法把各种不同进制的运算转化二进制运算。
        5. 树的存储可否借鉴这种思路呢？
            1. **解决思路：先研究最简单、最有规律的树，然后设法把一般的树转化为这种简单的树** 

## 二叉树
1. 为何要重点研究每结点最多只有两个 “叉” 的树？
    1. 二叉树的结构最简单，规律性最强；
    2. 可以证明，所有树都能转为唯一对应的二叉树，不失一般性 
2. 二叉树的定义：
    1. 定义：是n（n≥0）个结点的有限集合，由一个根结点以及两棵互不相交的、分别称为**左子树**和**右子树**的二叉树组成 。
    2. 逻辑结构：  一对二（1：2）
    3. 基本特征:
        1. **每个结点最多只有两棵子树（不存在度大于2的结点）；**
        2. **左子树和右子树次序不能颠倒（有序树）。**
    4. 问：具有3个结点的二叉树可能有几种不同形态？（5种） 普通树呢？（2种）
        ![图4](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/cpp49.png)
        
        1. 二叉树5种：
            1. 2、3、4、5有什么不同呢？ 
            2. 左子树/右子树的不同
        2. 普通树2种：
            1. 没有左子树、右子树的概念，因此2、3、4、5相同，只有2种
3. 二叉树的性质
    1. 性质1：在二叉树的第i层上至多有2(i次方)-1个结点（i>0）。
    2. 性质2：深度为k的二叉树至多有2(k次方)-1个结点（k>0）。
    3. 性质3：对于任何一棵二叉树，若2度的结点数有n2个，则叶子数（n0）必定为n2＋1 （即n0=n2+1）
        1. 即 叶子节点数= 度数为2的节点数 +1；
        2. 度数为2的节点：就是这个节点有2个子树
    4. 满二叉树：一棵深度为k 且有2(k次方) -1个结点的二叉树。（特点：每层都“充满”了结点）
    5. 完全二叉树：深度为k 的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k 的满二叉树中编号从1至n的结点一一对应。特点如下：
        1. k-1层一定是满二叉树
        2. 最后一层：右边有叶子左边一定右叶子。就是靠左
    6. 性质4：具有n个结点的完全二叉树的深度必为[log(2底数)n]＋1 
        1. 解释：[]取下值的意思，`2的n次方 = 13`，那么n一定是3<n<4,那么此时n就去3，这就是向下取值。那么结果：`3+1 = 4；`
    7. **性质5：对完全二叉树，若从上至下、从左至右编号，则编号为i 的结点，其左孩子编号必为2i，其右孩子编号必为2i＋1；其双亲的编号必为i/2（i＝1 时为根,除外）。** 
        
        ![图4](https://raw.githubusercontent.com/zhoghua123/imgsBed/master/cpp50.png)

4. 二叉树的存储
    1. 顺序存储接口
        1. 按二叉树的结点“自上而下、从左至右”编号，用一组连续的存储单元存储。
        2. 顺序存储后能否复原成唯一对应的二叉树形状？ 
            1. 若是完全/满二叉树则可以做到唯一复原。
            2. 而且有规律：下标值为i的双亲，其左孩子的下标值必为2i，其右孩子的下标值必为2i＋1（即性质5）
            3.  例如，对应[2]的两个孩子必为[4]和[5],即B的左孩子必是D,右孩子必为E。
        3. 讨论：不是完全二叉树怎么办？ 
            1. 一律转为完全二叉树！
            2. 方法很简单，将各层空缺处统统补上“虚结点”，其内容为空。 
            3. 缺点：浪费空间；插入、删除不便     
    2. 二叉树的链式存储
        1. 那么二叉树的链表还如何表示呢？ 
            1. 二叉链表示法
                1. 一个结构体分为：左孩子指针、数据域、右孩子指针
                2. 左孩子指针指向左孩子结构体，右孩子指针指向右孩子结构体
                3. 二叉链结点数据类型定义：
                    
                    ```
                    typedef struct BiTNode
                    {
                    	int data;
                    	struct BiTNode *lchild, *rchild;
                    }BiTNode, *BiTree;
                    ```
            3. 三叉链表示法：
                1. 如果需要倒查某结点的双亲，可以再增加一个双亲域（直接前趋）指针，将二叉链表变成三叉链表
                2. 一个结构体分为：左孩子指针、数据域、右孩子指针、双亲指针
                3. 三叉链结点数据类型定义：
                    
                    ```
                    typedef struct TriTNode 
                    {
                    	int data;
                    	//左右孩子指针
                    	struct TriTNode *lchild, *rchild;
                    	//双亲指针
                    	struct TriTNode *parent;
                    }TriTNode, *TriTree;
                    
                    ```

