---
layout: post
title: C/CPP与数据结构-第二节 栈tack和队列queue （一）
category: CPP基础
tags: CPP基础
description: CPP基础
--- 

## 栈stack
 1. 基本概念：
    1. 栈是一种特殊的线性表
    2. 栈仅能在线性表的一端进行操作
        1. 栈顶(Top)：允许操作的一端
        2. 栈底(Bottom)：不允许操作的一端
    3. **栈的插入操作，叫做进栈，也称压栈、入栈。类似子弹入弹夹**
    4. **栈的删除操作，叫做出栈，也有的叫做弹栈。如同弹夹中的子弹出夹**
2. stack的常用操作
    
    ```
    #ifndef _MY_STACK_H_
    #define _MY_STACK_H_
    
    typedef void Stack;
    //创建栈
    Stack* Stack_Create();
    //销毁栈
    void Stack_Destroy(Stack* stack);
    //清空栈
    void Stack_Clear(Stack* stack);
    //进栈
    int Stack_Push(Stack* stack, void* item);
    //出栈
    void* Stack_Pop(Stack* stack);
    //获取栈顶元素
    void* Stack_Top(Stack* stack);
    //获取栈的大小 
    int Stack_Size(Stack* stack);
    
    #endif //_MY_STACK_H_
    ```

### 栈的顺序存储设计与实现
1. 技术分析：
    1. 可以直接用线性表的顺序存储来实现
    2. 那么是头部插入还是尾部插入呢？ 
        1. 头部插入，需要把原来的每个结点都要后移一位，耗时，因此尾部插入最好
    3. 弹出、压入栈，就相当于线性表顺序存储删除、加入最后一个节点
2. 代码示例：
    
    ```
    //seqstack.h文件
    #ifndef _MY_STACK_H_
    #define _MY_STACK_H_
    
    typedef void SeqStack;
    
    SeqStack* SeqStack_Create(int capacity);
    
    void SeqStack_Destroy(SeqStack* stack);
    
    void SeqStack_Clear(SeqStack* stack);
    
    int SeqStack_Push(SeqStack* stack, void* item);
    
    void* SeqStack_Pop(SeqStack* stack);
    
    void* SeqStack_Top(SeqStack* stack);
    
    int SeqStack_Size(SeqStack* stack);
    
    int SeqStack_Capacity(SeqStack* stack);
    #endif //_MY_STACK_H_
    
    //seqstack.c文件
    #define _CRT_SECURE_NO_WARNINGS
    #include<stdlib.h>
    #include<string.h>
    #include<stdio.h>
    #include"seqstack.h"
    #include"seqlist.h"//线性表的顺序存储
    
    //创建栈相当于创建一个线性表
    SeqStack* SeqStack_Create(int capacity) {
    	
    	return SeqList_Create(capacity);;
    }
    //销毁栈相当于销毁一个线性表
    void SeqStack_Destroy(SeqStack* stack) {
    
    	 SeqList_Destroy(stack);
    }
    
    //清空栈相当于清空线性表
    void SeqStack_Clear(SeqStack* stack) {
    
    	 SeqList_Clear(stack);
    }
    
    //栈插入元素，相当于在线性表的尾部添加元素
    int SeqStack_Push(SeqStack* stack, void* item) {
    
    	return SeqList_Insert(stack, item, SeqList_Length(stack));
    }
    //栈弹出元素，相当于从线性表的尾部删除元素
    void* SeqStack_Pop(SeqStack* stack) {
    
    	return SeqList_Delete(stack, SeqList_Length(stack)-1);;
    }
    
    //获取栈顶部元素，相当于获取线性表的尾部元素
    void* SeqStack_Top(SeqStack* stack) {
    
    	return SeqList_Get(stack, SeqList_Length(stack)-1);
    }
    //栈的大小，线性表的长度
    int SeqStack_Size(SeqStack* stack) {
    
    	return SeqList_Length(stack);
    }
    
    //栈的容量，相当于线性表的容量
    int SeqStack_Capacity(SeqStack* stack) {
    	
    	return SeqList_Capacity(stack);
    }
    
    //main.c使用
    #define _CRT_SECURE_NO_WARNINGS
    #include<stdlib.h>
    #include<string.h>
    #include<stdio.h>
    #include"seqstack.h"
    
    void main() {
    	int i = 0;
    	int a[10];
    	SeqStack *stack = NULL;
    	for (i = 0; i < 10; i++)
    	{
    		a[i] = i + 1;
    	}
    	//创建栈
    	stack = SeqStack_Create(10);
    	//往栈中压入数据
    	for ( i = 0; i < 10; i++)
    	{
    		SeqStack_Push(stack, &a[i]);
    	}
    	//栈的属性
    	printf("len:%d \n", SeqStack_Size(stack));
    	printf("capacity:%d \n",SeqStack_Capacity(stack));
    
    	printf("top:%d \n", *((int *)SeqStack_Top(stack)));
    
    	//元素出栈
    	while (SeqStack_Size(stack)>0)
    	{
    		printf("pop:%d \n", *((int *)SeqStack_Pop(stack)));
    	}
    	//销毁栈
    	SeqStack_Destroy(stack);
    
    	system("pause");
    	return;
    }
    ```

### 栈的链式存储设计与实现
1. 技术分析
    1. 同栈的顺序存储相似，栈的链式存储也可以用线性表的链式存储来做
    2. 那么是头部插入还是尾部插入呢？ 
        1. 尾部插入需要遍历到尾部然后再插入，比较耗时
        2. 因此采用头部插入最好

