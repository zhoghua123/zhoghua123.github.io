---
layout: post
title: 第六章 多态、虚函数、虚函数表
category: CPP基础
tags: CPP基础
description: CPP基础
--- 

## 多态
### 父类指针、子类指针
1. 父类指针可以指向子类对象，是安全的，开发中经常用到(**继承方式必须是public**)
2. 子类指针指向父类对象是不安全的

### 多态
1. 默认情况下，编译器只会根据指针类型调用对应的函数，不存在多态
    
    ```
    class Animal {
    public:
    	void run() {
    		cout << "Animal-run()" << endl;
    	}
    };
    class Cat: public Animal {
    public:
    	void run() {
    		cout << "Cat-run()" << endl;
    	}
    };
    
    class Dog : public Animal {
    public:
    	void run() {
    		cout << "Dog-run()" << endl;
    	}
    };
    
    //使用
    Animal *cat = new Cat();
    cat->run();
    //打印结果,并不会调用Cat-run()
    //Animal-run()
    ```
2. 多态是面向对象非常重要的一个特性
    1. 同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果
    2. 在**运行时**，可以识别出真正的对象类型，调用对应子类中的函数
3. 多态的要素
    1. 子类重写父类的成员函数(override)（父类的成员函数必须是虚函数！）
    2. 父类指针指向子类对象
    3. 利用父类指针调用重写的成员函数
    
## 虚函数
1. C++中的多态通过虚函数(virtual function)来实现
2. 虚函数:被virtual修饰的成员函数
3. 只要在父类中声明为虚函数，子类中重写的函数也自动变成虚函数(也就是说子类中可以省略virtual关键字)
    
    ```
    class Animal {
    public:
    	virtual void run() {
    		cout << "Animal-run()" << endl;
    	}
    };
    class Cat: public Animal {
    public:
    	void run() {
    		cout << "Cat-run()" << endl;
    	}
    };
    
    class Dog : public Animal {
    public:
    	void run() {
    		cout << "Dog-run()" << endl;
    	}
    };
    
    void liu(Animal *animal) {
    	animal->run();
    }
    
    //调用
    liu(new Dog());
    liu(new Cat());
    
    //打印
    //Cat-run()
    //Dog-run()
    ```
4. 注意：你要使用哪个父类指针做多态，那么**至少**在那个父类指针或父类的父类用virtual修饰
    1. 意思就是如果virtual修饰的事Dog的run，而你用Animal修饰，那就不行！！！
        
        ```
        class Animal {
        public:
        	void run() {
        		cout << "Animal-run()" << endl;
        	}
        };
        class Dog : public Animal {
        public:
        	virtual	void run() {
        		cout << "Dog-run()" << endl;
        	}
        };
        
        class Erha : public Dog {
        public:
        	void run() {
        		cout << "Erha-run()" << endl;
        	}
        };
        
        int main() {
      
        	Animal *animal = new Animal();
        	animal->run();
        
        	Animal *animal1 = new Dog();
        	animal1->run();
        
        	Animal *animal2 = new Erha();
        	animal2->run();
        	
         //打印
        	//Animal-run()
        	//Animal-run()
        	//Animal-run()
        	}
        ```
5. **父类指针可以指向子类对象，继承方式必须是public**
    
    ```
    class Animal {
    public:
    	void run() {
    		cout << "Animal-run()" << endl;
    	}
    };
    //class 创建类默认继承是private
    class Dog : Animal {
    public:
    	virtual	void run() {
    		cout << "Dog-run()" << endl;
    	}
    };
    
    // 下面使用会报错
    Animal *animal1 = new Dog();
    animal1->run();
    ```

## 虚函数表
1. 虚函数的实现原理是虚表，这个虚表里面存储着最终需要调用的虚函数地址，这个虚表也叫虚函数表
    
    ```
    class Animal {
    public:
    	int m_age;
    	virtual void speak() {
    		cout << "Animal-speak()" << endl;
    	}
    	virtual void  run() {
    		cout << "Animal-run()" << endl;
    	}
    };
    class Cat : public Animal {
    
    public:
    	int m_life;
    	 void speak() {
    		cout << "Cat-speak()" << endl;
    	}
    	 void  run() {
    		cout << "Cat-run()" << endl;
    	}
    };
    
    int main() {
    	Animal *cat = new Cat();
    	cat->m_age = 20;
    	cat->speak();
    	cat->run();
    
    	getchar();
    	return 0;
    }
    ```
    
    2. 反汇编查看`cat->speak();cat->run();`这两句代码
        1. 将Animal类的2个virtual字段删掉，反汇编调用如下：
            
            ```
            cat->speak();
            //将当前对象的地址传给成员函数
            00A92428  mov         ecx,dword ptr [cat]  
            //call：固定地址
            00A9242B  call        Animal::speak (0A914C4h)  
            cat->run();
            00A92430  mov         ecx,dword ptr [cat] 
            //call ：固定地址 
            00A92433  call        Animal::run (0A914C9h)  
            ```
            
            1. 可以看出上面调用的结果分别是固定地址，**静态调用**。`call 地址`
        2. 将Animal类的2个virtual字段加上，反汇编调用如下：
            
            ```
            cat->speak();
            002929F1  mov         eax,dword ptr [cat]  
            002929F4  mov         edx,dword ptr [eax]  
            002929F6  mov         esi,esp  
            002929F8  mov         ecx,dword ptr [cat]  
            002929FB  mov         eax,dword ptr [edx]  
            //动态调用： call 寄存器
            002929FD  call        eax  
            cat->run();
            00292A06  mov         eax,dword ptr [cat]  
            00292A09  mov         edx,dword ptr [eax]  
            00292A0B  mov         esi,esp  
            00292A0D  mov         ecx,dword ptr [cat]  
            00292A10  mov         eax,dword ptr [edx+4]  
            //动态调用： call 寄存器
            00292A13  call        eax  
            ```
            
            1. 可以看出调用过程是**动态调用**的。`call 寄存器`


