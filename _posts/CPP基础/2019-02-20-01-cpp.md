---
layout: post
title: 第六章 多态、虚函数、虚函数表
category: CPP基础
tags: CPP基础
description: CPP基础
--- 

## 初始化列表与默认参数配合使用
1. 举例
    
    ```
    class Person {
    	int m_age;
    	int m_height;
    public:
    	Person(int age = 0,int height = 0):m_age(age),m_height(height) {
    
    	}
    };
    
    //使用
    Person perosn1;
    Person person2(18);
    Person person3(18, 190);
    ```
2. 如果函数声明和实现是分离的
    1. 初始化列表只能写在函数的实现中
    2. 默认参数只能写在函数的声明中（前面讲过）
        
    ```
    class Person {
    	int m_age;
    	int m_height;
    public:
    	//默认参数只能写在声明中
    	Person(int age = 0, int height = 0);
    };
    //构造函数的初始化列表只能写在实现中
    Person::Person(int age, int height) :m_age(age), m_height(height){
    
    }
    
    //使用
    Person perosn1;
    Person person2(18);
    Person person3(18, 190);
    ```

## 父类的构造函数
1. 子类的构造函数默认会**先**调用父类的无参构造函数
2. 如果子类的构造函数显式地调用了父类的有参构造函数，就不会再去默认调用父类的无参构造函数
    
    ```
    class Person {
    	int m_age;
    public:
    	Person() {
    		cout << "Person()" << endl;
    	}
    	Person(int age) : m_age(age) {
    		cout << "Person( int)" << endl;
    	}
    };
    
    class Student :Person {
    	int m_score;
    public:
    	Student() {
    		cout << "Student()" << endl;
    	}
    	
    	Student(int age, int score) :m_score(score),Person(age) {
    		//不能这么调用，否则就是创建一个临时Person对象了，不是原来的对象了
    		//Person(age)
    		cout << "Student( int ,int )" << endl;
    	}
    	Student(int age) :m_score(m_score) {
    
    		cout << "Student( int )" << endl;
    	}
    };
    //除了调用当前类的无参构造函数，而且会先调用父类的无参构造函数
    Student student;
    //不会调用父类无参的构造函数
    Student student2(18, 180);
    //还是会调用父类无参的构造函数
    Student student3(120);
    ```
3. 如果父类缺少无参构造函数，子类的构造函数必须显式调用父类的有参构造函数
    
    ```
    class Person {
    	int m_age;
    public:	
    	Person(int age) : m_age(age) {
    		cout << "Person( int)" << endl;
    	}
    };
    
    class Student :Person {
    	int m_score;
    public:
    	//根本不让你实现，因为父类没有无参构造函数
    	/*Student() {
    		cout << "Student()" << endl;
    	}
    	*/
    	/*Student(int age) :m_score(m_score) {
    
    		cout << "Student( int )" << endl;
    	}*/
    
    	//子类的构造函数必须显式调用父类的有参构造函数
    	Student(int age, int score) :m_score(score),Person(age) {
    		//不能这么调用，否则就是创建一个临时Person对象了，不是原来的对象了
    		//Person(age)
    		cout << "Student( int ,int )" << endl;
    	}
    };
    
    //使用
    Student student(18, 99);
    ```

## 继承体系下的构造函数相互调用示例

```
class Person {
	int m_age;
public:
	
	Person():Person(0) {
	}
	Person(int age) : m_age(age) {
	}
};

class Student :Person {
	int m_score;
public:
	Student() :Student(0,0) {
		cout << "Student()" << endl;
	}
	Student(int age, int score) :m_score(score),Person(age) {
		//不能这么调用，否则就是创建一个临时Person对象了，不是原来的对象了
		//Person(age)
	}
};
```

## 构造、析构顺序
1. 构造和析构的顺序相反
    
    ```
    struct Person
    {
    	Person() {
    		cout << "Person()" << endl;
    	}
    	~Person()
    	{
    		cout << "~Person()" << endl;
    	}
    };
    
    struct Student :Person
    {
    	Student() {
    		cout << "Student()" << endl;
    	}
    	~Student()
    	{
    		cout << "~Student()" << endl;
    	}
    };
    
    //调用
    Student *p = new Student;
    delete p;
    
    //打印
    Person()
    Student()
    ~Student()
    ~Person()
    ```


